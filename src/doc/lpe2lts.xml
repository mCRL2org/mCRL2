<?xml version="1.0"?>

<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"[
<!ENTITY lpe2lts "<function>lpe2lts</function>">
<!ENTITY option "<parameter>OPTION</parameter>">
<!ENTITY infile "<parameter>INFILE</parameter>">
<!ENTITY outfile "<parameter>OUTFILE</parameter>">
<!ENTITY format "<parameter>FORMAT</parameter>">
<!ENTITY default "<parameter>default</parameter>">
<!ENTITY debug "<parameter>debug</parameter>">
<!ENTITY internal "<parameter>internal</parameter>">
<!ENTITY opt_h "<option>-h</option>">
<!ENTITY opt_q "<option>-q</option>">
<!ENTITY opt_v "<option>-v</option>">
<!ENTITY opt_f "<option>-f</option>">
<!ENTITY opt_y "<option>-y</option>">
<!ENTITY opt_u "<option>-u</option>">
<!ENTITY opt_c "<option>-c</option>">
<!ENTITY opt_r "<option>-r</option>">
<!ENTITY opt_l "<option>-l</option>">
<!ENTITY opt_d "<option>-d</option>">
<!ENTITY opt_e "<option>-e</option>">
<!ENTITY opt_D "<option>-D</option>">
<!ENTITY opt_t "<option>-t</option>">
<!ENTITY opt_p "<option>-p</option>">
<!ENTITY opt_m "<option>-m</option>">
<!ENTITY opt_R "<option>-R</option>">
<!ENTITY opt_help "<option>--help</option>">
<!ENTITY opt_version "<option>--version</option>">
<!ENTITY opt_quiet "<option>--quiet</option>">
<!ENTITY opt_verbose "<option>--verbose</option>">
<!ENTITY opt_freevar "<option>--freevar</option>">
<!ENTITY opt_dummy "<option>--dummy</option>">
<!ENTITY opt_unused-data "<option>--unused-data</option>">
<!ENTITY opt_vector "<option>--vector</option>">
<!ENTITY opt_tree "<option>--tree</option>">
<!ENTITY opt_max "<option>--max</option>">
<!ENTITY opt_deadlock "<option>--deadlock</option>">
<!ENTITY opt_deadlock-detect "<option>--deadlock-detect</option>">
<!ENTITY opt_deadlock-trace "<option>--deadlock-trace</option>">
<!ENTITY opt_detect "<option>--detect</option>">
<!ENTITY opt_trace "<option>--trace</option>">
<!ENTITY opt_priority "<option>--priority</option>">
<!ENTITY opt_monitor "<option>--monitor</option>">
<!ENTITY opt_rewriter "<option>--rewriter</option>">
<!ENTITY opt_aut "<option>--aut</option>">
<!ENTITY opt_svc "<option>--svc</option>">
<!ENTITY opt_no-info "<option>--no-info</option>">
<!ENTITY stdin "<constant>stdin</constant>">
<!ENTITY stdout "<constant>stdout</constant>">
]>

<refentry id="lpe2lts">

<refmeta>
  <refentrytitle>lpe2lts</refentrytitle>
  <manvolnum>1</manvolnum>
</refmeta>

<refnamediv>
  <refname>lpe2lts</refname>
  <refpurpose>generate state space of an LPE</refpurpose>
</refnamediv>

<refsynopsisdiv>
  <cmdsynopsis>
    <command>&lpe2lts;</command>
    <arg choice="plain" rep="repeat"><arg choice="opt">&option;</arg></arg>
    <arg choice="opt">&infile;
    <arg choice="opt">&outfile;</arg>
    </arg>
  </cmdsynopsis>
</refsynopsisdiv>

<refsect1>
  <title>Description</title>
  <para>
    The &lpe2lts; tool generates state space of the linear process equation (LPE) in &infile; and
    saves the result to &outfile;. If &outfile; is not present,
    the state space is not stored.
  </para>
  <para>
    The format of &outfile; is determined by its extension (unless it is specified
     by an option). If the extension is unknown, the aut format will be used.
  </para>
</refsect1>

<refsect1>
<title>Options</title>
<para>
Mandatory arguments to long options are mandatory for short options too.
  <variablelist>
  <varlistentry>
    <term>&opt_h;</term>
    <term>&opt_help;</term>
    <listitem>
      <para>
        display help message and terminate
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_version;</term>
    <listitem>
      <para>
        display version information and terminate
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_q;</term>
    <term>&opt_quiet;</term>
    <listitem>
      <para>
        do not display warning messages
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_v;</term>
    <term>&opt_verbose;</term>
    <listitem>
      <para>
        display concise intermediate messages
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_f;</term>
    <term>&opt_freevar;</term>
    <listitem>
      <para>
        do not replace free variables in the LPE with dummy values
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_y;</term>
    <term>&opt_dummy;</term>
    <listitem>
      <para>
        replace free variables in the LPE with dummy values (default)
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_u;</term>
    <term>&opt_unused-data;</term>
    <listitem>
      <para>
        do not remove unused parts of the data specification
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_c;</term>
    <term>&opt_vector;</term>
    <listitem>
      <para>
        store state in a vector (fastest, default)
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_r;</term>
    <term>&opt_tree;</term>
    <listitem>
      <para>
        store state in a tree (for memory efficiency)
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_l;</term>
    <term>&opt_max;=NUM</term>
    <listitem>
      <para>
        Explore at most NUM states. After exploring of NUM states
        &lpe2lts; will stop, having generated a partial state space.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_d;</term>
    <term>&opt_deadlock;</term>
    <term>&opt_deadlock-detect;</term>
    <listitem>
      <para>
        Detect deadlocks (i.e. for every deadlock a message is
        printed). A deadlock is a state from which no transitions are
        possible. Can be used in combination with &opt_deadlock-trace;
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_e;</term>
    <term>&opt_deadlock-trace;</term>
    <listitem>
      <para>
         Write trace to each deadlock state to a file. For each
         deadlock found during the state-space exploration a unique
         file with extension .trc (trace) will be created containing
         one of the shortest traces from the initial state to the
         deadlock state. In this way all possible traces to a deadlock
         will be generated during the state-stace explorations. The
         length of the traces will not decrease during the generation.
         It is possible that two or more equal traces are generated.
         The traces can be pretty-printed and converted to other
         formats using 'tracepp'.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_D;</term>
    <term>&opt_detect;=NAME*</term>
    <listitem>
      <para>
         Detect actions from the list NAME* (i.e. print a message for every occurence).
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_t;</term>
    <term>&opt_trace;=NAME*</term>
    <listitem>
      <para>
         Write trace to each state that is reached with an action from
         NAME* to a file This option is similar to
         &opt_deadlock-trace;, but instead of deadlock traces the
         traces leading to an action from NAME*.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_p;</term>
    <term>&opt_priority;=NAME</term>
    <listitem>
      <para>
         Give priority to action NAME (i.e. if it is possible to
         execute an action NAME in some state, than make it the only
         executable action from that state).
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_m;</term>
    <term>&opt_monitor;</term>
    <listitem>
      <para>
         Print detailed status of generation. Once a level (in terms
         of breadth-first search) is completed, a message stating this
         is printed. After exploration of every 1000 states the
         following information is printed: current level, states
         explored, transitions explored, states seen. A state is
         explored if all its outgoing transitions have been explored.
         A state is seen if (at least) one of the transitions leading
         to it has been explored.
       </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_R;</term> <term>&opt_rewriter;=NAME</term>
    <listitem>
      <para>
         Use rewriter NAME (default 'inner'). &lpe2lts; makes heavy
         use of a term rewriting engine to manipulate with the data
         term of the LPE. The other options are:
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_aut;</term>
    <listitem>
      <para>
         force &outfile; to be in the aut format (implies
                        &opt_no-info;, see below)  
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_svc;</term>
    <listitem>
      <para>
         force &outfile; to be in the svc format
      </para>
    </listitem>
  </varlistentry>

   <varlistentry>
    <term>&opt_no-info;</term>
    <listitem>
      <para>
         Do not add state information to &outfile; Normally &lpe2lts;
         adds some information about the state vector to the output
         .svc file. This can options allows to ommit this
         information. It is not possible to add the state information
         to .aut files.
      </para>
    </listitem>
  </varlistentry>
  </variablelist>
</para>
</refsect1>

<refsect1>
<title>Author</title>
<para>
  Written by Muck van Weerdenburg. Please send all complaints, comments and bug
  reports to <email>bug@mcrl2.org</email>.
</para>
</refsect1>

</refentry>
