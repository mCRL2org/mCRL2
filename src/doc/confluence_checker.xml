<?xml version="1.0"?>

<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"[
<!ENTITY class_bdd_prover "<classname>BDD_Prover</classname>">
<!ENTITY class_confluence_checker "<classname>Confluence_Checker</classname>">
<!ENTITY class_invariant_checker "<classname>Invariant_Checker</classname>">
<!ENTITY class_disjointness_checker "<classname>Disjointness_Checker</classname>">
<!ENTITY class_bdd2dot "<classname>BDD2Dot</classname>">

<!ENTITY type_virtual "<type>virtual</type>">
<!ENTITY type_void "<type>void</type>">
<!ENTITY type_bool "<type>bool</type>">
<!ENTITY type_int "<type>int</type>">
<!ENTITY type_char_pointer "<type>char*</type>">
<!ENTITY type_aterm "<type>ATerm</type>">
<!ENTITY type_aterm_appl "<type>ATermAppl</type>">
<!ENTITY type_smt_solver_type "<type>SMT_Solver_Type</type>">
<!ENTITY type_rewrite_strategy "<type>RewriteStrategy</type>">

<!ENTITY confluence_checker_constructor "<function>Confluence_Checker::Confluence_Checker</function>">
<!ENTITY confluence_checker_check_confluence_and_mark "<function>Confluence_Checker::check_confluence_and_mark</function>">

<!ENTITY par_rewrite_strategy "<parameter>a_rewrite_strategy</parameter>">
<!ENTITY par_path_eliminator "<parameter>a_path_eliminator</parameter>">
<!ENTITY par_solver_type "<parameter>a_solver_type</parameter>">
<!ENTITY par_time_limit "<parameter>a_time_limit</parameter>">
<!ENTITY par_lpe "<parameter>a_lpe</parameter>">
<!ENTITY par_no_marking "<parameter>a_no_marking</parameter>">
<!ENTITY par_check_all "<parameter>a_check_all</parameter>">
<!ENTITY par_counter_example "<parameter>a_counter_example</parameter>">
<!ENTITY par_dot_file_name "<parameter>a_dot_file_name</parameter>">
<!ENTITY par_generate_invariants "<parameter>a_generate_invariants</parameter>">
<!ENTITY par_invariant "<parameter>a_invariant</parameter>">
<!ENTITY par_summand_number "<parameter>a_summand_number</parameter>">

<!ENTITY solver_ario "<constant>ario</constant>">
<!ENTITY solver_cvc_lite "<constant>cvc-lite</constant>">

<!ENTITY link_ario "<uri>http://www.eecs.umich.edu/~ario/</uri>">
<!ENTITY link_cvc "<uri>http://www.cs.nyu.edu/acsys/cvcl/</uri>">

<!ENTITY strat_jitty "<constant>GS_REWR_JITTY</constant>">

<!ENTITY stderr "<constant>stderr</constant>">

<!ENTITY const_strat_jitty "<constant>GS_REWR_JITTY</constant>">
<!ENTITY const_strat_jittyc "<constant>GS_REWR_JITTYC</constant>">
<!ENTITY const_strat_inner "<constant>GS_REWR_INNER</constant>">
<!ENTITY const_strat_innerc "<constant>GS_REWR_INNERC</constant>">
<!ENTITY const_true "<constant>true</constant>">
<!ENTITY const_false "<constant>false</constant>">

<!ENTITY inv "<literal>inv()</literal>">
<!ENTITY tau "<literal>tau</literal>">
<!ENTITY ctau "<literal>ctau</literal>">
]>

<refentry id="confluence_checker">

<refmeta>
<refentrytitle>confluence_checker</refentrytitle>
<manvolnum>7</manvolnum>
</refmeta>

<refnamediv>
<refname>confluence_checker</refname>
<refpurpose>
  a class that checks which &tau;-summands of an mCRL2 LPE are confluent and marks them by renaming their &tau;-actions to &ctau;
</refpurpose>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcprototype>
  <funcdef>&confluence_checker_constructor;</funcdef>
  <paramdef>&type_aterm_appl; &par_lpe;</paramdef>
  <paramdef>&type_rewrite_strategy; &par_rewrite_strategy; = &strat_jitty;</paramdef>
  <paramdef>&type_int; &par_time_limit;</paramdef>
  <paramdef>&type_bool; &par_path_eliminator;</paramdef>
  <paramdef>&type_smt_solver_type; &par_solver_type;</paramdef>
  <paramdef>&type_bool; &par_no_marking;</paramdef>
  <paramdef>&type_bool; &par_check_all;</paramdef>
  <paramdef>&type_bool; &par_counter_example;</paramdef>
  <paramdef>&type_bool; &par_generate_invariants;</paramdef>
  <paramdef>&type_char_pointer; &par_dot_file_name;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&confluence_checker_check_confluence_and_mark;</funcdef>
  <paramdef>&type_aterm_appl; &par_invariant;, &type_int; &par_summand_number;</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>
<para>
  Given an LPE,
  <literallayout>
    P(d: D) = ...
            + sum ei: Ei. ci(d, ei) -> ai(fi(d, ei)) . P(gi(d, ei))
            + ...
            + sum ej: Ej. cj(d, ej) -> tau . P(gj(d, ej))
            + ...;
  </literallayout>
  &tau;-summand <literal>j</literal> is confluent with summand <literal>i</literal> if the following condition holds
  for all <literal>d: D</literal>, for all <literal>ei: Ei</literal> and for all <literal>ej: Ej</literal>:
  <literallayout>
    (inv(d) /\ ci(d, ei) /\ cj(d, ej))
    =>
    (ci(gj(d, ej), ei) /\ cj(gi(d, ei), ej) /\ fi(d, ei) == fi(gj(d, ej), ei) /\ gi(gj(d, ej), ei) == gj(gi(d, ei), ej))
  </literallayout>
  where &inv; is the invariant specified using the parameter &par_invariant; of the function &confluence_checker_check_confluence_and_mark;.
  In case <literal>ai</literal> is also a &tau;-action, the formula above can be weakened to the following:
  <literallayout>
    (inv(d) /\ ci(d, ei) /\ cj(d, ej))
    =>
    (gi(d, ei) == gj(d, ej) \/ (ci(gj(d, ej), ei) /\ cj(gi(d, ei), ej) /\ gi(gj(d, ej), ei) == gj(gi(d, ei), ej)))
  </literallayout>
</para>

<para>
  The class &class_confluence_checker; can determine whether two summands are confluent
  in three ways and will indicate which of the methods was used while proving confluence.
  The three ways of determining confluence are as follows:
  <itemizedlist spacing='compact'>
    <listitem>
      <para>
        If summand number 1 has been proven confluent with summand number 2, summand
        number 2 is obviously confluent with summand number 1. This method of checking
        confluence is called checking confluence by symmetry. If two summands are
        confluent by symmetry, the class &class_confluence_checker; indicates this by
        printing a dot ('.').
      </para>
    </listitem>
    <listitem>
      <para>
        Another way of checking the confluence of two summands is determining whether
        the two summands are syntactically disjoint. Two summands are syntactically
        disjoint if the following holds:
        <itemizedlist spacing='compact'>
          <listitem>
            <para>
              The set of variables used by one summand is disjoint from the set
              of variables changed by the other summand and vice versa.
            </para>
          </listitem>
          <listitem>
            <para>
              The set of variables changed by one summand is disjoint from the set
              of variables changed by the other summand.
            </para>
          </listitem>
        </itemizedlist>
        If two summands are confluent because of syntactic disjointness, the class
        &class_confluence_checker; indicates this by printing a colon (':').
      </para>
    </listitem>
    <listitem>
      <para>
        The most time consuming way of checking the confluence of two summands is
        generating the confluence condition and then checking if this condition is a
        tautology using a prover for propositional formulas. If two summands are
        proven confluent using the prover, the class &class_confluence_checker;
        indicates this by printing a plus sign ('+').
        If the parameter &par_generate_invariants; is set to &const_true;, the class
        &class_confluence_checker;
        will try to prove that the reduced confluence condition is an invariant of the LPE,
        in case the confluence condition is not a tautology. If the reduced confluence
        condition is indeed an invariant, the two summands are proven confluent.
        The class &class_confluence_checker; indicates this by printing an 'i'.
      </para>
    </listitem>
  </itemizedlist>
</para>

<para>
  The class &class_confluence_checker; uses an instance of the class &class_bdd_prover;, an instance of the class &class_disjointness_checker; and
  an instance of the class &class_invariant_checker;
  to determine which &tau;-summands of an mCRL2 LPE are confluent. Confluent &tau;-summands will be marked by renaming their &tau;-actions to
  &ctau;. The constructor &confluence_checker_constructor; initializes the BDD based prover with the parameters &par_rewrite_strategy;,
  &par_time_limit;,
  &par_path_eliminator;, &par_solver_type; and the data specification of the LPE passed as parameter &par_lpe;. The
  parameter &par_rewrite_strategy; specifies which rewrite strategy is used by the prover's rewriter. It can be set to either
  &const_strat_inner;, &const_strat_innerc;, &const_strat_jitty; or &const_strat_jittyc;. The parameter &par_time_limit; specifies the maximum
  amount of time in seconds to be spent by the prover on proving a single formula. If &par_time_limit; is set to 0, no time limit will be enforced.
  The parameter &par_path_eliminator; specifies whether or not path elimination is applied. When path elimination is applied, the prover uses an
  SMT solver to remove inconsistent paths from BDDs. The parameter &par_solver_type; specifies which SMT solver is used for path elimination. 
  Either the SMT solver &solver_ario; or &solver_cvc_lite; can be used. To use one of these solvers, the directory containing the corresponding
  executable must be in the path. On June the 20th of 2006, Ario was available on &link_ario; and CVC Lite was available on &link_cvc;.
  If the parameter &par_path_eliminator; is set to &const_false;, the parameter &par_solver_type; is ignored.
</para>
<para>
  The parameter &par_dot_file_name;
  specifies whether a file in dot format of the resulting BDD is saved each time the prover cannot determine whether a formula is a contradiction
  or a tautology. If the parameter is set to 0, no .dot files are saved. If a string is passed as parameter &par_dot_file_name;, this string will
  be used as the prefix of the filenames. An instance of the class &class_bdd2dot; is used to save these files in dot format.
</para>
<para>
  If the parameter &par_counter_example; is set to &const_true;, a so called counter example is printed to &stderr; each time the prover
  indicates that two summands are not confluent. A counter example is a valuation for which the confluence condition to be proven does not hold.
</para>
<para>
  If the parameter &par_check_all; is set to &const_true;, the confluence of the &tau;-summands regarding all other summands will be checked.
  If the parameter is set to &const_false;, &class_confluence_checker; continues with the next &tau;-summand as soon as a summand is encountered
  that is not confluent with the current &tau;-summand.
</para>
<para>
  If the parameter &par_generate_invariants; is set, an invariant checker is used to check if the reduced confluence condition is an invariant of
  the LPE passed as parameter &par_lpe;. If the reduced confluence condition is an invariant, the two summands are confluent.
</para>
<para>
  The function &confluence_checker_check_confluence_and_mark; returns an LPE with all &tau;-actions of confluent &tau;-summands renamed to &ctau;,
  unless the parameter &par_no_marking; is set to &const_true;. In case the parameter &par_no_marking; was set to &const_true;, the confluent
  tau-summands will not be marked, only the results of the confluence checking will be displayed.
</para>
<para>
  If there already is an action named &ctau; present in the LPE passed as parameter &par_lpe;, an error will be reported.
</para>
</refsect1>

<refsect1>
<title>Preconditions</title>
<para>
  The following precondition has to be satisfied for &confluence_checker_constructor;:
  <itemizedlist>
    <listitem>
      <para>the argument passed as parameter &par_lpe; is a valid mCRL2 LPE</para>
    </listitem>
    <listitem>
      <para>
        the argument passed as parameter &par_time_limit; is greater than or equal to 0. If the argument is equal to 0, no time limit will be
        enforced
      </para>
    </listitem>
  </itemizedlist>
</para>
<para>
  The following precondition has to be satisfied for &confluence_checker_check_confluence_and_mark;:
  <itemizedlist>
    <listitem>
      <para>
        the argument passed as parameter &par_invariant; is a valid formula in internal mCRL2 format
      </para>
    </listitem>
    <listitem>
      <para>
        the argument passed as parameter &par_summand_number; corresponds with a summands of the LPE passed as parameter &par_lpe;.
        It lies in the interval from and including 1 upto and including the highest summand number
      </para>
    </listitem>
  </itemizedlist>
</para>
</refsect1>

<refsect1>
<title>Author</title>
<para>
  Written by Luc Engelen. Please send all complaints, comments and bug reports to <email>bug@mcrl2.org</email>.
</para>
</refsect1>

</refentry>
