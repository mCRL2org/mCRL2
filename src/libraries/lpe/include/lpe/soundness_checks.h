#ifndef LPE_SOUNDNESS_CHECKS_H
#define LPE_SOUNDNESS_CHECKS_H

// This file contains soundness checks for LPE terms.
// N.B. This file is automatically generated!

#include "libstruct.h"
#include "atermpp/aterm.h"
#include "atermpp/aterm_list.h"
#include "atermpp/aterm_appl.h"
#include "atermpp/aterm_traits.h"

namespace lpe {

using atermpp::aterm;
using atermpp::aterm_list;
using atermpp::aterm_appl;
using atermpp::aterm_traits;

// checks
// 1) if term t satisfies the predicate f
template <typename Term, typename CheckFunction>
bool check_term_argument(Term t, CheckFunction f)
{
  return f(t);
}

// checks
// 1) if term t is a list,
// 2) if the list has the proper minimum size
// 3) if all elements of the list satisfy the predicate f
template <typename Term, typename CheckFunction>
bool check_list_argument(Term t, CheckFunction f, unsigned int minimum_size)
{
  aterm term(aterm_traits<Term>::term(t));
  if (t.type() != AT_LIST)
    return false;
  aterm_list l(term);
  if (l.size() < minimum_size)
    return false;
  for (aterm_list::iterator i = l.begin(); i != l.end(); ++i)
  {
    if (!f(*i))
      return false;
  }
  return true;
}

template <typename Term>
bool check_rule_String(Term t)
{
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (a.size() > 0)
    return false;
  return true;
}

//--- begin
template <typename Term> bool check_rule_SortExpr(Term t);
template <typename Term> bool check_rule_SortId(Term t);
template <typename Term> bool check_rule_StructCons(Term t);
template <typename Term> bool check_rule_StructProj(Term t);
template <typename Term> bool check_rule_StringOrNil(Term t);
template <typename Term> bool check_rule_SortExprOrUnknown(Term t);
template <typename Term> bool check_rule_DataExpr(Term t);
template <typename Term> bool check_rule_DataVarId(Term t);
template <typename Term> bool check_rule_OpId(Term t);
template <typename Term> bool check_rule_BagEnumElt(Term t);
template <typename Term> bool check_rule_WhrDecl(Term t);
template <typename Term> bool check_rule_DataSpec(Term t);
template <typename Term> bool check_rule_SortDecl(Term t);
template <typename Term> bool check_rule_DataEqn(Term t);
template <typename Term> bool check_rule_DataExprOrNil(Term t);
template <typename Term> bool check_rule_MultAct(Term t);
template <typename Term> bool check_rule_ParamId(Term t);
template <typename Term> bool check_rule_Action(Term t);
template <typename Term> bool check_rule_ActId(Term t);
template <typename Term> bool check_rule_ProcExpr(Term t);
template <typename Term> bool check_rule_ProcVarId(Term t);
template <typename Term> bool check_rule_MultActName(Term t);
template <typename Term> bool check_rule_RenameExpr(Term t);
template <typename Term> bool check_rule_CommExpr(Term t);
template <typename Term> bool check_rule_Spec(Term t);
template <typename Term> bool check_rule_ProcEqnSpec(Term t);
template <typename Term> bool check_rule_ProcEqn(Term t);
template <typename Term> bool check_rule_LPESummand(Term t);
template <typename Term> bool check_rule_MultActOrDelta(Term t);
template <typename Term> bool check_rule_Assignment(Term t);
template <typename Term> bool check_rule_Init(Term t);
template <typename Term> bool check_rule_StateFrm(Term t);
template <typename Term> bool check_rule_DataVarIdInit(Term t);
template <typename Term> bool check_rule_RegFrm(Term t);
template <typename Term> bool check_rule_ActFrm(Term t);
template <typename Term> bool check_rule_PBES(Term t);
template <typename Term> bool check_rule_PropVarInst(Term t);
template <typename Term> bool check_rule_PBEqn(Term t);
template <typename Term> bool check_rule_FixPoint(Term t);
template <typename Term> bool check_rule_PropVarDecl(Term t);
template <typename Term> bool check_rule_PBExpr(Term t);
template <typename Term> bool check_term_ProcEqn(Term t);
template <typename Term> bool check_term_Hide(Term t);
template <typename Term> bool check_term_SortArrow(Term t);
template <typename Term> bool check_term_CommExpr(Term t);
template <typename Term> bool check_term_StateNot(Term t);
template <typename Term> bool check_term_IfThen(Term t);
template <typename Term> bool check_term_StateImp(Term t);
template <typename Term> bool check_term_PBESExists(Term t);
template <typename Term> bool check_term_Assignment(Term t);
template <typename Term> bool check_term_StateForall(Term t);
template <typename Term> bool check_term_SortId(Term t);
template <typename Term> bool check_term_StateNu(Term t);
template <typename Term> bool check_term_DataSpec(Term t);
template <typename Term> bool check_term_LPE(Term t);
template <typename Term> bool check_term_SpecV1(Term t);
template <typename Term> bool check_term_Tau(Term t);
template <typename Term> bool check_term_StateYaledTimed(Term t);
template <typename Term> bool check_term_DataEqnSpec(Term t);
template <typename Term> bool check_term_PBESOr(Term t);
template <typename Term> bool check_term_ProcVarId(Term t);
template <typename Term> bool check_term_ConsSpec(Term t);
template <typename Term> bool check_term_Sum(Term t);
template <typename Term> bool check_term_DataVarId(Term t);
template <typename Term> bool check_term_SortSpec(Term t);
template <typename Term> bool check_term_MapSpec(Term t);
template <typename Term> bool check_term_StateYaled(Term t);
template <typename Term> bool check_term_Choice(Term t);
template <typename Term> bool check_term_MultAct(Term t);
template <typename Term> bool check_term_PropVarInst(Term t);
template <typename Term> bool check_term_StateDelay(Term t);
template <typename Term> bool check_term_LPESummand(Term t);
template <typename Term> bool check_term_StructCons(Term t);
template <typename Term> bool check_term_Mu(Term t);
template <typename Term> bool check_term_ActNot(Term t);
template <typename Term> bool check_term_Block(Term t);
template <typename Term> bool check_term_Rename(Term t);
template <typename Term> bool check_term_Sync(Term t);
template <typename Term> bool check_term_ActExists(Term t);
template <typename Term> bool check_term_StateMu(Term t);
template <typename Term> bool check_term_StateFalse(Term t);
template <typename Term> bool check_term_PBESForall(Term t);
template <typename Term> bool check_term_StateTrue(Term t);
template <typename Term> bool check_term_BInit(Term t);
template <typename Term> bool check_term_PBESFalse(Term t);
template <typename Term> bool check_term_WhrDecl(Term t);
template <typename Term> bool check_term_DataAppl(Term t);
template <typename Term> bool check_term_StateDelayTimed(Term t);
template <typename Term> bool check_term_Nu(Term t);
template <typename Term> bool check_term_AtTime(Term t);
template <typename Term> bool check_term_ActOr(Term t);
template <typename Term> bool check_term_Comm(Term t);
template <typename Term> bool check_term_Delta(Term t);
template <typename Term> bool check_term_StateAnd(Term t);
template <typename Term> bool check_term_LMerge(Term t);
template <typename Term> bool check_term_ActForall(Term t);
template <typename Term> bool check_term_RenameExpr(Term t);
template <typename Term> bool check_term_Merge(Term t);
template <typename Term> bool check_term_ActSpec(Term t);
template <typename Term> bool check_term_Action(Term t);
template <typename Term> bool check_term_PBESAnd(Term t);
template <typename Term> bool check_term_StateMust(Term t);
template <typename Term> bool check_term_Seq(Term t);
template <typename Term> bool check_term_DataVarIdInit(Term t);
template <typename Term> bool check_term_Process(Term t);
template <typename Term> bool check_term_ActAnd(Term t);
template <typename Term> bool check_term_PBES(Term t);
template <typename Term> bool check_term_BagEnumElt(Term t);
template <typename Term> bool check_term_StateVar(Term t);
template <typename Term> bool check_term_ActAt(Term t);
template <typename Term> bool check_term_DataEqn(Term t);
template <typename Term> bool check_term_StateExists(Term t);
template <typename Term> bool check_term_StateMay(Term t);
template <typename Term> bool check_term_ParamId(Term t);
template <typename Term> bool check_term_PBESTrue(Term t);
template <typename Term> bool check_term_MultActName(Term t);
template <typename Term> bool check_term_IfThenElse(Term t);
template <typename Term> bool check_term_Nil(Term t);
template <typename Term> bool check_term_StateOr(Term t);
template <typename Term> bool check_term_StructProj(Term t);
template <typename Term> bool check_term_PBEqn(Term t);
template <typename Term> bool check_term_OpId(Term t);
template <typename Term> bool check_term_ActFalse(Term t);
template <typename Term> bool check_term_ActId(Term t);
template <typename Term> bool check_term_LPEInit(Term t);
template <typename Term> bool check_term_Allow(Term t);
template <typename Term> bool check_term_PropVarDecl(Term t);
template <typename Term> bool check_term_ActImp(Term t);
template <typename Term> bool check_term_ActTrue(Term t);

template <typename Term>
bool check_rule_SortExpr(Term t)
{
  return    check_rule_SortId(t)
         || check_term_SortArrow(t);
}

template <typename Term>
bool check_rule_SortId(Term t)
{
  return    check_term_SortId(t);
}

template <typename Term>
bool check_rule_StructCons(Term t)
{
  return    check_term_StructCons(t);
}

template <typename Term>
bool check_rule_StructProj(Term t)
{
  return    check_term_StructProj(t);
}

template <typename Term>
bool check_rule_StringOrNil(Term t)
{
  return    check_rule_String(t)
         || check_term_Nil(t);
}

template <typename Term>
bool check_rule_SortExprOrUnknown(Term t)
{
  return    check_rule_SortExpr(t);
}

template <typename Term>
bool check_rule_DataExpr(Term t)
{
  return    check_rule_DataVarId(t)
         || check_rule_OpId(t)
         || check_term_DataAppl(t);
}

template <typename Term>
bool check_rule_DataVarId(Term t)
{
  return    check_term_DataVarId(t);
}

template <typename Term>
bool check_rule_OpId(Term t)
{
  return    check_term_OpId(t);
}

template <typename Term>
bool check_rule_BagEnumElt(Term t)
{
  return    check_term_BagEnumElt(t);
}

template <typename Term>
bool check_rule_WhrDecl(Term t)
{
  return    check_term_WhrDecl(t);
}

template <typename Term>
bool check_rule_DataSpec(Term t)
{
  return    check_term_DataSpec(t);
}

template <typename Term>
bool check_rule_SortDecl(Term t)
{
  return    check_rule_SortId(t);
}

template <typename Term>
bool check_rule_DataEqn(Term t)
{
  return    check_term_DataEqn(t);
}

template <typename Term>
bool check_rule_DataExprOrNil(Term t)
{
  return    check_rule_DataExpr(t)
         || check_term_Nil(t);
}

template <typename Term>
bool check_rule_MultAct(Term t)
{
  return    check_term_MultAct(t);
}

template <typename Term>
bool check_rule_ParamId(Term t)
{
  return    check_term_ParamId(t);
}

template <typename Term>
bool check_rule_Action(Term t)
{
  return    check_term_Action(t);
}

template <typename Term>
bool check_rule_ActId(Term t)
{
  return    check_term_ActId(t);
}

template <typename Term>
bool check_rule_ProcExpr(Term t)
{
  return    check_rule_Action(t)
         || check_term_Process(t)
         || check_term_Delta(t)
         || check_term_Tau(t)
         || check_term_Sum(t)
         || check_term_Block(t)
         || check_term_Hide(t)
         || check_term_Rename(t)
         || check_term_Comm(t)
         || check_term_Allow(t)
         || check_term_Sync(t)
         || check_term_AtTime(t)
         || check_term_Seq(t)
         || check_term_IfThen(t)
         || check_term_IfThenElse(t)
         || check_term_BInit(t)
         || check_term_Merge(t)
         || check_term_LMerge(t)
         || check_term_Choice(t);
}

template <typename Term>
bool check_rule_ProcVarId(Term t)
{
  return    check_term_ProcVarId(t);
}

template <typename Term>
bool check_rule_MultActName(Term t)
{
  return    check_term_MultActName(t);
}

template <typename Term>
bool check_rule_RenameExpr(Term t)
{
  return    check_term_RenameExpr(t);
}

template <typename Term>
bool check_rule_CommExpr(Term t)
{
  return    check_term_CommExpr(t);
}

template <typename Term>
bool check_rule_Spec(Term t)
{
  return    check_term_SpecV1(t);
}

template <typename Term>
bool check_rule_ProcEqnSpec(Term t)
{
  return    check_term_LPE(t);
}

template <typename Term>
bool check_rule_ProcEqn(Term t)
{
  return    check_term_ProcEqn(t);
}

template <typename Term>
bool check_rule_LPESummand(Term t)
{
  return    check_term_LPESummand(t);
}

template <typename Term>
bool check_rule_MultActOrDelta(Term t)
{
  return    check_rule_MultAct(t)
         || check_term_Delta(t);
}

template <typename Term>
bool check_rule_Assignment(Term t)
{
  return    check_term_Assignment(t);
}

template <typename Term>
bool check_rule_Init(Term t)
{
  return    check_term_LPEInit(t);
}

template <typename Term>
bool check_rule_StateFrm(Term t)
{
  return    check_rule_DataExpr(t)
         || check_term_StateTrue(t)
         || check_term_StateFalse(t)
         || check_term_StateNot(t)
         || check_term_StateAnd(t)
         || check_term_StateOr(t)
         || check_term_StateImp(t)
         || check_term_StateForall(t)
         || check_term_StateExists(t)
         || check_term_StateMust(t)
         || check_term_StateMay(t)
         || check_term_StateYaled(t)
         || check_term_StateYaledTimed(t)
         || check_term_StateDelay(t)
         || check_term_StateDelayTimed(t)
         || check_term_StateVar(t)
         || check_term_StateNu(t)
         || check_term_StateMu(t);
}

template <typename Term>
bool check_rule_DataVarIdInit(Term t)
{
  return    check_term_DataVarIdInit(t);
}

template <typename Term>
bool check_rule_RegFrm(Term t)
{
  return    check_rule_ActFrm(t);
}

template <typename Term>
bool check_rule_ActFrm(Term t)
{
  return    check_rule_MultAct(t)
         || check_rule_DataExpr(t)
         || check_term_ActTrue(t)
         || check_term_ActFalse(t)
         || check_term_ActNot(t)
         || check_term_ActAnd(t)
         || check_term_ActOr(t)
         || check_term_ActImp(t)
         || check_term_ActForall(t)
         || check_term_ActExists(t)
         || check_term_ActAt(t);
}

template <typename Term>
bool check_rule_PBES(Term t)
{
  return    check_term_PBES(t);
}

template <typename Term>
bool check_rule_PropVarInst(Term t)
{
  return    check_term_PropVarInst(t);
}

template <typename Term>
bool check_rule_PBEqn(Term t)
{
  return    check_term_PBEqn(t);
}

template <typename Term>
bool check_rule_FixPoint(Term t)
{
  return    check_term_Mu(t)
         || check_term_Nu(t);
}

template <typename Term>
bool check_rule_PropVarDecl(Term t)
{
  return    check_term_PropVarDecl(t);
}

template <typename Term>
bool check_rule_PBExpr(Term t)
{
  return    check_rule_DataExpr(t)
         || check_term_PBESTrue(t)
         || check_term_PBESFalse(t)
         || check_term_PBESAnd(t)
         || check_term_PBESOr(t)
         || check_term_PBESForall(t)
         || check_term_PBESExists(t)
         || check_rule_PropVarInst(t);
}

// ProcEqn(DataVarId*, ProcVarId, DataVarId*, ProcExpr)
template <typename Term>
bool check_term_ProcEqn(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsProcEqn(a))
    return false;

  // check the children
  if (a.size() != 4)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_DataVarId<aterm>, 0))
    return false;
  if (!check_term_argument(a(1), check_rule_ProcVarId<aterm>))
    return false;
  if (!check_list_argument(a(2), check_rule_DataVarId<aterm>, 0))
    return false;
  if (!check_term_argument(a(3), check_rule_ProcExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// Hide(String*, ProcExpr)
template <typename Term>
bool check_term_Hide(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsHide(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_String<aterm>, 0))
    return false;
  if (!check_term_argument(a(1), check_rule_ProcExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// SortArrow(SortExpr, SortExpr)
template <typename Term>
bool check_term_SortArrow(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsSortArrow(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_SortExpr<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_SortExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// CommExpr(MultActName, StringOrNil)
template <typename Term>
bool check_term_CommExpr(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsCommExpr(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_MultActName<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_StringOrNil<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// StateNot(StateFrm)
template <typename Term>
bool check_term_StateNot(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsStateNot(a))
    return false;

  // check the children
  if (a.size() != 1)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_StateFrm<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// IfThen(DataExpr, ProcExpr)
template <typename Term>
bool check_term_IfThen(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsIfThen(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_DataExpr<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_ProcExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// StateImp(StateFrm, StateFrm)
template <typename Term>
bool check_term_StateImp(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsStateImp(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_StateFrm<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_StateFrm<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// PBESExists(DataVarId+, PBExpr)
template <typename Term>
bool check_term_PBESExists(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsPBESExists(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_DataVarId<aterm>, 1))
    return false;
  if (!check_term_argument(a(1), check_rule_PBExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// Assignment(DataVarId, DataExpr)
template <typename Term>
bool check_term_Assignment(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsAssignment(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_DataVarId<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_DataExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// StateForall(DataVarId+, StateFrm)
template <typename Term>
bool check_term_StateForall(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsStateForall(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_DataVarId<aterm>, 1))
    return false;
  if (!check_term_argument(a(1), check_rule_StateFrm<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// SortId(String)
template <typename Term>
bool check_term_SortId(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsSortId(a))
    return false;

  // check the children
  if (a.size() != 1)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_String<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// StateNu(String, DataVarIdInit*, StateFrm)
template <typename Term>
bool check_term_StateNu(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsStateNu(a))
    return false;

  // check the children
  if (a.size() != 3)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_String<aterm>))
    return false;
  if (!check_list_argument(a(1), check_rule_DataVarIdInit<aterm>, 0))
    return false;
  if (!check_term_argument(a(2), check_rule_StateFrm<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// DataSpec(SortSpec, ConsSpec, MapSpec, DataEqnSpec)
template <typename Term>
bool check_term_DataSpec(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsDataSpec(a))
    return false;

  // check the children
  if (a.size() != 4)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_term_SortSpec<aterm>))
    return false;
  if (!check_term_argument(a(1), check_term_ConsSpec<aterm>))
    return false;
  if (!check_term_argument(a(2), check_term_MapSpec<aterm>))
    return false;
  if (!check_term_argument(a(3), check_term_DataEqnSpec<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// LPE(DataVarId*, DataVarId*, LPESummand*)
template <typename Term>
bool check_term_LPE(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsLPE(a))
    return false;

  // check the children
  if (a.size() != 3)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_DataVarId<aterm>, 0))
    return false;
  if (!check_list_argument(a(1), check_rule_DataVarId<aterm>, 0))
    return false;
  if (!check_list_argument(a(2), check_rule_LPESummand<aterm>, 0))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// SpecV1(DataSpec, ActSpec, ProcEqnSpec, Init)
template <typename Term>
bool check_term_SpecV1(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsSpecV1(a))
    return false;

  // check the children
  if (a.size() != 4)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_DataSpec<aterm>))
    return false;
  if (!check_term_argument(a(1), check_term_ActSpec<aterm>))
    return false;
  if (!check_term_argument(a(2), check_rule_ProcEqnSpec<aterm>))
    return false;
  if (!check_term_argument(a(3), check_rule_Init<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// Tau()
template <typename Term>
bool check_term_Tau(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsTau(a))
    return false;

  // check the children
  if (a.size() != 0)
    return false;

  return true;
}

// StateYaledTimed(DataExpr)
template <typename Term>
bool check_term_StateYaledTimed(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsStateYaledTimed(a))
    return false;

  // check the children
  if (a.size() != 1)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_DataExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// DataEqnSpec(DataEqn*)
template <typename Term>
bool check_term_DataEqnSpec(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsDataEqnSpec(a))
    return false;

  // check the children
  if (a.size() != 1)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_DataEqn<aterm>, 0))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// PBESOr(PBExpr, PBExpr)
template <typename Term>
bool check_term_PBESOr(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsPBESOr(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_PBExpr<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_PBExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// ProcVarId(String, SortExpr*)
template <typename Term>
bool check_term_ProcVarId(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsProcVarId(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_String<aterm>))
    return false;
  if (!check_list_argument(a(1), check_rule_SortExpr<aterm>, 0))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// ConsSpec(OpId*)
template <typename Term>
bool check_term_ConsSpec(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsConsSpec(a))
    return false;

  // check the children
  if (a.size() != 1)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_OpId<aterm>, 0))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// Sum(DataVarId+, ProcExpr)
template <typename Term>
bool check_term_Sum(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsSum(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_DataVarId<aterm>, 1))
    return false;
  if (!check_term_argument(a(1), check_rule_ProcExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// DataVarId(String, SortExpr)
template <typename Term>
bool check_term_DataVarId(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsDataVarId(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_String<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_SortExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// SortSpec(SortDecl*)
template <typename Term>
bool check_term_SortSpec(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsSortSpec(a))
    return false;

  // check the children
  if (a.size() != 1)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_SortDecl<aterm>, 0))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// MapSpec(OpId*)
template <typename Term>
bool check_term_MapSpec(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsMapSpec(a))
    return false;

  // check the children
  if (a.size() != 1)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_OpId<aterm>, 0))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// StateYaled()
template <typename Term>
bool check_term_StateYaled(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsStateYaled(a))
    return false;

  // check the children
  if (a.size() != 0)
    return false;

  return true;
}

// Choice(ProcExpr, ProcExpr)
template <typename Term>
bool check_term_Choice(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsChoice(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_ProcExpr<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_ProcExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// MultAct(Action*)
template <typename Term>
bool check_term_MultAct(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsMultAct(a))
    return false;

  // check the children
  if (a.size() != 1)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_Action<aterm>, 0))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// PropVarInst(String, DataExpr*)
template <typename Term>
bool check_term_PropVarInst(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsPropVarInst(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_String<aterm>))
    return false;
  if (!check_list_argument(a(1), check_rule_DataExpr<aterm>, 0))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// StateDelay()
template <typename Term>
bool check_term_StateDelay(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsStateDelay(a))
    return false;

  // check the children
  if (a.size() != 0)
    return false;

  return true;
}

// LPESummand(DataVarId*, DataExpr, MultActOrDelta, DataExprOrNil, Assignment*)
template <typename Term>
bool check_term_LPESummand(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsLPESummand(a))
    return false;

  // check the children
  if (a.size() != 5)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_DataVarId<aterm>, 0))
    return false;
  if (!check_term_argument(a(1), check_rule_DataExpr<aterm>))
    return false;
  if (!check_term_argument(a(2), check_rule_MultActOrDelta<aterm>))
    return false;
  if (!check_term_argument(a(3), check_rule_DataExprOrNil<aterm>))
    return false;
  if (!check_list_argument(a(4), check_rule_Assignment<aterm>, 0))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// StructCons(String, StructProj*, StringOrNil)
template <typename Term>
bool check_term_StructCons(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsStructCons(a))
    return false;

  // check the children
  if (a.size() != 3)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_String<aterm>))
    return false;
  if (!check_list_argument(a(1), check_rule_StructProj<aterm>, 0))
    return false;
  if (!check_term_argument(a(2), check_rule_StringOrNil<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// Mu()
template <typename Term>
bool check_term_Mu(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsMu(a))
    return false;

  // check the children
  if (a.size() != 0)
    return false;

  return true;
}

// ActNot(ActFrm)
template <typename Term>
bool check_term_ActNot(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsActNot(a))
    return false;

  // check the children
  if (a.size() != 1)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_ActFrm<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// Block(String*, ProcExpr)
template <typename Term>
bool check_term_Block(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsBlock(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_String<aterm>, 0))
    return false;
  if (!check_term_argument(a(1), check_rule_ProcExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// Rename(RenameExpr*, ProcExpr)
template <typename Term>
bool check_term_Rename(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsRename(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_RenameExpr<aterm>, 0))
    return false;
  if (!check_term_argument(a(1), check_rule_ProcExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// Sync(ProcExpr, ProcExpr)
template <typename Term>
bool check_term_Sync(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsSync(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_ProcExpr<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_ProcExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// ActExists(DataVarId+, ActFrm)
template <typename Term>
bool check_term_ActExists(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsActExists(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_DataVarId<aterm>, 1))
    return false;
  if (!check_term_argument(a(1), check_rule_ActFrm<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// StateMu(String, DataVarIdInit*, StateFrm)
template <typename Term>
bool check_term_StateMu(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsStateMu(a))
    return false;

  // check the children
  if (a.size() != 3)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_String<aterm>))
    return false;
  if (!check_list_argument(a(1), check_rule_DataVarIdInit<aterm>, 0))
    return false;
  if (!check_term_argument(a(2), check_rule_StateFrm<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// StateFalse()
template <typename Term>
bool check_term_StateFalse(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsStateFalse(a))
    return false;

  // check the children
  if (a.size() != 0)
    return false;

  return true;
}

// PBESForall(DataVarId+, PBExpr)
template <typename Term>
bool check_term_PBESForall(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsPBESForall(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_DataVarId<aterm>, 1))
    return false;
  if (!check_term_argument(a(1), check_rule_PBExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// StateTrue()
template <typename Term>
bool check_term_StateTrue(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsStateTrue(a))
    return false;

  // check the children
  if (a.size() != 0)
    return false;

  return true;
}

// BInit(ProcExpr, ProcExpr)
template <typename Term>
bool check_term_BInit(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsBInit(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_ProcExpr<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_ProcExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// PBESFalse()
template <typename Term>
bool check_term_PBESFalse(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsPBESFalse(a))
    return false;

  // check the children
  if (a.size() != 0)
    return false;

  return true;
}

// WhrDecl(String, DataExpr)
template <typename Term>
bool check_term_WhrDecl(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsWhrDecl(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_String<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_DataExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// DataAppl(DataExpr, DataExpr)
template <typename Term>
bool check_term_DataAppl(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsDataAppl(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_DataExpr<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_DataExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// StateDelayTimed(DataExpr)
template <typename Term>
bool check_term_StateDelayTimed(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsStateDelayTimed(a))
    return false;

  // check the children
  if (a.size() != 1)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_DataExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// Nu()
template <typename Term>
bool check_term_Nu(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsNu(a))
    return false;

  // check the children
  if (a.size() != 0)
    return false;

  return true;
}

// AtTime(ProcExpr, DataExpr)
template <typename Term>
bool check_term_AtTime(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsAtTime(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_ProcExpr<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_DataExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// ActOr(ActFrm, ActFrm)
template <typename Term>
bool check_term_ActOr(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsActOr(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_ActFrm<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_ActFrm<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// Comm(CommExpr*, ProcExpr)
template <typename Term>
bool check_term_Comm(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsComm(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_CommExpr<aterm>, 0))
    return false;
  if (!check_term_argument(a(1), check_rule_ProcExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// Delta()
template <typename Term>
bool check_term_Delta(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsDelta(a))
    return false;

  // check the children
  if (a.size() != 0)
    return false;

  return true;
}

// StateAnd(StateFrm, StateFrm)
template <typename Term>
bool check_term_StateAnd(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsStateAnd(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_StateFrm<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_StateFrm<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// LMerge(ProcExpr, ProcExpr)
template <typename Term>
bool check_term_LMerge(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsLMerge(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_ProcExpr<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_ProcExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// ActForall(DataVarId+, ActFrm)
template <typename Term>
bool check_term_ActForall(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsActForall(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_DataVarId<aterm>, 1))
    return false;
  if (!check_term_argument(a(1), check_rule_ActFrm<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// RenameExpr(String, String)
template <typename Term>
bool check_term_RenameExpr(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsRenameExpr(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_String<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_String<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// Merge(ProcExpr, ProcExpr)
template <typename Term>
bool check_term_Merge(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsMerge(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_ProcExpr<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_ProcExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// ActSpec(ActId*)
template <typename Term>
bool check_term_ActSpec(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsActSpec(a))
    return false;

  // check the children
  if (a.size() != 1)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_ActId<aterm>, 0))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// Action(ActId, DataExpr*)
template <typename Term>
bool check_term_Action(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsAction(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_ActId<aterm>))
    return false;
  if (!check_list_argument(a(1), check_rule_DataExpr<aterm>, 0))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// PBESAnd(PBExpr, PBExpr)
template <typename Term>
bool check_term_PBESAnd(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsPBESAnd(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_PBExpr<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_PBExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// StateMust(RegFrm, StateFrm)
template <typename Term>
bool check_term_StateMust(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsStateMust(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_RegFrm<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_StateFrm<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// Seq(ProcExpr, ProcExpr)
template <typename Term>
bool check_term_Seq(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsSeq(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_ProcExpr<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_ProcExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// DataVarIdInit(String, SortExpr, DataExpr)
template <typename Term>
bool check_term_DataVarIdInit(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsDataVarIdInit(a))
    return false;

  // check the children
  if (a.size() != 3)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_String<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_SortExpr<aterm>))
    return false;
  if (!check_term_argument(a(2), check_rule_DataExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// Process(ProcVarId, DataExpr*)
template <typename Term>
bool check_term_Process(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsProcess(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_ProcVarId<aterm>))
    return false;
  if (!check_list_argument(a(1), check_rule_DataExpr<aterm>, 0))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// ActAnd(ActFrm, ActFrm)
template <typename Term>
bool check_term_ActAnd(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsActAnd(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_ActFrm<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_ActFrm<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// PBES(DataSpec, PBEqn*, PropVarInst)
template <typename Term>
bool check_term_PBES(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsPBES(a))
    return false;

  // check the children
  if (a.size() != 3)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_DataSpec<aterm>))
    return false;
  if (!check_list_argument(a(1), check_rule_PBEqn<aterm>, 0))
    return false;
  if (!check_term_argument(a(2), check_rule_PropVarInst<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// BagEnumElt(DataExpr, DataExpr)
template <typename Term>
bool check_term_BagEnumElt(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsBagEnumElt(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_DataExpr<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_DataExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// StateVar(String, DataExpr*)
template <typename Term>
bool check_term_StateVar(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsStateVar(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_String<aterm>))
    return false;
  if (!check_list_argument(a(1), check_rule_DataExpr<aterm>, 0))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// ActAt(ActFrm, DataExpr)
template <typename Term>
bool check_term_ActAt(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsActAt(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_ActFrm<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_DataExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// DataEqn(DataVarId*, DataExprOrNil, DataExpr, DataExpr)
template <typename Term>
bool check_term_DataEqn(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsDataEqn(a))
    return false;

  // check the children
  if (a.size() != 4)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_DataVarId<aterm>, 0))
    return false;
  if (!check_term_argument(a(1), check_rule_DataExprOrNil<aterm>))
    return false;
  if (!check_term_argument(a(2), check_rule_DataExpr<aterm>))
    return false;
  if (!check_term_argument(a(3), check_rule_DataExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// StateExists(DataVarId+, StateFrm)
template <typename Term>
bool check_term_StateExists(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsStateExists(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_DataVarId<aterm>, 1))
    return false;
  if (!check_term_argument(a(1), check_rule_StateFrm<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// StateMay(RegFrm, StateFrm)
template <typename Term>
bool check_term_StateMay(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsStateMay(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_RegFrm<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_StateFrm<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// ParamId(String, DataExpr*)
template <typename Term>
bool check_term_ParamId(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsParamId(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_String<aterm>))
    return false;
  if (!check_list_argument(a(1), check_rule_DataExpr<aterm>, 0))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// PBESTrue()
template <typename Term>
bool check_term_PBESTrue(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsPBESTrue(a))
    return false;

  // check the children
  if (a.size() != 0)
    return false;

  return true;
}

// MultActName(String+)
template <typename Term>
bool check_term_MultActName(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsMultActName(a))
    return false;

  // check the children
  if (a.size() != 1)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_String<aterm>, 1))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// IfThenElse(DataExpr, ProcExpr, ProcExpr)
template <typename Term>
bool check_term_IfThenElse(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsIfThenElse(a))
    return false;

  // check the children
  if (a.size() != 3)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_DataExpr<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_ProcExpr<aterm>))
    return false;
  if (!check_term_argument(a(2), check_rule_ProcExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// Nil()
template <typename Term>
bool check_term_Nil(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsNil(a))
    return false;

  // check the children
  if (a.size() != 0)
    return false;

  return true;
}

// StateOr(StateFrm, StateFrm)
template <typename Term>
bool check_term_StateOr(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsStateOr(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_StateFrm<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_StateFrm<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// StructProj(StringOrNil, SortExpr)
template <typename Term>
bool check_term_StructProj(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsStructProj(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_StringOrNil<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_SortExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// PBEqn(FixPoint, PropVarDecl, PBExpr)
template <typename Term>
bool check_term_PBEqn(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsPBEqn(a))
    return false;

  // check the children
  if (a.size() != 3)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_FixPoint<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_PropVarDecl<aterm>))
    return false;
  if (!check_term_argument(a(2), check_rule_PBExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// OpId(String, SortExpr)
template <typename Term>
bool check_term_OpId(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsOpId(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_String<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_SortExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// ActFalse()
template <typename Term>
bool check_term_ActFalse(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsActFalse(a))
    return false;

  // check the children
  if (a.size() != 0)
    return false;

  return true;
}

// ActId(String, SortExpr*)
template <typename Term>
bool check_term_ActId(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsActId(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_String<aterm>))
    return false;
  if (!check_list_argument(a(1), check_rule_SortExpr<aterm>, 0))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// LPEInit(DataVarId*, Assignment*)
template <typename Term>
bool check_term_LPEInit(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsLPEInit(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_DataVarId<aterm>, 0))
    return false;
  if (!check_list_argument(a(1), check_rule_Assignment<aterm>, 0))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// Allow(MultActName*, ProcExpr)
template <typename Term>
bool check_term_Allow(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsAllow(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_MultActName<aterm>, 0))
    return false;
  if (!check_term_argument(a(1), check_rule_ProcExpr<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// PropVarDecl(String, DataVarId*)
template <typename Term>
bool check_term_PropVarDecl(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsPropVarDecl(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_String<aterm>))
    return false;
  if (!check_list_argument(a(1), check_rule_DataVarId<aterm>, 0))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// ActImp(ActFrm, ActFrm)
template <typename Term>
bool check_term_ActImp(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsActImp(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifdef LPE_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_ActFrm<aterm>))
    return false;
  if (!check_term_argument(a(1), check_rule_ActFrm<aterm>))
    return false;
#endif // LPE_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// ActTrue()
template <typename Term>
bool check_term_ActTrue(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsActTrue(a))
    return false;

  // check the children
  if (a.size() != 0)
    return false;

  return true;
}


//--- end

} // namespace lpe

#endif // LPE_SOUNDNESS_CHECKS_H
