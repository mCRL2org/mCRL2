\documentclass{article}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[dvipsnames]{xcolor}

\setcounter{MaxMatrixCols}{10}

\font \aap cmmi10
\newcommand{\at}[1]{\mbox{\aap ,} #1}
\newcommand{\ap}{{:}}
\newcommand{\concat}{\ensuremath{+\!\!+}}
\newcommand{\tuple}[1]{\ensuremath{\langle {#1} \rangle}}
\newcommand{\vars}{\mathit{vars}}
\newtheorem{theorem}{Theorem}
\newtheorem{acknowledgement}[theorem]{Acknowledgement}
\newtheorem{algorithm}[theorem]{Algorithm}
\newtheorem{axiom}[theorem]{Axiom}
\newtheorem{case}[theorem]{Case}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{conclusion}[theorem]{Conclusion}
\newtheorem{condition}[theorem]{Condition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{criterion}[theorem]{Criterion}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{exercise}[theorem]{Exercise}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{notation}[theorem]{Notation}
\newtheorem{problem}[theorem]{Problem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{solution}[theorem]{Solution}
\newtheorem{summary}[theorem]{Summary}
\newenvironment{proof}[1][Proof]{\noindent\textbf{#1.} }{\ \rule{0.5em}{0.5em}}

\begin{document}

\title{PBES Generation}
\author{Wieger Wesselink, Tim Willemse}
\maketitle

This document describes the generation of PBESs. These algorithms are implemented in the tools
\textbf{lps2pbes} and \textbf{lpsbisim2pbes}.

\section{Transforming an LPS and a property to a PBES}

In this section we define the algorithm \textsc{lps2pbes} that generates a
PBES from a modal mu calculus property $\varphi$ and an LPS. Let $\langle {D_{p},d_{0},P}\rangle $
be the LPS given by

\begin{equation*}
\begin{array}{lrl}
\mathbf{proc}~P(x{:}D_{p}) & = & \sum_{i\in
I}\sum_{y_{i}:E_{i}}c_{i}(x,y_{i})\rightarrow a_{i}(f_{i}(x,y_{i}))%
\mbox{\aap ,}t_{i}(x,y_{i})\cdot P(g_{i}(x,y_{i})) \\
& + & \sum_{j\in J}\sum_{y_{i}:E_{j}}c_{j}(x,y_{i})\rightarrow \delta %
\mbox{\aap ,}t_{j}(x,y_{i});%
\end{array}%
\end{equation*}%
where $a_{i}(f_{i}(x,y))$ is a multiset of actions. Then we define
\begin{equation*}
\textsc{lps2pbes}(\sigma X(x_{f}:D_{f}:=d).~\varphi ,\langle {%
D_{p},d_{0},P}\rangle )=\mathbf{E}(\varphi ),
\end{equation*}%
where the function $\mathbf{E}$ is inductively defined using the tables
below. The function $\varphi $ has to be in positive normal form, i.e. it
may not contain any $\lnot $ or $\Rightarrow $ symbols. There is also an untimed variant
of the
algorithm, which can be obtained by removing all time references. A formula $
\varphi $ not of the form $\sigma X(x_{f}:D_{f}:=d).~\varphi $ is first
translated into $\nu X().~\varphi $. We assume that $T:\mathbb{R}$ is a
unique fresh time variable that is generated by the algorithm.
We denote the formula $\varphi$ that is passed to the algorithm \textsc{lps2pbes} as $\varphi_0$. It is used as a global variable in the translation.
\vspace{1cm}

%-------------------------------------%
%           function Sat
%-------------------------------------%
Let $a=\{a_{1},\ldots ,a_{n}\}$ and $b=\{b_{1},\ldots ,b_{n}\}$ be two multi
actions. Let $A$ be the set of all permutations $[i_{1},\ldots ,i_{n}]$ of $%
[1,\ldots n]$ such that $name(a_{k})=name(b_{i_{k}})$ for $k=1\ldots n$.
Then we define the function $\mathbf{Sat}$ as follows:

\begin{equation*}
\begin{array}{lll}
\mathbf{Sat}(a \mbox{\aap ,} t, b) & =_{def} & \left\{
\begin{array}{cc}
\bigvee\limits_{\lbrack i_{1},\ldots ,i_{n}]\in
A}\bigwedge\limits_{k=1\ldots n}(a_{k}=b_{i_{k}}) & \text{if }A\neq
\emptyset \\
false & \text{otherwise}%
\end{array}%
\right. \\
\mathbf{Sat}(a \mbox{\aap ,} t, c) & =_{def} & c \\
\mathbf{Sat}(a \mbox{\aap ,} t, \alpha \mbox{\aap ,} u) & =_{def} & \mathbf{%
Sat}(a \mbox{\aap ,} t, \alpha) \wedge t \approx u \\
\mathbf{Sat}(a \mbox{\aap ,} t, \neg \alpha) & =_{def} & \neg \mathbf{Sat}(a %
\mbox{\aap ,} t, \alpha) \\
\mathbf{Sat}(a \mbox{\aap ,} t, \alpha \wedge \beta) & =_{def} & \mathbf{Sat}%
(a \mbox{\aap ,} t, \alpha) \wedge \mathbf{Sat}(a \mbox{\aap ,} t, \beta) \\
\mathbf{Sat}(a \mbox{\aap ,} t, \alpha \vee \beta) & =_{def} & \mathbf{Sat}%
(a \mbox{\aap ,} t, \alpha) \vee \mathbf{Sat}(a \mbox{\aap ,} t, \beta) \\
\mathbf{Sat}(a \mbox{\aap ,} t, \alpha \Rightarrow \beta) & =_{def} &
\mathbf{Sat}(a \mbox{\aap ,} t, \alpha) \Rightarrow \mathbf{Sat}(a %
\mbox{\aap ,} t, \beta) \\
\mathbf{Sat}(a \mbox{\aap ,} t, \forall{x {:} D}. \alpha) & =_{def} & \forall%
{y {:} D}. (\mathbf{Sat}(a \mbox{\aap ,} t, \alpha[x := y]) \\
\mathbf{Sat}(a \mbox{\aap ,} t, \exists{x {:} D}. \alpha) & =_{def} & \exists%
{y {:} D}. (\mathbf{Sat}(a \mbox{\aap ,} t, \alpha[x := y]) \\
&  &
\end{array}%
\end{equation*}

%-------------------------------------%
%           function Par
%-------------------------------------%

\begin{equation*}
\begin{array}{lll}
\mathbf{Par}_{X,l}(c) & =_{def} & [] \\
\mathbf{Par}_{X,l}(\lnot \varphi ) & =_{def} & \mathbf{Par}_{X,l}(\varphi )
\\
\mathbf{Par}_{X,l}(\varphi \wedge \psi ) & =_{def} & \mathbf{Par}%
_{X,l}(\varphi )++\mathbf{Par}_{X,l}(\psi ) \\
\mathbf{Par}_{X,l}(\varphi \vee \psi ) & =_{def} & \mathbf{Par}%
_{X,l}(\varphi )++\mathbf{Par}_{X,l}(\psi ) \\
\mathbf{Par}_{X,l}(\varphi \Rightarrow \psi ) & =_{def} & \mathbf{Par}%
_{X,l}(\varphi )++\mathbf{Par}_{X,l}(\psi ) \\
\mathbf{Par}_{X,l}([\alpha ]\varphi ) & =_{def} & \mathbf{Par}_{X,l}(\varphi
) \\
\mathbf{Par}_{X,l}(\langle \alpha \rangle \varphi ) & =_{def} & \mathbf{Par}%
_{X,l}(\varphi ) \\
\mathbf{Par}_{X,l}(\forall {x{:}D}.\varphi ) & =_{def} & \mathbf{Par}%
_{X,l++[x{:}D]}(\varphi ) \\
\mathbf{Par}_{X,l}(\exists {x{:}D}.\varphi ) & =_{def} & \mathbf{Par}%
_{X,l++[x{:}D]}(\varphi ) \\
\mathbf{Par}_{X,l}(Y(d_{f})) & =_{def} & [] \\
\mathbf{Par}_{X,l}(\sigma Y(x_{f}{:}D_{f}:=d).\varphi ) & =_{def} & \left\{
\begin{array}{cc}
l & \mathsf{if\ }Y=X \\
\mathbf{Par}_{X,l++[x_{f}{:}D_{f}]}(\varphi ) & \mathsf{if\ }Y\neq X%
\end{array}%
\right. \\
\mathbf{Par}_{X,l}(\nabla (t)) & =_{def} & [] \\
\mathbf{Par}_{X,l}(\Delta (t)) & =_{def} & [] \\
&  &
\end{array}%
\end{equation*}

\pagebreak

%-------------------------------------%
%           function RHS
%-------------------------------------%
\begin{equation*}
\begin{array}{lll}
{\mathbf{RHS}}(c) & =_{def} & c \\
{\mathbf{RHS}}(\varphi \wedge \psi ) & =_{def} & {\mathbf{RHS}}(\varphi
)\wedge {\mathbf{RHS}}(\psi ) \\
{\mathbf{RHS}}(\varphi \vee \psi ) & =_{def} & {\mathbf{RHS}}(\varphi )\vee {%
\mathbf{RHS}}(\psi ) \\
{\mathbf{RHS}}(\forall {x{:}D}.\varphi ) & =_{def} & \forall {x{:}D}.{%
\mathbf{RHS}}(\varphi ) \\
{\mathbf{RHS}}(\exists {x{:}D}.\varphi ) & =_{def} & \exists {x{:}D}.{%
\mathbf{RHS}}(\varphi ) \\
{\mathbf{RHS}}([\alpha ]\varphi ) & =_{def} & \bigwedge_{i{\in }I}\forall _{y%
{:}E_{i}}((\mathbf{Sat}(a_{i}(f_{i}(x,y))\mbox{\aap ,}t_{i}(x,y),\alpha )\
\wedge \\
&  & \phantom{\bigwedge_{i {\in} I} \forall_{y {:} E_i}(}c_{i}(x,y)\wedge
t_{i}(x,y)>T\ )\Rightarrow \\
&  & \phantom{\bigwedge_{i {\in} I} \forall_{y {:} E_i}(} {\mathbf{RHS}}%
(\varphi )[T,x:=t_{i}(x,y),g_{i}(x,y)]) \\
{\mathbf{RHS}}(\langle \alpha \rangle \varphi ) & =_{def} & \bigvee_{i{\in }%
I}\exists _{y{:}E_{i}}(\mathbf{Sat}(a_{i}(f_{i}(x,y))\mbox{\aap
,}t_{i}(x,y),\alpha )\ \wedge \\
&  & \phantom{\bigvee_{i {\in} I} \exists_{y {:} E_i}(}c_{i}(x,y)\wedge
t_{i}(x,y)>T\ \wedge \\
&  & \phantom{\bigvee_{i {\in} I} \exists_{y {:} E_i}(} {\mathbf{RHS}}%
(\varphi )[T,x:=t_{i}(x,y),g_{i}(x,y)]) \\
{\mathbf{RHS}}(X(e)) & =_{def} & X(T,e,x,\mathbf{Par}_{X,[]}(\varphi _{0}))
\\
{\mathbf{RHS}}(\sigma X(x_{f}{:}D_{f}:=e).~\varphi ) & =_{def}~~~ & X(T,e,x,%
\mathbf{Par}_{X,[]}(\varphi _{0})) \\
{\mathbf{RHS}}(\nabla (t)) & =_{def} & \left( \bigwedge_{i{\in }I\cup
J}\forall _{y{:}E_{i}}((\lnot c_{i}(x,y)\vee t>t_{i}(x,y))\right) \wedge t>T
\\
{\mathbf{RHS}}(\Delta (t)) & =_{def} & \left( \bigvee_{i{\in }I\cup
J}\exists _{y{:}E_{i}}((c_{i}(x,y)\wedge t\leq t_{i}(x,y))\right) \vee t\leq
T%
\end{array}%
\end{equation*}

%-------------------------------------%
%           function E
%-------------------------------------%
\begin{equation*}
\begin{array}{lll}
{\mathbf{E}}(c) & =_{def} & \epsilon \\
{\mathbf{E}}(\varphi \wedge \psi ) & =_{def} & {\mathbf{E}}(\varphi ){%
\mathbf{E}}(\psi ) \\
{\mathbf{E}}(\varphi \vee \psi ) & =_{def} & {\mathbf{E}}(\varphi ){\mathbf{E%
}}(\psi ) \\
{\mathbf{E}}(\forall {x{:}D}.\varphi ) & =_{def} & {\mathbf{E}}(\varphi ) \\
{\mathbf{E}}(\exists {x{:}D}.\varphi ) & =_{def} & {\mathbf{E}}(\varphi ) \\
{\mathbf{E}}([\alpha ]\varphi ) & =_{def} & {\mathbf{E}}(\varphi ) \\
{\mathbf{E}}(\langle \alpha \rangle \varphi ) & =_{def} & {\mathbf{E}}%
(\varphi ) \\
{\mathbf{E}}(\nabla ) & =_{def} & \epsilon \\
{\mathbf{E}}(\nabla (t)) & =_{def} & \epsilon \\
{\mathbf{E}}(\Delta ) & =_{def} & \epsilon \\
{\mathbf{E}}(\Delta (t)) & =_{def} & \epsilon \\
{\mathbf{E}}(X(e)) & =_{def} & \epsilon \\
{\mathbf{E}}(\sigma X(x_{f}{:}D_{f}:=e).~\varphi )~~~ & =_{def}~~~ & (%
\sigma X(T:\mathbb{R},x_{f}{:}D_{f},x{:}D_{p},\mathbf{Par}%
_{X,[]}(\varphi _{0}))={\mathbf{RHS}}(\varphi )~)~{\mathbf{E}}(\varphi )%
\end{array}%
\end{equation*}%

\subsection{Counter example generation}

There is a modified translation that adds information to the PBES from which
a counter example can be generated. N.B. The counter example generation is
only available for the untimed case. The function RHS is adapted from%
\begin{equation*}
\begin{array}{lll}
{\mathbf{RHS}}([\alpha ]\varphi ) & =_{def} & \bigwedge_{i{\in }I}\forall _{y%
{:}E_{i}}\left( (\mathbf{Sat}(a_{i}(f_{i}(x,y)),\alpha )\ \wedge
c_{i}(x,y)\right) \Rightarrow {\mathbf{RHS}}(\varphi )[x:=g_{i}(x,y)]) \\
{\mathbf{RHS}}(\langle \alpha \rangle \varphi ) & =_{def} & \bigvee_{i{\in }%
I}\exists _{y{:}E_{i}}\left( (\mathbf{Sat}(a_{i}(f_{i}(x,y)),\alpha )\
\wedge c_{i}(x,y)\right) \ \wedge {\mathbf{RHS}}(\varphi )[x:=g_{i}(x,y)])%
\end{array}%
\end{equation*}%
into%
\begin{equation*}
\begin{array}{lll}
{\mathbf{RHS}}([\alpha ]\varphi ) & =_{def} & \bigwedge_{i{\in }I}\forall _{y%
{:}E_{i}}\left( \mathbf{Sat}(a_{i}(f_{i}(x,y)),\alpha )\ \wedge
c_{i}(x,y)\right) \Rightarrow \\
&  & \phantom{\bigwedge_{i {\in} I} \forall_{y {:} E_i}(}\left( \left( {%
\mathbf{RHS}}(\varphi )[x:=g_{i}(x,y)]\wedge
Z_{a_{i}}^{+}(x,f_{i}(x,y),g_{i}(x,y))\right) \vee
Z_{a_{i}}^{-}(x,f_{i}(x,y),g_{i}(x,y))\right) \\
{\mathbf{RHS}}(\langle \alpha \rangle \varphi ) & =_{def} & \bigvee_{i{\in }%
I}\exists _{y{:}E_{i}}\left( \mathbf{Sat}(a_{i}(f_{i}(x,y)),\alpha )\ \wedge
c_{i}(x,y)\right) \wedge \\
&  & \phantom{\bigwedge_{i {\in} I} \forall_{y {:} E_i}(}\left( \left( {%
\mathbf{RHS}}(\varphi )[x:=g_{i}(x,y)]\vee
Z_{a_{i}}^{-}(x,f_{i}(x,y),g_{i}(x,y))\right) \wedge
Z_{a_{i}}^{+}(x,f_{i}(x,y),g_{i}(x,y))\right) ,%
\end{array}%
\end{equation*}%
where $\nu Z_{a_{i}}^{+}(x,f_{i}(x,y),d^{\prime })=true$ and $\nu
Z_{a_{i}}^{-}(x,f_{i}(x,y),d^{\prime })=false$ are additional equations for
every $a_{i}$ that appears in the LPS.

\newpage

\section{Transforming an LTS and a property to a PBES}

In this section we define the algorithm \textsc{lts2pbes} that generates a PBES from a
modal mu calculus formula $\varphi$ and an LTS $\langle {S,Act,\rightarrow ,s}_{0}\rangle$ :
\begin{equation*}
\text{\textsc{lts2pbes}}(\sigma X(d:D:=e).~\varphi ,\langle {%
S,Act,\rightarrow ,s}_{0}\rangle )=\left\langle \mathbf{E}_{\sigma
X(d:D:=e).~\varphi }(\varphi ),X_{s_{0}}(e)\right\rangle
\end{equation*}%
where the function $\mathbf{E}$ is inductively defined using the tables
below. The function $\varphi $ has to be in positive normal form, i.e. it
may not contain any $\lnot $ or $\Rightarrow $ symbols. A formula $\psi $
not of the form $\sigma X(d:D:=e).~\varphi $ is translated into $\nu
X().~\psi $. We denote the formula $\varphi$ that is passed to the algorithm \textsc{lts2pbes} as $\varphi_0$. It is used as a global variable in the translation.

N.B. The functions $\mathbf{Sat}$ and $\mathbf{Par}$ are defined in the
section about \textsc{lps2pbes}.

$\bigskip$

$%
\begin{array}{lll}
{\mathbf{E}}(c) & =_{def} & \epsilon \\
{\mathbf{E}}(\varphi \wedge \psi ) & =_{def} & {\mathbf{E}}%
(\varphi ){\mathbf{E}}(\psi ) \\
{\mathbf{E}}(\varphi \vee \psi ) & =_{def} & {\mathbf{E}}%
(\varphi ){\mathbf{E}}(\psi ) \\
{\mathbf{E}}(\forall {x{:}D}.\varphi ) & =_{def} & {\mathbf{E}%
}(\varphi ) \\
{\mathbf{E}}(\exists {x{:}D}.\varphi ) & =_{def} & {\mathbf{E}%
}(\varphi ) \\
{\mathbf{E}}([\alpha ]\varphi ) & =_{def} & {\mathbf{E}}%
(\varphi ) \\
{\mathbf{E}}(\langle \alpha \rangle \varphi ) & =_{def} & {%
\mathbf{E}}(\varphi ) \\
{\mathbf{E}}(X(d)) & =_{def} & \epsilon \\
{\mathbf{E}}(\sigma X(d{:}D:=e).~\varphi )~~~ & =_{def}~~~ &
(\sigma \{X_{s}(d:D,\mathbf{Par}_{X,[]}(\varphi _{0}))={\mathbf{RHS}}%
_{\varphi }(\varphi ,s)\ |\ s\in S\})~{\mathbf{E}}(\varphi )%
\end{array}%
$

$\bigskip $

$%
\begin{array}{lll}
{\mathbf{RHS}}(c,s) & =_{def} & c \\
{\mathbf{RHS}}(\varphi \wedge \psi ,s) & =_{def} & {\mathbf{%
RHS}}(\varphi ,s)\wedge {\mathbf{RHS}}(\psi ,s)
\\
{\mathbf{RHS}}(\varphi \vee \psi ,s) & =_{def} & {\mathbf{RHS}%
}(\varphi ,s)\vee {\mathbf{RHS}}(\psi ,s) \\
{\mathbf{RHS}}(\forall d{{:}D}.\varphi ,s) & =_{def} &
\forall d{{:}D}.{\mathbf{RHS}}(\varphi ,s) \\
{\mathbf{RHS}}(\exists d{{:}D}.\varphi ,s) & =_{def} &
\exists d{{:}D}.{\mathbf{RHS}}(\varphi ,s) \\
{\mathbf{RHS}}([\alpha ]\varphi ,s) & =_{def} & \bigwedge
\left\{ \mathbf{Sat}(a(x),\alpha )\Rightarrow {\mathbf{RHS}}_{\varphi
_{0}}(\varphi ,t)\ |\ s\overset{a(x)}{\rightarrow }t\right\}  \\
{\mathbf{RHS}}(\langle \alpha \rangle \varphi ,s) & =_{def} &
\bigvee \left\{ \mathbf{Sat}(a(x),\alpha )\wedge {\mathbf{RHS}}_{\varphi
_{0}}(\varphi ,t)\ |\ s\overset{a(x)}{\rightarrow }t\right\}  \\
{\mathbf{RHS}}(X(e),s) & =_{def} & X_{s}(e,\mathbf{Par}%
_{X,[]}(\varphi _{0})) \\
{\mathbf{RHS}}(\sigma X(d{:}D:=e).~\varphi ,s) & =_{def}~~~ &
X_{s}(e,\mathbf{Par}_{X,[]}(\varphi _{0}))%
\end{array}%
$\pagebreak

\subsection{Counter example generation}

There is a modified translation that adds information to the PBES from which
a counter example can be generated. The function RHS is adapted from%
\begin{equation*}
\begin{array}{lll}
{\mathbf{RHS}}([\alpha ]\varphi ,s) & =_{def} & \bigwedge
\left\{ \mathbf{Sat}(a(x),\alpha )\Rightarrow {\mathbf{RHS}}_{\varphi
_{0}}(\varphi ,t)\ |\ s\overset{a(x)}{\rightarrow }t\right\}  \\
{\mathbf{RHS}}(\langle \alpha \rangle \varphi ,s) & =_{def} &
\bigvee \left\{ \mathbf{Sat}(a(x),\alpha )\wedge {\mathbf{RHS}}_{\varphi
_{0}}(\varphi ,t)\ |\ s\overset{a(x)}{\rightarrow }t\right\}
\end{array}%
\end{equation*}%
into%
\begin{equation*}
\begin{array}{lll}
{\mathbf{RHS}}([\alpha ]\varphi ,s) & =_{def} & \bigwedge
\left\{ \mathbf{Sat}(a(x),\alpha )\Rightarrow \left( \left( {\mathbf{RHS}}%
(\varphi ,t)\wedge Z_{a}^{+}(s,x,t)\right) \vee
Z_{a}^{-}(s,x,t)\right) \ |\ s\overset{a(x)}{\rightarrow }t\right\}  \\
{\mathbf{RHS}}(\langle \alpha \rangle \varphi ,s) & =_{def} &
\bigvee \left\{ \mathbf{Sat}(a(x),\alpha )\wedge \left( \left( {\mathbf{RHS}}%
(\varphi ,t)\vee Z_{a}^{-}(s,x,t)\right) \wedge
Z_{a}^{+}(s,x,t)\right) \ |\ s\overset{a(x)}{\rightarrow }t\right\}
\end{array}%
\end{equation*}%
where $\nu Z_{a_{i}}^{+}(s,d_{x},t)=true$ and $\nu
Z_{a_{i}}^{-}(s,d_{x},t)=false$ are additional equations for every $a(x)$
that appears in the LTS.

\newpage
\section{Bisimulation}

Let%
\begin{eqnarray*}
M(d) &=&\sum\limits_{i\in I_{M}}\sum_{e:E_{i}}c_{i}(d,e)\rightarrow
a_{i}(d,e)\cdot M(g_{i}(d,e)) \\
S(d) &=&\sum\limits_{i\in I_{S}}\sum_{e:E_{i}}c_{i}(d,e)\rightarrow
a_{i}(d,e)\cdot M(g_{i}(d,e))
\end{eqnarray*}%
be two linear processes, such that $I_{M}\cap I_{S}=\emptyset $. $M$ is
called the model and $S$ the specification. The expression $a_{i}(d,e)$ can
be a multi-action, or have the special value $\tau $. We assume that there
are no $\delta $ summands. We define four pbes equation systems that express
some kind of bisimulation equivalence between $M$ and $S$.

\paragraph{Branching Bisimulation}

\emph{brbsim}$(M,S)=\nu E_{2}\mu E_{1}$, where%
\begin{equation*}
\begin{array}{ccl}
E_{2} & := & \{X^{M,S}(d,d^{\prime })=match^{M,S}(d,d^{\prime })\wedge
match^{S,M}(d^{\prime },d), \\
&  & X^{S,M}(d^{\prime },d)=X^{M,S}(d,d^{\prime })\} \\
E_{1} & := & \{Y_{i}^{M,S}(d,d^{\prime },e)=close_{i}^{M,S}(d,d^{\prime
},e)|i\in I_{M}, \\
&  & Y_{i}^{S,M}(d^{\prime },d,e)=close_{i}^{S,M}(d^{\prime },d,e)|i\in
I_{S}\}%
\end{array}%
\end{equation*}%
with for all $i\in I_{p}$ and $(p,q)\in \{(M,S),(S,M)\}$:%
\begin{eqnarray*}
match^{p,q}(d,d^{\prime }) &=&\bigwedge\limits_{i\in I_{p}}\forall
_{e:E_{i}}.(c_{i}(d,e)\Rightarrow Y_{i}^{p,q}(d,d^{\prime },e)) \\
close_{i}^{p,q}(d,d^{\prime },e) &=&\bigvee\limits_{\{j\in I_{q}|a_{j}=\tau
\}}\exists _{e^{\prime }:E_{j}}.(c_{j}(d^{\prime },e^{\prime })\wedge
Y_{i}^{p,q}(d,g_{j}(d^{\prime },e^{\prime }),e)) \\
&&\vee (X^{p,q}(d,d^{\prime })\wedge step_{i}^{p,q}(d,d^{\prime },e)) \\
step_{i}^{p,q}(d,d^{\prime },e) &=&\left\{
\begin{array}{cl}
a_{i}=\tau : & X^{p,q}(g_{i}(d,e),d^{\prime })\vee \bigvee\limits_{\{j\in
I_{q}|a_{j}=\tau \}}\exists _{e^{\prime }:E_{j}}.(c_{j}(d^{\prime
},e^{\prime })\wedge X^{p,q}(g_{i}(d,e),g_{j}(d^{\prime },e^{\prime })) \\
a_{i}\neq \tau : & \bigvee\limits_{\{j\in I_{q}|a_{j}=a_{i}\}}\exists
_{e^{\prime }:E_{j}}.(c_{j}(d^{\prime },e^{\prime })\wedge
(a_{i}(d,e)=a_{j}(d^{\prime },e^{\prime }))\wedge
X^{p,q}(g_{i}(d,e),g_{j}(d^{\prime },e^{\prime }))%
\end{array}%
\right.
\end{eqnarray*}

\paragraph{Strong Bisimulation}

\emph{sbisim}$(M,S)=\nu E$, where%
\begin{equation*}
\begin{array}{ccl}
E & := & \{X^{M,S}(d,d^{\prime })=match^{M,S}(d,d^{\prime })\wedge
match^{S,M}(d^{\prime },d), \\
&  & X^{S,M}(d^{\prime },d)=X^{M,S}(d,d^{\prime })\}%
\end{array}%
\end{equation*}%
with for all $i\in I_{p}$ and $(p,q)\in \{(M,S),(S,M)\}$:%
\begin{eqnarray*}
match^{p,q}(d,d^{\prime }) &=&\bigwedge\limits_{i\in I_{p}}\forall
_{e:E_{i}}.(c_{i}(d,e)\Rightarrow step_{i}^{p,q}(d,d^{\prime },e)) \\
step_{i}^{p,q}(d,d^{\prime },e) &=&\bigvee\limits_{j\in I_{q}}\exists
_{e^{\prime }:E_{j}}.(c_{j}(d^{\prime },e^{\prime })\wedge
(a_{i}(d,e)=a_{j}(d^{\prime },e^{\prime }))\wedge
X^{p,q}(g_{i}(d,e),g_{j}(d^{\prime },e^{\prime }))
\end{eqnarray*}

\paragraph{Weak Bisimulation}

\emph{wbisim}$(M,S)=\nu E_{2}\mu E_{1}$, where%
\begin{equation*}
\begin{array}{ccl}
E_{3} & := & \{X^{M,S}(d,d^{\prime })=match^{M,S}(d,d^{\prime })\wedge
match^{S,M}(d^{\prime },d), \\
&  & X^{S,M}(d^{\prime },d)=X^{M,S}(d,d^{\prime })\} \\
E_{2} & := & \{Y_{1,i}^{M,S}(d,d^{\prime },e)=close_{1,i}^{M,S}(d,d^{\prime
},e)|i\in I_{M}, \\
&  & Y_{2,i}^{M,S}(d,d^{\prime })=close_{2,i}^{M,S}(d,d^{\prime })|i\in
I_{M}, \\
&  & Y_{1,i}^{S,M}(d^{\prime },d,e)=close_{1,i}^{S,M}(d^{\prime },d,e)|i\in
I_{S}, \\
&  & Y_{2,i}^{S,M}(d^{\prime },d)=close_{2,i}^{S,M}(d^{\prime },d)|i\in
I_{S}\}%
\end{array}%
\end{equation*}%
with for all $i\in I_{p}$ and $(p,q)\in \{(M,S),(S,M)\}$:%
\begin{eqnarray*}
match^{p,q}(d,d^{\prime }) &=&\bigwedge\limits_{i\in I_{p}}\forall
_{e:E_{i}}.(c_{i}(d,e)\Rightarrow Y_{1,i}^{p,q}(d,d^{\prime },e)) \\
close_{1,i}^{p,q}(d,d^{\prime },e) &=&\left( \bigvee\limits_{\{j\in
I_{q}|a_{j}=\tau \}}\exists _{e^{\prime }:E_{j}}.(c_{j}(d^{\prime
},e^{\prime })\wedge Y_{1,i}^{p,q}(d,g_{j}(d^{\prime },e^{\prime
}),e))\right) \vee step_{i}^{p,q}(d,d^{\prime },e) \\
step_{i}^{p,q}(d,d^{\prime },e) &=&\left\{
\begin{array}{cl}
a_{i}=\tau : & close_{2,i}^{p,q}(g_{i}(d,e),d^{\prime }) \\
a_{i}\neq \tau : & \bigvee\limits_{j\in I_{q}}\exists _{e^{\prime
}:E_{j}}.\left( c_{j}(d^{\prime },e^{\prime })\wedge
a_{i}(d,e)=a_{j}(d^{\prime },e^{\prime })\wedge
close_{2,i}^{p,q}(g_{i}(d,e),g_{j}(d^{\prime },e^{\prime }))\right)%
\end{array}%
\right. \\
close_{2,i}^{p,q}(d,d^{\prime }) &=&X^{p,q}(d,d^{\prime })\vee
\bigvee\limits_{\{j\in I_{q}|a_{j}=\tau \}}\left( \exists _{e^{\prime
}:E_{j}}c_{j}(d^{\prime },e^{\prime })\wedge Y_{2,i}^{p,q}(d,g_{j}(d^{\prime
},e^{\prime }))\right)
\end{eqnarray*}

\paragraph{Branching Simulation Equivalence}

\emph{brbsim}$(M,S)=\nu E_{2}\mu E_{1}$, where%
\begin{equation*}
\begin{array}{ccl}
E_{2} & := & \{X^{M,S}(d,d^{\prime })=match^{M,S}(d,d^{\prime })\wedge
match^{S,M}(d^{\prime },d), \\
&  & X^{M,S}(d,d^{\prime })=X^{S,M}(d^{\prime },d), \\
&  & X^{S,M}(d^{\prime },d)=X^{M,S}(d,d^{\prime })\} \\
E_{1} & := & \{Y_{i}^{M,S}(d,d^{\prime },e)=close_{i}^{M,S}(d,d^{\prime
},e)|i\in I_{M}, \\
&  & Y_{i}^{S,M}(d^{\prime },d,e)=close_{i}^{S,M}(d^{\prime },d,e)|i\in
I_{S}\}%
\end{array}%
\end{equation*}%
with $match$, $close$, and $step$ defined exactly the same as in branching
bisimulation.

\end{document}
