\index{}\documentclass[a4paper,10pt]{article}
\usepackage{textcomp,amsmath,amssymb,amsthm,stmaryrd}
\usepackage{geometry}
\usepackage{mymath,mythm}
\usepackage{algorithm,algorithmic}

\theoremstyle{plain}
\newtheorem{thmfs}{Theorem}[section]
\theoremstyle{definition}
\newtheorem{tcase}[thmfs]{Test case}

\newcommand{\lps}{linear process specification}
\newcommand{\tool}{\textit{lpsconstelm}}
\newcommand{\ovr}{\overrightarrow}
\newcommand{\mcrl}{mCRL2}
\newcommand{\framework}{\textit{LPS framework} \cite{LPSframework}}
\newcommand{\pp}{process parameter}
\newcommand{\pps}{process parameters}
\newcommand{\ti}{\textit}
\newcommand{\tb}{\textbf}
\newcommand{\sv}{\textit{state vector}}
\newcommand{\fv}{\textit{flag vector}}
\newcommand{\svs}{\textit{new state vector set}}
\newcommand{\nfv}{\textit{new flag vector}}
\newcommand{\la}{$\leftarrow$}
\newcommand{\ra}{$\rightarrow$}
\newcommand{\sq}{$\square$}
\newcommand{\ifs}{\ti{influence set}}

\newcommand{\Sig}{\nm{Sig}}
\newcommand{\Sort}{\nm{Sort}}
\newcommand{\Fun}{\nm{Fun}}
\newcommand{\ap}{{:}}

\newcommand{\tabw}{\hspace*{15.mm} \= \hspace*{20.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm}  \= \hspace*{5.mm}  \= \hspace*{5.mm}  \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm}  \= \hspace*{5.mm}  \= \hspace*{5.mm}\kill}

\newcommand{\tab}{\hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm}  \= \hspace*{5.mm}  \= \hspace*{5.mm}  \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm}  \= \hspace*{5.mm}  \= \hspace*{5.mm}\kill}

\font \aap cmmi10
\newcommand{\at}[1]{\mbox{\aap ,} #1}

\newcommand{\csvs}{new\_state\_vector\_set}
\newcommand{\cfvs}{new\_flag\_vector\_set}


%opening
\title{lpsconstelm}
\author{F.P.M. Stappers}

\begin{document}

\maketitle

\begin{abstract}
This documentation describes the implementation and test cases of the tool \tool\ in  the \mcrl\ toolset.
Basically, \tool\ is a tool which eliminates constant parameters in a \lps\ (LPS).
\end{abstract}

\tableofcontents

\section{Introduction}
The \tool\ tool is a tool for \mcrl\ studio. The tool is a
filter which reads from file \ti{input.lps}, which is
a file in \ti{.lps} format \cite{LPSformat}. We make use of the
\framework\ to read \ti{input.lps}. For
each detected constant \pp\ the filter substitutes its constant value and removes the \pp\ from the
\lps . After the algorithm (Section \ref{sec:alg}) terminates, \tool\
will write the output to an output file \ti{output.lps} (in the \ti{.lps} format.)

\section{Definitions} \label{sec:def}

The equation below is a \lps\ in \mcrl :
\begin{defn}\lps\ (LPS) \newline
%\at werkt niet
\begin{tabbing}
\tab
$X (\ovr{d: D}) = $ \> \> \> $ \sum_{i \in I} \sum_{\ovr{e_i: E_i}} c_i ( \ovr{d, e_i }) \rightarrow
(a_i^1 (\ovr{f_{i,1}}(\ovr{d,e_i})) \vert \ldots \vert a_i^{n(i)}(\ovr{f_{i,n(i)}}(\ovr{d,e_i}))) \at \text{ } t_i(\ovr{d,e_i})  \cdot X(\ovr{g_i}(\ovr{d,e_i})) +$ \\ \\
\> \> \> $ \sum_{j \in J} \sum_{\ovr{e_j: E_j}} c_j ( \ovr{d, e_j} ) \rightarrow
(a_j^1 (\ovr{f_{j,1}}(\ovr{d,e_j})) \vert \ldots \vert a_j^{n(j)}(\ovr{f_{j,n(j)}}(\ovr{d,e_j}))) \at \text{ } t_j(\ovr{d,e_j}) + $ \\ \\
\> \> \> $\sum_{\ovr{e_\delta:E_\delta}} \ovr{c_\delta} ( \ovr{d, e_\delta}) \rightarrow
\delta \at \text{ } t_\delta(\ovr{d,e_\delta})$
\end{tabbing}

Where $I$ and $J$ are disjoint.\\
\end{defn}

\noindent For the description of the \tool\ tool we only use those elements of an LPS which are relevant. So we use a simplified\footnote{Multiactions, time, deadlock and termination are not taken into account} representation of an LPS .
\begin{defn}[Simplified LPS]\label{def:LPS}
\begin{displaymath}
X (\ovr{d:D}) = \sum_{i \in I} \sum_{\ovr{e_i:E_i}} c_i ( \ovr{d, e_i}) \rightarrow X(\ovr{g_i}(\ovr{d,e_i}))
\end{displaymath}\\
If we talk about an LPS in this article we refer to Definition \ref{def:LPS}.  The different states
%are $\ovr{d}$
of a process are represented by the data vector parameter $\ovr{d: D}$. Type $\ovr{D}$ may be a Cartesian product of $n$ data types, meaning that $\ovr{d}$ is of a tuple $(d_1, \ldots, d_n)$.
Let $x \in \lbrace 1, \ldots , \vert \ovr{d} \vert \rbrace$. The $x^{th}$ element in the tuple is notated: $\ovr{d}._x$.
The LPS expresses that in state $\ovr{d}$ %it preforms action $a$, carrying data parameter $\ovr{f_i}(\ovr{d},e_i)$ and
it can reach the new state $\ovr{g_i}(\ovr{d,e_i})$ under the condition that $c_i(\ovr{d,e_i})$ is \ti{true}. So, for each summand $i$ from $I$ we have a function $\ovr{g_i}: \ovr{D} \times \ovr{E_i} \rightarrow \ovr{D}$ and a function $c_i: \ovr{D} \times \ovr{E_i} \rightarrow \mathbb{B}$.
% Data parameters $\ovr{e_i : E_i}$ are sum variables. These variables are used to let a action range over a data domain.
If we want to speak about a specific statespace, which is generated from an LPS, we can instantiate this state space with the initial state $X(\ovr{v_0})$.

\noindent For an more detailed explanation of \lps s  we refer to \cite{LPS_info}.
\end{defn}

\section{Free Variables}
\subsection{Explanation}

If a parameter at a certain state does not influence the behavior of an LPS at that specific state, we can assign to this \pp\ a \ti{free variable}. With these \ti{free variables} we are able to model that \pp\ can have values, which will not influence the behavior of an LPS.

\subsection{Assumptions}
We make certain assumptions about \ti{free variables} which occur in an LPS, otherwise reasoning about LPS's would be to complicated. The first assumption is that the value of these variables will not influence the behavior of the LPS. Another assumption is that \ti{free variables} only occur once in an LPS. Therefore each \ti{free variable} is unique.
Also we assume that each value of a state is either a closed term or a free variable.

For further reading about \lps\ and free variables please refer to \cite{LPSfreevar}

\section{lpsconstelm definition}\label{subsec:lpsdef}
\subsection{lpsconstelm definition - without free variables}

In this definition we do not consider free variables.
A parameter of an LPS can be replaced by its initial value if it can be determined that this parameter remains constant throughout the run of any trace, starting at the initial state. The elimination of constant parameters does not reduce the resulting state space, however it may reduce the time and space needed to for example generate a state space from an LPS. \\
If we have infinite time and space we can inspect each state and check whether a \pp\ changes throughout the execution of the process. For this we define the reachable state set $R$ for each state ($\ovr{v_0}$).

\begin{defn} Let $L$ be an LPS, where: \\
\begin{itemize}
\item $I$ is the set of summand indices, \\ $\ovr{E_i}$ is the set of sum variables of summand $i$, \\ $c_i$ is the condition function of summand $i$ and \\ $\ovr{g_i}$ is the next state function of summand $i$.
\end{itemize}

$R_L(\ovr{v_0})$ is the smallest set for which the following holds:
  \begin{itemize}
    \item[-] $\ovr{v_0} \in R_L(\ovr{v_0})$
    \item[-] For all $i \in I$ and $\ovr{e_i} \in \ovr{E_i}$, if $\ovr{v} \in R_L(\ovr{v_0})$ and $c_i(\ovr{v, e_i})$ holds, \\ then $\ovr{g_i}(\ovr{v, e_i}) \in R_L(\ovr{v_0})$ \\
   \end{itemize}
\end{defn}

\begin{defn}\label{def:lps_comp} We define $S_L(\ovr{v_0})$ to be the set of indices of \pps\ for LPS $L$ which are constant. That is:\\

$S_L(\ovr{v_0}) = \lbrace j \in  \lbrace 1, \ldots, \vert \ovr{v_0}\vert  \rbrace \vert (\forall_{\ovr{v} \in R_L(\ovr{v_0})}( \ovr{v}._j = \ovr{v_{0}}._j)) \rbrace $
\end{defn}

To get $S_L(\ovr{v_0})$ we have to compute $R_L(\ovr{v_0})$. This means we have to generate the entire state space starting at state $\ovr{v_0}$. Generating the entire state space can take a lot of time and space; it might take infinite time and/or space. However if we can make an approximation of Definition \ref{def:lps_comp} we do not necessarily have to inspect all states. Note that if we use an approximation there are cases in which not all constant parameters can be found. In practice we do not mind, because these are hard to find and the cost/benefit is to small.

\subsection{lpsconstelm definition - with free variables}

A \pp\ of an LPS can be replaced by its constant value if it can be determined that this parameter remains constant throughout any run of the process, starting at the initial state. However if a \pp\ is initially a free variable and the \pp\ remains constant, the specific assigned value or the initial \ti{free variable} value is used.\\

We define the reachable state set $R^{FV}$ for each state ($\ovr{v_0}$).
\begin{defn} Let $L$ be an LPS, where\begin{itemize}
\item $I$ is the set of summand indices, \\ $\ovr{E_i}$ is the set of sum variables of summand $i$, \\ $c_i$ is the condition function of summand $i$ and \\ $\ovr{g_i}$ is the next state function of summand $i$. \\
$FV$ is the set of \ti{free variables} occurring in $L$.\\
\end{itemize}

$R_L^{FV}(\ovr{v_0})$ is the smallest set for which the following holds:
  \begin{itemize}
    \item[-] $\ovr{v_0} \in R_L^{FV}(\ovr{v_0})$
    \item[-] For all $i \in I$ and $\ovr{e_i} \in \ovr{E_i}$, if $\ovr{v} \in R_L^{FV}(\ovr{v_0})$ and $c_i(\ovr{v, e_i})$ holds, \\ then $\ovr{g_i}(\ovr{v, e_i}) \in R_L^{FV}(\ovr{v_0})$ \\
   \end{itemize}
\end{defn}

\begin{defn}\label{def:lps_comp_fv} We define $S_L^{FV}(\ovr{v_0})$ to be the set of indices of \pps\ which are constant. That is:\\

$S_L^{FV}(\ovr{v_0}) = \lbrace j \in  \lbrace 1, \ldots, n \rbrace \vert \forall_{\ovr{v}, \ovr{w} \in R_L^{FV}(\ovr{v_0})}( \ovr{v}._j \not\in FV \wedge \ovr{w}._j \not\in FV \rightarrow ( \ovr{v}._j = \ovr{w}._j)))
\rbrace $
\end{defn}

To get $S_L^{FV} (\ovr{v_0})$ we have to compute $R_L^{FV}(\ovr{v_0})$, and this means we have to generate the entire state space starting from state $\ovr{v_0}$. However we interested in an approximation. We take proposal 3 (Section \ref{def:sug3}) as a starting point for constructing Proposal 4 (Section \ref{def:sug4}).

\section{Proposals}
In this section we speak about different techniques to find an algorithm that find as many constant \pps\ in polynomial time. These proposals are all estimations, so we can reduce complexity of the given definitions in Section \ref{subsec:lpsdef}. Each proposal contains a small description, which describes how a certain proposal was born.

\subsection{Proposal 1 - without free variables} \label{sec:prop1}
Because variables can occur in non-normal forms we introduce a form function which allows us to take the normal form of such a data term.
We write $NF(t)$ for the normal form of data term $t$.
Let $j \in \lbrace 1, \ldots,  n \rbrace $ and let $\ovr{d}$ be state vector. We assume $\ovr{d}._j$ is a normal form. If $\ovr{d}._j$ is equal to $NF(\ovr{g_i}(\ovr{d,e_i})._j)$ for all $i \in I$ we know argument at position $j$ is constant. Each summand has a condition $c_i$. If a condition $c_i(\ovr{d, e_i})$ does not hold, the next state $X(\ovr{g_i}(\ovr{d, e_i}))$ can not be reached. This is why we omit comparing each \pp\ in $\ovr{d} $ with such a $X(\ovr{g_i}(\ovr{d, e_i}))$.

 However some conditions $NF(c_i(\ovr{d,e_i}))$ might never be \ti{true}, so it useless to compare $NF(\ovr{d}._j)$ with $NF(\ovr{g_i}(\ovr{d,e_i})._j)$  if $NF(c_i(\ovr{d,e_i}))$ is not  $"true"$. \\

\begin{defn} \label{def:sug1} Let $L$ be an LPS and we define $S_L^1$:
\begin{displaymath}
S_L^1 =
\lbrace
j \in \lbrace 1, \ldots , n \rbrace \vert \forall_{i\in I} (\forall_{\ovr{d}: \ovr{D}}((NF(c_i(\ovr{d,e_i})) = "true")  \Rightarrow (NF(\ovr{d}._j) = NF(\ovr{g_i}(\ovr{d,e_i})._j))))\rbrace
\end{displaymath}
If we take a look at Example \ref{cexample:sug1}, we see it might be possible to improve our proposal to detect more constant \pps .
\begin{example}Let $CE1$ be \label{cexample:sug1}\begin{verbatim}

proc P(x : Nat) = true -> P(x := 2 * x);
init P(x : = 0);

\end{verbatim}
\end{example}
\begin{flushleft}
If we use Definition \ref{def:sug1}, we get:\\
\end{flushleft}
\begin{tabbing}
\tab
\> \> $S_{CE1}^1$\\
\> $\equiv$\\
\> \> $\lbrace j \in \lbrace 1 \rbrace \vert \forall_{x : Nat}( x = 2 \ast x ) \rbrace $\\
\> $\equiv$ \\
\> \> $\lbrace j \in \lbrace 1 \rbrace \vert false \rbrace $\\
\> $\equiv$ \\
\> \> $\emptyset$ \\
\end{tabbing}
In Definition \ref{def:sug1} it has to hold for every $\ovr{d}$, however
we don't want to inspect all possible $\ovr{d}$'s. We want to inspect it for a specific instantiation LPS of a $X(\ovr{v_0})$.
\end{defn}

\subsection{Proposal 2 - without free variables}
In Section \ref{sec:prop1} we see that Definition \ref{def:sug1} can be improved, if we can give a specific $\ovr{d}$. We try to improve that approximation, by giving $\ovr{d}$ a specific value in $S_L^2$. So we define:

\begin{defn}\label{def:sug2}  Let $L$ be an LPS
\begin{displaymath}
S_L^2(\ovr{d})=
\lbrace
j \in \lbrace 1, \ldots , n \rbrace \vert \forall_{i\in I} (NF(c_i(\ovr{d,e_i})) = "true") \Rightarrow \ovr{d}._j = NF(\ovr{g_i}(\ovr{d,e_i})._j)))\rbrace
\end{displaymath}
%We elimate the problem for checking each state
We now can "instantiate" the $S^2$ with a $\ovr{d}$. If we instantiate $S^2$ with $\ovr{v_0}$, there is a problem. If we take a look at Example \ref{cexample:sug2}, we can see why:

\begin{example} Let $E2$ be\label{cexample:sug2}\begin{verbatim}

proc P(x,y: Nat) = (x=0) -> P(x:= 1, y:= 0) +
                   (x=1) -> P(x:= x, y:= 1);
init P(x := 0, y:= 0);

\end{verbatim}
\end{example}
If we use Definition \ref{def:sug2}, we get:
\begin{tabbing}
\hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm}  \= \hspace*{5.mm}  \= \hspace*{5.mm}  \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm}\kill
\> \> $S_{E2}^2(\langle 0, 0 \rangle)$\\
\> $\equiv$\\
\> \> $\lbrace j \in \lbrace 1, 2 \rbrace \vert \forall_{i\in I} (NF(c_i( \langle  0,  0\rangle ) = "true") \Rightarrow  \langle  0,  0\rangle._j = NF(\ovr{g_i}( \langle  0,  0\rangle)._j))\rbrace $\\\
\> $\equiv$ \\
\> \>$\lbrace j \in \lbrace 1, 2 \rbrace \vert $ \\
\> \> \> $(NF(\ovr{c_1}( \langle  0,  0\rangle ) = "true") \Rightarrow  \langle  0,  0\rangle._j = NF(\ovr{g_{1}}( \langle  0,  0\rangle)._j)) $\\
\> \> \> $\wedge$ \\
\> \> \> $ (NF(\ovr{c_2}( \langle  0,  0\rangle ) = "true") \Rightarrow  \langle  0,  0\rangle._j = NF(\ovr{g_{2}}( \langle  0,  0\rangle)._j)) $ \\
\> \>$
\rbrace $\\
\> $\equiv$ \\
\> \> $\lbrace j \in \lbrace 1, 2 \rbrace \vert $\\
\> \> \> $("true" \Rightarrow  \langle  0,  0\rangle._j = NF(\ovr{g_{1}}( \langle  0,  0\rangle)._j))$ \\
\> \> \> $\wedge$ \\
\> \> \> $("false" \Rightarrow  \langle  0,  0\rangle._j = NF(\ovr{g_{2}}( \langle  0,  0\rangle)._j))$ \\
\> \> $\rbrace $\\
\> $\equiv$ \\
\> \> $\lbrace j \in \lbrace 1, 2 \rbrace \vert
\langle  0,  0\rangle._j = NF(\ovr{g_1}( \langle  0,  0\rangle)._j)
\rbrace $\\
\> $\equiv$\\
\> \> $\lbrace j \in \lbrace 1 \rbrace \vert (( 0)  = ( 1)) \rbrace $\\
\> \> $\cup$ \\
\> \> $\lbrace j \in \lbrace 2 \rbrace \vert (( 0)  = ( 0)) \rbrace $\\
\> $\equiv $ \\
\> \> $\lbrace 2 \rbrace$ \\
\end{tabbing}

$S_{E2}^2(\langle 0,0 \rangle) = \lbrace 2 \rbrace$. This indicates that the second \pp\ is constant. However if we take another step from the initial state, we see the the that the second \pp\ is not constant. We only inspect those states which are adjacent to the initial state, which might result in a wrong solution.
\end{defn}

\subsection{Proposal 3 - without free variables}
To overcome the problem in which only the states adjacent to the initial state are compared, we suggest this proposal. First we redefine when the next state of summands should compared to the initial state. So if we have a condition and the condition is an open term, it might be that this condition will not reduce to a normal form which is either \ti{true} or \ti{false}. In such a case, there might be an valuation of the variables in the condition for which the condition holds. If this is the case we know the condition of a particular summand might be \ti{true}, so the corresponding next state should be inspected. The summands for which the conditions are \ti{false} are not inspected. \\

\begin{defn}[$\bot$] Let $x$ be a \pp . We define $\bot$ to be the value of \pp\ $x$, if $x$ is not constant.
\end{defn}

We are interested in the largest subset of constant \pps\ so:

Let $X \subseteq \lbrace 1, \ldots, n \rbrace$ \footnote{$X$ is the set of indices which we are looking for} be a set of indices of constant \pps\ of an LPS:

\begin{defn} We define $\otimes_X(\ovr{d})$:\\
Let $j \in \lbrace 1, \dots, \vert \ovr{d} \vert \rbrace $. \\
If $j \not\in X$ then $\otimes_X(\ovr{d})._j = \bot $. \\
If $j \in X$ then $\otimes_X(\ovr{d})._j = \ovr{d}._j$.\\
\end{defn}

In order find the largest subset we give:

\begin{defn} \label{def:sug3} Let $L$ be an LPS. We define: $ S_L^3(\ovr{v_0}) \subseteq \lbrace 1, \ldots, n \rbrace $
 as the biggest possible set such that:\\
\begin{tabbing}
\tab
\> $\forall_{i \in I} (NF( c_i ( \ovr{\otimes_{S_L^3}(\ovr{v_0}), e_i} ) ) \not= "false" \Rightarrow \forall_{j \in S_L^3}(\ovr{v_0}._j =  NF( \ovr{g_i}(\ovr{\otimes_{S_L^3}(\ovr{v_0}), e_i} )._j))) $
\end{tabbing}
\end{defn}

\begin{thm} Let $L$ be an LPS and $\ovr{d}$ a vector of \pps \label{thm:sub}
$$S_L^3(\ovr{d}) \subseteq S_L(\ovr{d}) $$
\end{thm}
\begin{flushleft}

\begin{defn}[$@$] Let $\ovr{d} = (d_1, \dots d_n)$, let $j \in \lbrace 1, \ldots , \vert \ovr{d} \vert \rbrace$ and let $x$ be a value.\\
$\ovr{d}@_j(x)$ is defined as the substitution of the $j^{th}$ element of $\ovr{d}$ with the value of $x$.
\end{defn}

% \begin{defn}[$\ovr{\Bbb{D}}$] Let $\ovr{d} = (d_1, \dots d_n)$ and $j \in \lbrace 1, \ldots \vert \ovr{d} \vert \rbrace$.\\
% $\ovr{\Bbb{D}}._j$ is defined as the domain of the $j^{th}$ element in vector $\ovr{d}$.
% \end{defn}

\begin{defn}[$\varphi(\ovr{d},X)$]
$\varphi$ is a function of $\ovr{D} \times \mathcal{P}(Nat) \rightarrow \mathcal{P}(\ovr{D})$:
\begin{displaymath}
    \varphi(\ovr{d},X) = \left \{
        \begin{array}{l l}
            X = \emptyset                       & \rightarrow \lbrace \ovr{d} \rbrace \\
            X \neq \emptyset                    & \rightarrow \cup_{y \in \ovr{D}._z} \varphi(\ovr{d}@_z(y), X \setminus \lbrace z \rbrace ) \hspace{20pt} \text{with } z \in X \\
        \end{array} \right.
\end{displaymath}

\end{defn}

\tb{Proof. \ref{thm:sub}}
\end{flushleft}
We do case distinction on $S_L^3(\ovr{v_0})$:\\
\begin{itemize}
\newcommand{\tmp}{\vspace{8pt}}

\item[-] Let $S_L^3(\ovr{v_0})$ be empty, then $S_L^3(\ovr{v_0}) \subseteq S_L(\ovr{v_0})$ holds trivially.
\item[-] Let $S_L^3(\ovr{v_0})$ not be empty. We prove that if there is an element in $S_L^3(\ovr{v_0})$, then this element is also in $S_L(\ovr{v_0})$. \\ \tmp
\tmp $ j \in S_L^3(\ovr{v_0})$ \\
\tmp $ \equiv $ \hspace{20pt} $\lbrace$ Def \ref{def:sug3} of $S_L^3 \rbrace$ \\
\tmp $ j \in \lbrace k \in \lbrace 1, \ldots, n \rbrace \vert \forall_{i \in I}(NF(c_i(\ovr{\otimes_{S_L^3}(\ovr{v_0}), e_i})) \neq false \Rightarrow \ovr{v_0}._k = NF(\ovr{g_i}(\otimes_{S_L^3}(\ovr{v_0}), e_i)._k) ) \rbrace$ \\
\tmp $ \equiv $ \hspace{20pt} $\lbrace$ Property of $\ovr{\otimes_{S_L^3}(\ovr{v_0},e_i})\rbrace$ \\
\tmp $ j \in \lbrace k \in \lbrace 1, \ldots, n \rbrace \vert \forall_{i \in I, \ovr{e_i} \in \ovr{E_i}}(\forall_{\ovr{x} \in
 \varphi(\ovr{v_0},S_L^3)
}(c_i(\ovr{x, e_i}) \Rightarrow \ovr{v_0}._k = \ovr{g_i}(\ovr{x, e_i})._k )) \rbrace$\\
\tmp $ \Rightarrow$ \hspace{20pt} $\lbrace  \varphi(\ovr{v_0},S_L^3) \supseteq R_L(\ovr{v_0}) \footnote{See Example \ref{example:proof3}} \rbrace$  \\
\tmp $ j \in \lbrace k \in \lbrace 1, \ldots, n \rbrace \vert \forall_{i \in I, \ovr{e_i} \in \ovr{E_i}}(\forall_{x \in R_L(\ovr{v_0})}( c_i(\ovr{x, e_i})  \Rightarrow \ovr{v_0}._k = \ovr{g_i}(\ovr{x, e_i})._k )) \rbrace$\\
% \tmp $ \equiv $\\
\tmp $ \equiv $ \hspace{20pt} $\lbrace \forall_{i \in I, \ovr{e_i} \in \ovr{E_i}} \forall_{x \in R_L(\ovr{v_0})} c_i(x,e_i) \Rightarrow \ovr{g_i}(\ovr{x, e_i}) \in R_L(\ovr{v_0}) ) \rbrace$\\
\tmp $j \in \lbrace k \in \lbrace 1, \ldots, n \rbrace \vert \forall_{i \in I, \ovr{e_i} \in \ovr{E_i}}(\forall_{x \in R_L(\ovr{v_0})} \forall_{y \in R_L(\ovr{v_0})} (y = \ovr{g_i}(x,e_i) \wedge c_i(x, e_i) \Rightarrow \ovr{v_0}._k = y_.k )  \rbrace $\\
% \tmp $ j \in \lbrace k \in \lbrace 1, \ldots, n \rbrace \vert \forall_{i \in I, \ovr{e_i} \in \ovr{E_i}}(\forall_{x \in R_L(\ovr{v_0})}( c_i(\ovr{x, e_i})  \Rightarrow \ovr{v_0}._k = \ovr{x}.k) \rbrace$\\
% \tmp $\Rightarrow$ \hspace*{20pt} $\lbrace \forall_{x,y \in R_L(\ovr{v_0})\ovr{e_i} \in \ovr{E_i}}(c(\ovr{x,e_i}) \Rightarrow \ovr{v_0}._k = \ovr{y}._k)\rbrace$ \\
\tmp $ \equiv$ \hspace{20pt} $\lbrace \ovr{v_0}  \in R_L(\ovr{v_0}) \rbrace$\\
\tmp $ j \in \lbrace k \in \lbrace 1, \ldots, n \rbrace \vert \forall_{x \in R_L(\ovr{v_0})}(\ovr{x}._k = \ovr{v_0}._k) \rbrace$\\
\tmp $ \equiv$ \hspace{20pt} $\lbrace$ Def \ref{def:lps_comp} of $S_L\rbrace$\\
\tmp $ j \in S_L(\ovr{v_0})$

\begin{example}\label{example:proof3}
Let $S = \lbrace 1, 2 \rbrace$.
We have $\ovr{z} = (1, 5, 3)$.
% We know because of $S$ that the $3^{th}$ element is not constant and therefore is $\bot$.
% So we redefine to $z$ to be $(1, 5, \bot)$.
% The $3^th$ element of the vector is of type $\lbrace 1, 2, 3, 4\rbrace$, so $\bot : \lbrace 1, 2, 3, 4 \rbrace$.
The values of the $3^{th}$ vector can range between 1 and 4.
If we want to map this vector to a statespace, knowing that the first and the second are
constant is, we get the following state space:
$$  \varphi(\ovr{v_0},S_L^3) = \lbrace (1, 5, 1), (1, 5, 2), (1, 5, 3), (1, 5, 4) \rbrace$$
which is a maximal statespace.
If we have $R_L(\ovr{z})$ (and we know this is reachable set is minimal) the maximal space space genarated would be
$\lbrace (1, 5, 1), (1, 5, 2), (1, 5, 3), (1, 5, 4) \rbrace$ and a minimal set might be $\lbrace (1, 5, 1), (1, 5, 4) \rbrace$.
So:
$R_L(\ovr{z}) \subseteq \lbrace (1, 5, 1), (1, 5, 2), (1, 5, 3), (1, 5, 4) \rbrace =  (1, 5, \bot) = \ovr{z} $\\
\end{example}

\end{itemize}
So we have derived that each element in $S_L^3(\ovr{v_0})$, is also in $S_L(\ovr{v_0})$.
\\ \sq


\newpage
\subsection{Proposal 4 - with free variables}

We are interested in the largest subset of constant \pps ; for each \pp\ it should hold that it should equal to all their next state \pps.

Let $X \subseteq \lbrace 1, \ldots, n \rbrace$ of constant \pps\ of an LPS:

% \begin{defn} We define $\oplus_X^{FV}(\ovr{d})$:\\
% Let $j \in \lbrace 1, \dots, \vert \ovr{d} \vert \rbrace $ and let $y$ be an element out of a proper domain.\\
% % If $j \in X$ and $\ovr{d}._j \in FV $ then $\oplus_X^{FV}(\ovr{d})._j = y$. \\
% If $j \in X$ and $\ovr{d}._j \not\in FV $ then $\oplus_X^{FV}(\ovr{d})._j = \ovr{d}._j$.\\
% If $j \not\in X$ then $\oplus_X^{FV}(\ovr{d})._j = \bot$\\
% \end{defn}

\newcommand{\z}{(\ovr{\otimes_{S_L^4}^{FV}(\ovr{v_0}),e_i})}

\noindent In order find the largest subset we give: % to the following definition:
\begin{defn} \label{def:sug4} Let $L$ be an LPS. We define $S_L^4$:
\begin{tabbing}
\tab
$ S_L^4(\ovr{v_0}) \subseteq \lbrace 1 \ldots n  \rbrace $ \\ \\
is the biggest subset, for which holds:\\
% \> $\forall_{i \in I }($ \\
\> $\forall_{j \in S^L_4(\ovr{v_0})}($\\
% \> \> \> $ c_i\z \neq false \Rightarrow $ \\
\> \>$NF(\ovr{v_0}._j) \not\in FV \Rightarrow $\\
\> \>$\forall_{i \in I} (NF(c_i\z) \neq \text{false } \wedge$ \\
\> \>$NF(\ovr{g_i}\z._j) \not\in FV \Rightarrow$\\
\> \> \> $NF(\ovr{g_i}\z._j)= NF(\ovr{v_0}._j)$\\
 \> \> $)$\\
\> $\land$\\
\> \> $NF(\ovr{v_0}._j) \in FV \Rightarrow$ \\
\> \>$ \exists_k(\forall_{i \in I} (NF(c_i\z) \neq \text{false } \wedge $\\
\> \>$ NF(\ovr{g_i}\z._j) \not\in FV \Rightarrow $ \\
\> \> \> $ NF(\ovr{g_i}\z._j)= k)$\\
\> \> $)$\\
% \> \> \> $)$ \\
\> $)$\\
% \> $)$ \\
% $)$
\end{tabbing}
\end{defn}

If we compare Definition \ref{def:sug4} to Definition \ref{def:lps_comp_fv} we see that Theorem \ref{thm:sub_fv} holds :
\begin{thm}\label{thm:sub_fv} Let $L$ be an LPS and $\ovr{d}$ a vector op \pps .
$$S_L^4(\ovr{d}) \subseteq S_L^{FV}(\ovr{d}) $$
\end{thm}
% \begin{flushleft}
% We do case distinction on $S_L^3(\ovr{init})$:\\
% \tb{Proof. \ref{thm:sub_fv}}
% \end{flushleft}
% \begin{itemize}
% \newcommand{\tmp}{\vspace{8pt}}

% \item[-] Let $S_L^4(\ovr{init})$ be empty, then $S_L^3(\ovr{init}) \subseteq S_L^{FV}(\ovr{init})$ holds trivially.
% \item[-] Let $S_L^4(\ovr{init})$ not be empty. We prove that if there is an element in $S_L^4(\ovr{init})$, then this element is also in $S_L^{FV}(\ovr{init})$. \newline \newline
% $\vdots$
% \end{itemize}

% So we have derived that each element in $S_L^4(\ovr{init})$, is also in $S_L^{FV}(\ovr{init})$.


\section{Algorithm description}
In this section we informally describe the algorithms for finding constant \pps\ in LPSs with and without \ti{free variables}. First a description is given about how to determine the constant \pps\ when an LPS does not contain any free variables. Next an informal description is given for finding constant \pps\ when an LPS contains free variables.

\subsection{without free variables}\label{alg:org}

First the \sv\ is constructed from the initial process of the \lps. Next the set $S$ is defined, which $S$ contains the indices for all \pps\ that might be constant. It might be the case that all \pps\ are constant so we start off with having all indices in set $S$. If a \pp\ is detected to be variable, this \pp\ is removed from the set $S$.

We keep on removing elements from $S$ until no more elements can be removed. Removing the elements is done as follows:
First we fill in all values of the \pps , for which the index is in $S$, into the conditions. Next all conditions are rewritten and compared to \ti{false}.

If the rewritten condition, in its normal form, is different from \ti{false} the condition might be \ti{true}, thus we calculate the nextstate of the current summand.  We compare each element from the \sv\ with the nextstate vector for which the indices are in $S$. If an element is not equal, the corresponding index is removed from the set $S$.
At value at the removed index of the \sv\ is replaced by $\bot$.

If no elements are removed from $S$ during the iteration, there are either no more constant \pps\ or all \pps\ are constant. If this is the case we stop the iteration. Next all occurrences in of constant \pps\ are substituted with their constant values and are constant \pps\ are removed form the list of \pps\ from the LPS.

\subsection{with free variables}
Before describing the algorithm informally we define some rules which should hold when we use \ti{free variables}. The set  $S$ is again the set of indices of constant \pps .

The values of \pps\ can either be given a specific value or a \ti{free variable}. In order to determine if a \pp\ is constant or variable we define rules.

\begin{enumerate}
\item The \pp\ has a specific value or is a \ti{free variable} and a \ti{free variable} is assigned to this \pp :\\
If \ti{free variable} is assigned to a \pp\ with a specific value, the value of this \pp\ remains unchanged. If the index of \pp\ is in $S$, it will not be removed from $S$. If we would allow replacement of a specific value with a \ti{free variable}, this might lead to a fault result. Consider the next example; Let $x_1$ and $x_2$ be two specific values which are not equal to each other. Let $v_1$ be a \ti{free variable}. Let the index of \pp\ be in $S$. This \pp\ has the value $x_1$ and is replaced with $v_1$, the index of \pp\ stays in $S$. If in a next state this \pp\ is substituted with $x_2$, the index remains in $S$. This indicates that the \pp\ would remain constant. Clearly this observation is wrong. So we prohibited assigning \ti{free variables} by specific values.

\item A \pp\ which is a \ti{free variable} is substituted with a specific value:\\
The \pp\ gets the value which is substituted and the \pp\ remains in $S$ if the specific value is not $\bot$. If the \pp\ gets the value $\bot$ the \pp\ is removed from $S$.

\item The \pp\ which is specific value is substituted with another specific value:\\
If the substituted value differs from the original value, the \pp\ becomes marked variable and is removed from the set $S$.
If they are equal, the \pp\ remains in the set $S$ if it already had been in the set $S$.
\end{enumerate}

If no constant \pps\ can be removed, the algorithm ends. However it is possible that we end in a situation like in Example \ref{freevarcheckup}. If we follow the algorithm, we see that the algorithm detects the $3^{th}$ element as a constant \pp. However the $3^{th}$ is not a constant \pp . To overcome the detection of fake constant \pps , we have to take an extra pass on the LPS. The current state vector is compared to the nextstates of summands on which the condition is not false.
If all \pps\ of all nextstates are equal\footnote{with respect to the extended rules on \ti{free variables}} to the current state, then there are no fake constant \pps . If the pass detects a \pp\ which is not the same in the nextstate as in the current state, the algorithm starts over with:
\begin{itemize}
\item $S$ without the indices of found fake constant \pps .
\item All the \pps\ which are fake constant \pps\ are substituted with the value $\bot$.
\end{itemize}
If the "Free Variable Checkup" does not find fake constants the algorithm ends.

\begin{example}\label{freevarcheckup} This LPS contains fake constant \pps .  $FV_x$ indicates the $x^{th}$ element in the set of $FV$.
\begin{tabbing}
\tabw
\tb{act} \> a; \\
\tb{proc} \> X(a, b , c) =     \>  a. X( $FV_4$, $FV_5$, a) + \\
\>                             \>  a. X( $FV_6$, $FV_7$, b) + \\
\>                             \>  a. X(   8 ,   9,  $FV_8$);  \\
\tb{init} \> X($FV_1$, $FV_2$, $FV_3$);
\end{tabbing}
\end{example}


In this part we only describe the difference between the algorithm without \ti{free variables}. The algorithm remains basically the same. We only extend Algorithm Description \ref{alg:org} when comparing elements from the current state with the corresponding next state. When comparing we use the rules associated with \ti{free variables}.

\newpage
\section{Algorithms}
\subsection{without free variables} \label{sec:alg}
\line(1,0){200}\\
\textbf{lpsconstelm (without free variables)}\\
\line(1,0){200}
\begin{algorithmic}[1]
\STATE $curr := v_0$
\STATE $R := \lbrace 1 \ldots \vert v_0 \vert \rbrace $
\STATE $S := \emptyset $
  \WHILE{$S \neq R $}
    \STATE $S := R$
    \FORALL{$ (i \in I) \wedge NF((c_i(curr)) \neq false) $}
        \FORALL{$j \in S $}
          \IF{$ NF((g_i(curr)._j) \neq curr._j)$}
              \STATE $curr._j := \bot$
              \STATE $R := R \setminus \lbrace j \rbrace$
          \ELSIF{$otherwise$}
              \STATE $skip$
          \ENDIF
        \ENDFOR
    \ENDFOR
  \ENDWHILE
\RETURN $S$
\end{algorithmic}

\newpage
\subsection{with free variables}
\line(1,0){200}\\
\textbf{lpsconstelm (with free variables)}\\
\line(1,0){200}
\begin{algorithmic}[1]
\STATE $curr := v_0$
\STATE $R := \lbrace 1 \ldots \vert v_0 \vert \rbrace $
\STATE $S := \emptyset $
\WHILE{$S = R$}
  \WHILE{$S = R$}
    \STATE $S := R$
    \FORALL{$ (i \in I) \wedge (c_i(curr) \neq false)$}
        \FORALL{$j \in S $}
          \IF{$ curr._j \in FV$}
            \IF{$ g_i(curr)._j \not\in FV $}
              \STATE $ curr._j := g_i(curr)._j $
              \IF{$ curr._j = \bot $}
                \STATE $R:= R \setminus \lbrace j \rbrace $
	      \ENDIF
            \ELSIF{$ g_i(curr)._j \in FV $}
               \STATE $ skip $
            \ENDIF
          \ELSIF{$curr._j \not\in FV$}
            \IF{$ (g_i(curr)._j \not\in FV) \wedge (g_i(curr)._j \neq curr._j)$}
              \STATE $curr._j = \bot$
              \STATE $R := R \setminus \lbrace j \rbrace$
            \ELSIF{$ (g_i(curr)._j = curr._j) \vee (g_i(curr)._j \in FV)$}
              \STATE $skip$
            \ENDIF
          \ENDIF
        \ENDFOR
    \ENDFOR
  \ENDWHILE \newline
  \algorithmiccomment{Free Variable Checkup}
  \FORALL{$ j \in R $}
    \STATE $t:= NILL$
    \FORALL{$ i \in I$}
      \IF{$g_i(curr)._j \not\in FV \wedge t = NILL$}
        \STATE $ t := g_i(curr)._j $
      \ELSIF{$ g_i(curr)._j \not\in FV \wedge  t \neq NILL \wedge t \neq g_i(curr)._j$}
        \STATE $ R := R \setminus \lbrace j \rbrace$
        \STATE $ curr._j := \bot $
      \ELSIF{$ otherwise$}
        \STATE $skip$
      \ENDIF
    \ENDFOR
  \ENDFOR
\ENDWHILE
\RETURN $S$
\end{algorithmic}
% \end{algorithm}
\newpage

\section{Test Cases}
All specifications are given in \mcrl\ specification.
Transformation from a \mcrl\ specification to an LPS file is done with the tool:
$mcrl22lps$. Each transformation is executed with the \verb"-no-cluster" option, unless
mentioned otherwise.

\subsection*{Case 1}
inputfile: \verb"$DIR$/tests/lpsconstelm/case1.mcrl2"
\begin{tabbing}
\tabw
\ti{info} \> This case is designed to detect if the \tool\ can detect a simple constant \\
\> \pp .\\
\line(1,0){120}\\

\tb{act}  \> action: Nat;\\
\tb{proc} \> P(i: Nat) \> = \> action(i).P(i);\\
\tb{init} \> P(0);\\

\line(1,0){120}\\
\ti{Result}
\> All occurrences of i should be substituted by 0 and i should be removed from the list of \\
\> \pps . \\
\end{tabbing}

\subsection*{Case 2}
inputfile: \verb"$DIR$/tests/lpsconstelm/case2.mcrl2"
\begin{tabbing}
\tabw
\ti{info}
\> This case is designed to detect if the \tool\ can detect a simple non constant \\
\> \pp .\\
\line(1,0){120}\\
\tb{act}  \> action: Nat;\\
\tb{proc} \> P(i: Nat) \> = \> action(i).P(i+1);\\
\tb{init} \> P(0);\\
\line(1,0){120}\\
\ti{Result} \> $i$ is not constant, therefor $i$ should not be substituted and removed. The LPS \\
\> remains the same. \\
\end{tabbing}

\subsection*{Case 3}
inputfile: \verb"$DIR$/tests/lpsconstelm/case3.mcrl2"
\begin{tabbing}
\tabw
\ti{info}
\> This case is designed to detect if the \tool\ can detect a simple non constant \\
\> and a simple constant \pp .\\
\line(1,0){120}\\
\tb{act}  \> action: Nat;\\
\tb{proc} \> P(i,j: Nat) \> = \> action(j).P(i+1, j);\\
\tb{init} \> P(0,5);\\
\line(1,0){120}\\
\ti{Result} \> $i$ is not constant, $i$ is not constant.$i$ is not to be removed, occurrences of \\
\> $j$ should be substituted by 5 and $j$ should be removed from the list of \pps .\\
\end{tabbing}

\subsection*{Case 4}
inputfile: \verb"$DIR$/tests/lpsconstelm/case4.mcrl2"
\begin{tabbing}
\tabw
\ti{info} \> This case is to designed to test the arguments \verb"-no-condition", \\
\> \verb"-no-reachable" and the the way the tool deals with multiple simple summands. \\
\line(1,0){120}\\
\tb{act}  \> action: Nat;\\
\tb{proc} \> P(i,j: Nat) \> = \> true  $\rightarrow$ action(j).P(i+1, j)+\\
          \>             \>   \> false $\rightarrow$ action(j).P(i+1, j+1);\\
\tb{init} \> P(0,5);\\
\line(1,0){120}\\
\ti{Result}
\> \verb"-": \> \> Only the fist summand is not false, therefor $j$ is constant and $i$ \\
\> \> \> is not constant. All occurrences of $j$ should be substituted by 5 and \\
\> \> \> $j$ should be removed from the list of \pps. Only the \\
\> \> \> first summand is written to the new LPS, because the \\
\> \> \> second summand is never evaluated.\\
\> \verb"-no-condition": \> \> All the conditions of the summands are considered to be true. If \\
\> \> \> this argument is used $i$ and $j$ are not constant\footnote{j is still constant but should not be marked as a constant \pp } and therefore no \\
\> \> \> \pp\ should be substituted and to be removed.\\
\> \verb"-no-reachable": \> \> Only the fist summand is not false, therefor $j$ is constant \\
\> \> \> and $i$ is not constant. All occurrences of $j$ should be substituted by \\
\> \> \> 5 and $j$ should be removed from the list of \pps. \\
\> \> \> Both summands are written to in the new LPS, allthough the second \\
\> \> \> summand is never inspected. Note that in the second summand $j$ is \\
\> \> \> the occurrences of $j$ is substituted with 5.\\
\end{tabbing}

\subsection*{Case 5}
inputfile: \verb"$DIR$/tests/lpsconstelm/case5.mcrl2"
\begin{tabbing}
\tabw
\ti{info} \> This case is designed to test the \verb"-no-singleton" argument. \\
\line(1,0){120}\\
\tb{sort} \> Singleton = struct x; \\
\tb{act}  \> action :Nat; \\
\tb{proc} \>  P(i : Nat, j : Singleton ) = true $\rightarrow$ action(i). P(i+1,j); \\
\tb{init} \>  P(0,x); \\
\line(1,0){120}\\
\ti{Result} \>
\verb"-": \> \> $j$ is found to be constant, so all occurrences of $j$ are substituted  \\
\> \> \> by the value $x$\\
\> \verb"-no-singleton" : \> \> "Singleton" has only one constructor. So all \pps\  \\
\> \> \>                       of type "Singleton" are not to be substituted and removed  \\
\> \> \>                       from the list of \pps . So in this case no  \\
\> \> \>                       modification is made to the LPS.
\end{tabbing}
\newpage
\subsection*{Case 6}
inputfile: \verb"$DIR$/tests/lpsconstelm/case6.mcrl2"
\begin{tabbing}
\tabw
\ti{info} \> This test is designed to test a mCRL2 specification with multiple actions. \\
          \> A multiple summand test. \\
\line(1,0){120}\\
\tb{act} \> action :Nat;\\
\tb{proc} \> P(i: Nat) = \>  action(i). Q(i);\\
     \> Q(i: Nat) = \>  action(i). P(i);\\

\tb{init} \> P(0);\\
\line(1,0){120}\\
\ti{Result} \> From the generated LPS we see that $i$ is constant. All occurrences of $i$ are to substituted \\
 \> by 0 and $i$ is removed from the list of \pps .
\end{tabbing}

\subsection*{Case 7}
inputfile: \verb"$DIR$/tests/lpsconstelm/case7.mcrl2"
\begin{tabbing}
\tabw
\tb{into} \> This case is designed to test if guards will influence the \tool\ correctly.\\
\line(1,0){120}\\
\tb{act}  \> action :Nat;\\
\tb{proc} \> P(i,j: Nat) =  \>  (i \verb">" 5) $\rightarrow$ action(i). P(i+1,j) +\\
          \>                \> (i == 5)        $\rightarrow$ action(j). Q(j);\\
          \> Q(i: Nat)   = \>                                action(i). Q(i);\\

\tb{init} \>  P(0,0);\\
\line(1,0){120}\\
\ti{Result} \> \verb"-": \> \> If no argument is used, all the conditions are false. So $s3, j$ and $i$ are \\
\> \> \>  marked constant. All occurrences are substituted and removed from \\
\> \> \> the list of \pps .\\
\> \verb"-no-condition": \> \> If this argument is used only $j$ will be marked constant. All \\
\> \> \> occurrences of $j$ are substituted by 0 and $j$ is removed from the \\
\> \> \> list of \pps .\\
\line(1,0){120}\\
\ti{Generated LPS} \\
\>  \verb" var  freevar,freevar0: Nat;"\\
\>  \verb" proc P(s3: Pos, j,i: Nat) = "\\
\>  \verb"        (s3 == 2) ->          "\\
\>  \verb"          action(i) .          "\\
\>  \verb"          P(s3 := 2, j := freevar0)"\\
\>  \verb"      + (s3 == 1 && 5 < i ) ->      "\\
\>  \verb"          action(i) .               "\\
\>  \verb"          P(s3 := 1, i := i + 1)  "\\
\>  \verb"      + (s3 == 1 && i == 5) ->   "\\
\>  \verb"          action(j) .          "\\
\>  \verb"          P(s3 := 2, j := freevar, i := j);"\\
\>  \verb"                 "\\
\>  \verb" init P(s3 := 1, j := 0, i := 0);"\\
\end{tabbing}
\newpage
\subsection*{Case 8}
inputfile: \verb"$DIR$/tests/lpsconstelm/case8.mcrl2"
\begin{tabbing}
\tabw
\ti{info} \> This case is designed to show the short comings of the algorithm. The \tool \ \\
	\> cannot detect equality of ($i$==5). It will detect that $i$ does not stay constant. \\
\tb{act} \> action: Nat;\\
\tb{proc} \> X(i: Nat)   = \>  (i \verb"<"  5) $\rightarrow$ action(i).X(i+1) +\\
           \>        \> (i == 5) $\rightarrow$ action(i).Y(i, i);\\
    \>  Y(i,j: Nat) = \>  action(j).Y(i,j+1);               \\
\tb{init} X(0);\\
\line(1,0){120}\\
\ti{Result} \> All \pps\ are not constant, so none of the occurrences of a \\
\> \pp\ are substituted by their value and are removed from the list of \\
\> \pps.\\
\line(1,0){120}\\
\ti{Generated LPS} \\
\>  \verb" var  freevar0: Nat;"                              \\      %%
\>  \verb" proc P(s3: Pos, i,j: Nat) = "                       \\    %%
\>  \verb"        (s3 == 2) ->        "                        \\    %%
\>  \verb"          action(j) .     "                          \\    %%
\>  \verb"          P(s3 := 2, j := j + 1)"                    \\    %%
\>  \verb"      + (s3 == 1 && i < 5) ->"                       \\    %%
\>  \verb"          action(i) . "                              \\    %%
\>  \verb"           P(s3 := 1, i := i + 1, j := freevar0) "   \\    %%
\>  \verb"      + (s3 == 1 && i == 5) -> "                     \\    %%
\>  \verb"          action(i) .       "                        \\    %%
\>  \verb"          P(s3 := 2, j := i);"                       \\    %%
\>  \verb"                            "                        \\    %%
\>  \verb" var  freevar: Nat;      "                           \\    %%
\>  \verb" init P(s3 := 1, i := 0, j := freevar);"             \\    %%
\end{tabbing}
% \newpage
% \subsection*{Case 9}
% inputfile: \verb"$DIR$/tests/lpsconstelm/case9.lps"
% \begin{tabbing}
% \tabw
% \ti{info} \> This test is designed to find fake constant \pps . It can \\
%  \> be the case that \pps\ appear to be constant, due the usage \\
% \> of free variables. However they may be dependant upon other \pps , \\
% \> for which there is a combination, that a constant marked \pp\ \\
% \> is not a constant \pp . Note that this LPS is self build LPS, to \\
% \> ensure that the "free variable check" is conducted. The test will only work when \\
% \> the argument \verb"-no-condition" is used.\\
% \line(1,0){120}\\
% \ti{Result} \> Only \pp\ $y$ is  not constant. $x$ is a fake constant. \\
% \> So only \pp\ $y$ is subsituted with 2 and is removed from the list of \\
% \> \pps . \\
% \line(1,0){120}\\
% \ti{Generated LPS} \\
% \>  \verb" act  a;"\\
% \>  \verb""\\
% \>  \verb" var  freevar1,freevar2: Nat;"\\
% \>  \verb" proc P(s3: Pos, y,x: Nat) ="\\
% \>  \verb"       (s3 == 1) ->"\\
% \>  \verb"         a ."\\
% \>  \verb"         P(s3 := 1, y := freevar1)"\\
% \>  \verb"     + (s3 == 2) ->"\\
% \>  \verb"         a ."\\
% \>  \verb"         P(s3 := 1, y := freevar2, x := y)"\\
% \>  \verb"     + (s3 == 1 || s3 == 2) ->"\\
% \>  \verb"         a ."\\
% \>  \verb"         P(s3 := 1, y := 2, x := 1);"\\
% \>  \verb""
% \>  \verb" var  freevar,freevar0: Nat;"\\
% \>  \verb" init P(s3 := 1, y := freevar, x := freevar0);"\\
% \end{tabbing}

\newpage
\begin{thebibliography}{99}
   \bibitem{LPS_info} unknown author \\
     \textit{Article not ready at the moment},
   \bibitem{LPSframework} J.W. Wesselink,
   \textit{http://www.win.tue.nl/~wieger/mcrl2/html/index.html}\\
   A C++ wrapper for the ATerm library.
   \bibitem{LPSformat} Aad Mathijssen\\
   \textit{https://svn.win.tue.nl/viewcvs-checkout/MCRL2/trunk/specs/mcrl2.internal.txt},
   A description of the internal format of the mCRL2 language.
  \bibitem{LPSfreevar} unknown author,
   \textit{Article not ready at the moment}

\end{thebibliography}

\newpage



\end{document}
