% This file describes the self-stabilisation protocol of Israeli
% and Jalfon. See "Token management schemes and random walks yield 
% self-stabilizating mutual exclusion. 1990". This example was taken
% from the PRISM Benchmark Suite: 
% http://www.prismmodelchecker.org/casestudies/self-stabilisation.php
%
% In this case there are 5 processes. Each process can hold a token
% and they are interconnected in a ring fashion. The communication is
% bidirectional. A process decides whether to send its token to the
% next or previous process in the ring with probability of 1/2 for each
% decision. The ring is stable if only one token is left. 
%
% The model of Israeli and Jalfon has the property that the components 
% can communicate independently of each other. A process may decide
% to communicate with another process, but postpone this, such that
% other processes may already have carried out various rounds of
% communication before the first process executes its first communication.
% 
% Hector Joao Rivera Verduzco. November 2016.

act send_token:Nat#Nat;
    read_token:Nat#Nat;
    comm_token:Nat#Nat;
    token, notoken, stable;

%   token:
proc P(id:Nat, token:Bool, prev:Nat, next:Nat)=
        (token == true)->(
                           dist b:Bool[1/2].
                           b-> send_token(id,next).P(id,false,prev,next)
                            <> send_token(id,prev).P(id,false,prev,next)
                         )+
        % It is always possible to receive a token from prev or next
        read_token(next,id).P(id,true,prev,next) + 
        read_token(prev,id).P(id,true,prev,next) +
        % Check for token
        (token) ->token.P()+
        (!token)->notoken.P()
    ;
               
init 
    allow({comm_token,stable},
    comm({send_token | read_token -> comm_token,
          token | notoken | notoken | notoken | notoken -> stable
         },
         P(0,true,4,1)||
         P(1,true,0,2)||
         P(2,true,1,3)||
         P(3,true,2,4)||
         P(4,true,3,0)
    ));
