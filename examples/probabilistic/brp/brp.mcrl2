% This file describes a variant of the bounded retransmission
% protocol. This example was taken from the PRISM Benchmark Suite: 
% http://www.prismmodelchecker.org/casestudies/brp.php
%
% This protocol specifies that a "sender" trying to deliver a file 
% divided in a number of chunks N. Furthermore, in case of
% failure the package is retransmitted. The maximum number of 
% retransmissions is bounded by MAX. The communication channels L and K
% between sender and receiver are not completely reliable, and their 
% behavior is modelled using a probabilistic labelled transition system
% to specify the probability of a packet to get lost in the channel.
%
% Hector Joao Rivera Verduzco. November 2016.

map N:Pos;
    MAX:Pos;
     
eqn N=10;
    MAX=4;
    
% Interactions
act new_file;
    fail_transmission;
    success_frame;
    send_aF;  read_aF;  c_aF;
    read_aB;  send_aB;  c_aB;
    read_aA;  send_aA;  c_aA;
    read_aG;  send_aG;  c_aG;
    read_TO_Ack; send_TO_Ack;  c_TO_Ack;
    read_TO_Msg; send_TO_Msg;  c_TO_Msg;
    send_success_file; read_success_file;  c_success_file;
    send_sync; read_sync;  c_sync;
    status_s, status_srep, status_i : Int;
    
% s: program counter
% 0 idle
% 1 next_frame	
% 2 wait_ack
% 3 retransmit
% 4 success
% 5 error
% 6 wait sync
proc sender(s:Int, srep:Int, nrtr:Int, i:Int, fSent:Int)=
        %idle
	% Only sent one file, similar to the PRISM model
        (s==0 && fSent==0)->new_file.sender(1,0,nrtr,1,fSent+1)+
        % next frame
        (s==1)->send_aF.sender(2,srep,0,i,fSent)+
        % wait ack
        (s==2)->read_aB.sender(4,srep,nrtr,i,fSent)+
        (s==2)->read_TO_Msg.sender(3,srep,nrtr,i,fSent)+
        (s==2)->read_TO_Ack.sender(3,srep,nrtr,i,fSent)+
        % retransmit
        (s==3 && nrtr<MAX)->send_aF.sender(2,srep,nrtr+1,i,fSent)+
        (s==3 && nrtr==MAX && i<N)->fail_transmission.sender(5,1,nrtr,i,fSent)+
        (s==3 && nrtr==MAX && i==N)->fail_transmission.sender(5,2,nrtr,i,fSent)+
        % success
        (s==4 && i<N)->success_frame.sender(1,srep,nrtr,i+1,fSent)+
        (s==4 && i==N)->send_success_file.sender(0,3,nrtr,i,fSent)+
        % error
        (s==5)->send_sync.sender(6,srep,nrtr,i,fSent)+
        % wait sync
        (s==6)->send_sync.sender(6,srep,nrtr,i,fSent)+
        % send status (required for mu-calculus formulas)
        status_s(s).sender()+
        status_srep(srep).sender()+
        status_i(i).sender()
     ;
               
    receiver(r:Int)=
        % new file
        (r==0)->read_aG.receiver(1)+
        (r==1)->send_aA.receiver(0)+
        read_success_file.receiver(0)+
        read_sync.receiver(0)
    ;
               
    channelK(k:Int)=
        % idle
        (k==0)->read_aF.( dist b:Bool[if(b,98/100,2/100)].
                          b-> channelK(1)
                          <>  channelK(2)
                         )+
        % sending
        (k==1)->send_aG.channelK(0)+
        % lost
        (k==2)->send_TO_Msg.channelK(0)
    ;
    
    channelL(l:Int)=
        % idle
        (l==0)->read_aA.( dist b:Bool[if(b,99/100,1/100)].
                          b-> channelL(1)
                          <>  channelL(2)
                         )+
        % sending
        (l==1)->send_aB.channelL(0)+
        % lost
        (l==2)->send_TO_Ack.channelL(0)
    ;
% 
init 
    hide({c_aF, c_aB, c_aA, c_aG, c_TO_Ack, c_TO_Msg, c_success_file, c_sync},
	allow({new_file, fail_transmission, success_frame, c_aF,
           c_aB, c_aA, c_aG, c_TO_Ack, c_TO_Msg, c_success_file,
           c_sync, status_s, status_srep, status_i},
    comm({read_aF | send_aF -> c_aF,
          read_aB | send_aB -> c_aB,
          read_aA | send_aA -> c_aA,
          read_aG | send_aG -> c_aG,
          read_TO_Ack | send_TO_Ack -> c_TO_Ack,
          read_TO_Msg | send_TO_Msg -> c_TO_Msg,
          send_success_file | read_success_file -> c_success_file,
          send_sync | read_sync -> c_sync},

        sender(0,0,0,0,0)||
        channelK(0)||
        channelL(0)||
        receiver(0)
        )));
