% This specification describes the game `Othello' or `Reversi', which is a two
% player board game. There is a board of N by M where N and M are generally both 8.
% One player has white pieces (W) and the
% other has red pieces (R). Initially, the board is set up as:
%
%      . . . . . . . .
%      . . . . . . . .
%      . . . . . . . .
%      . . . R W . . .
%      . . . W R . . .
%      . . . . . . . .
%      . . . . . . . .
%      . . . . . . . .
%
% Red makes the first move and the players alternatingly put a piece on
% the board, unless a player cannot put a piece on the board,
% in which case he must skip his turn.
% A move is made by putting a piece on the board such that at least
% one piece of the opponent is enclosed with two opposite colors.
% Subsequently all pieces that are enclosed will change color.
%
% The game ends when both players cannot do a move anymore. 
% The player with the largest number of pieces
% on the board wins. If both players have the same number of pieces
% it is a draw.
%
% The following formula expresses that with a perfect play white
% can always win the game. Either white wins right away, or if white can move, 
% there is a winning move of White, or
% if Red can do a move, all moves of Red will lead to a winning
% situation for White.
% 
% mu X.(<WhiteWins>true || 
%       (( forall x,y:Pos.[WhiteMove(x,y)]false || exists x,y:Pos.<WhiteMove(x,y)>X) &&
%          forall x,y:Pos.[RedMove(x,y)]X ))
%
% On a 4x4 board this formula is true, i.e. white can always win the game.
% When verifying this formula, it is useful to apply lpssuminst and lpsparunfold.
% It is also useful to avoid rewriting when linearising this example (flag -o), as
% rewriting will give a huge specification.
%
% The formula that expresses that red has a winning strategy is the following.
% On a 4x4 board it does not hold.
%
% mu X.(<RedWins>true || 
%        ((forall x,y:Pos.[RedMove(x,y)]false || exists x,y:Pos.<RedMove(x,y)>X) &&
%          forall x,y:Pos.[WhiteMove(x,y)]X ))
%
% Thanks go to Mark Winands for suggesting the game.
%
% Reijkjavik, May 16, 2006, Jan Friso Groote
% Improvements made in Juli 2009.

sort Piece = struct Red | White | None;
map N,M:Pos;
eqn N=4;
    M=4;

sort Row=List(Piece);
     Board=List(Row);
map  At:Nat#Nat#Board->Piece;                       % At(x,y,b) give the piece at position x,y. If there is no
                                                    % piece, or if x,y is outside the board, give None.
     At:Nat#Row->Piece;                             % See At above. Now for a single row.
     Put:Piece#Pos#Pos#Board->Board;                % Put piece p at the indicated position in a board.
     Put:Piece#Pos#Row->Row;                        % Put piece p at the indicated position in a row.
     Count:Piece#Board->Nat;                        % Count the number of pieces p on the board.
     Count:Piece#Pos#Pos#Board->Nat;                % Auxiliary function to count the number of pieces on the board.
     Enclosing:Piece#Pos#Pos#Board->Bool;           % Find out whether putting a piece p at coordinates x,y
                                                    % will enclose a set of pieces of the opponent.
     Search:Piece#Pos#Pos#Int#Int#Bool#Board->Bool; % Search is an auxialiary function, which finds out whether
                                                    % on the board, from position x,y in direction dx,dy pieces of the
                                                    % opponent can be found, followed by a piece of the own color. The 
                                                    % boolean indicates whether pieces of the opponent have already
                                                    % been observed.

     Swap,Swap1:Piece#Pos#Pos#Int#Int#Board->Board; % Swap the pieces of the opposite color than the given piece to that of 
                                                    % the given piece in the given direction, until an empty spot, or a piece
                                                    % of color p is encountered. The initial position x,y is not considered.
                                                    % Swap1 is an auxiliary function.
     CanMove:Piece#Board->Bool;                     % Indicates whether the indicated piece can be put on the board.
     CanMove:Piece#Pos#Pos#Board->Bool;             % Indicates whether the indicated piece can be put on the given coordinates 
                                                    % on the board.
     PutPiece:Piece#Pos#Pos#Board->Board;           % Put a piece p at the given coordinates and swap pieces of the opposite
                                                    % color in all directions starting at this point.
     Opposite:Piece->Piece;                         % Give the opposite color of the current piece.


var b,b':Board;
    r:Row;
    p,p':Piece;
    x,y:Nat;
    c:Bool;
    z:Pos;
eqn Opposite(Red)=White;
    Opposite(White)=Red;
    Opposite(None)=None;

    y==1 -> At(x,y,r|>b)=At(x,r);
    1<y && y<=M -> At(x,y,r|>b)=At(x,Int2Nat(y-1),b);
    y==0 || y>M || x==0 || x>N -> At(x,y,b)=None;
    At(x,y,if(c,b,b'))=if(c,At(x,y,b),At(x,y,b'));  % This rewrite rule is instrumental to let lpsconstelm reduce the system substantially,
                                                    % after applying lpsparunfold.
    x==1 -> At(x,p|>r)=p;
    1<x && x<=N -> At(x,p|>r)=At(Int2Nat(x-1),r);
    x==0 || x>N -> At(x,p|>r)=None;

    At(x,Put(p,z,r))=if(x==z,p,At(x,r));

var b,b':Board;
    r:Row;
    p,p':Piece;
    x,y:Pos;
    dx,dy:Int;
    c,othercolorseen:Bool;
eqn y==1 -> Put(p,x,y,r|>b)=Put(p,x,r)|>b;
    y>1 && y<=M -> Put(p,x,y,r|>b)=r|>Put(p,x,Int2Pos(y-1),b);
    Put(p,x,y,if(c,b,b'))=if(c,Put(p,x,y,b),Put(p,x,y,b'));  % See comments for distribution of At over if.
    x==1 -> Put(p,x,p'|>r)=p|>r;
    x>1 && x<=N -> Put(p,x,p'|>r)=p'|>Put(p,Int2Pos(x-1),r);

    Count(p,b)=Count(p,1,1,b);

    x==N && y==M ->
      Count(p,x,y,b)=if(At(x,y,b)==p,1,0);

    x==N && y<M ->
         Count(p,x,y,b)=if(At(x,y,b)==p,1,0)+Count(p,1,y+1,b);

    x<N -> Count(p,x,y,b)=if(At(x,y,b)==p,1,0)+Count(p,x+1,y,b);

    Enclosing(p,x,y,b)=
       Search(p,x,y,1,0,false,b)||
       Search(p,x,y,1,-1,false,b)||
       Search(p,x,y,0,-1,false,b)||
       Search(p,x,y,-1,-1,false,b)||
       Search(p,x,y,-1,0,false,b)||
       Search(p,x,y,-1,1,false,b)||
       Search(p,x,y,0,1,false,b)||
       Search(p,x,y,1,1,false,b);

    0<x+dx && x+dx<=N && 0<y+dy && y+dy<=M ->
       Search(p,x,y,dx,dy,othercolorseen,b)=
         if(At(Int2Nat(x+dx),Int2Nat(y+dy),b)==None,false,
            if(At(Int2Nat(x+dx),Int2Nat(y+dy),b)==p,othercolorseen,
                       Search(p,Int2Pos(x+dx),Int2Pos(y+dy),dx,dy,true,b)));

    !(0<x+dx && x+dx<=N && 0<y+dy && y+dy<=M) ->
        Search(p,x,y,dx,dy,othercolorseen,b)=false;

    Swap(p,x,y,dx,dy,b)=if(Search(p,x,y,dx,dy,false,b),Swap1(p,x,y,dx,dy,b),b);

    0<x+dx && x+dx<=N && 0<y+dy && y+dy<=M ->
      Swap1(p,x,y,dx,dy,b)=
        if(At(Int2Nat(x+dx),Int2Nat(y+dy),b)==Opposite(p), 
             Put(p,Int2Pos(x+dx),Int2Pos(y+dy),Swap1(p,Int2Pos(x+dx),Int2Pos(y+dy),dx,dy,b)),
             b);

    !(0<x+dx && x+dx<=N && 0<y+dy && y+dy<=M) ->
        Swap1(p,x,y,dx,dy,b)=b;

    #b!=0 -> 
     PutPiece(p,x,y,b)=                      % See for the condition remark below at CanMove.
       Put(p,x,y,
       Swap(p,x,y,1,0,
       Swap(p,x,y,1,-1,
       Swap(p,x,y,0,-1,
       Swap(p,x,y,-1,-1,
       Swap(p,x,y,-1,0,
       Swap(p,x,y,-1,1,
       Swap(p,x,y,0,1,
       Swap(p,x,y,1,1,b)))))))));


    #b!=0 -> CanMove(p,b)=CanMove(p,1,1,b);   % The condition is only required to prevent
                                              % rewriting when linearising. When premature
                                              % rewriting starts, terms become far too big
                                              % and termination appears endless.

    x==N && y==M ->
      CanMove(p,x,y,b)=At(x,y,b)==None && Enclosing(p,x,y,b);

    x==N && y<M ->
      CanMove(p,x,y,b)=
         (At(x,y,b)==None && Enclosing(p,x,y,b)) || CanMove(p,1,y+1,b);

    x<N ->
      CanMove(p,x,y,b)=
         (At(x,y,b)==None && Enclosing(p,x,y,b)) || CanMove(p,x+1,y,b);


act WhiteMove,RedMove:Pos#Pos;
    WhiteWins,RedWins,Draw;

proc Othello(b:Board,WhiteMoves,RedMoves:Bool)=
       sum x,y:Pos. (WhiteMoves &&
                     x<=N && y<=M &&
                     At(x,y,b)==None &&
                     Enclosing(White,x,y,b))->
           WhiteMove(x,y).
             Othello(PutPiece(White,x,y,b),
                     !CanMove(Red,b) && CanMove(White,b),
                     CanMove(Red,b))+
       sum x,y:Pos. (RedMoves &&
                     x<=N && y<=M &&
                     At(x,y,b)==None &&
                     Enclosing(Red,x,y,b))->
           RedMove(x,y).
             Othello(PutPiece(Red,x,y,b),
                     CanMove(White,PutPiece(Red,x,y,b)),
                     !CanMove(White,PutPiece(Red,x,y,b)) && CanMove(Red,PutPiece(Red,x,y,b)))+
       (!WhiteMoves && !RedMoves &&
                     Count(Red,b)>Count(White,b)) ->
           RedWins.Othello(b,false,false)+
       (!WhiteMoves && !RedMoves &&
                     Count(Red,b)<Count(White,b)) ->
           WhiteWins.Othello(b,false,false)+
       (!WhiteMoves && !RedMoves &&
                     Count(Red,b)==Count(White,b)) ->
           Draw.Othello(b,false,false)+
       delta;


init Othello([[None,None,None,None],
              [None,Red,White,None],
              [None,White,Red,None],
              [None,None,None,None]],false,true);
