// Date: 02-12-2004
// This document describes the output format of the GenSpect parser. Here:
// - <NumberString> represents a string of the format '"0"|("-"?[1-9][0-9]*)'
// - <String> represents an arbitrary string
// - the other alphabetical strings within angular brackets are non-terminals
//   that represent all possible branches of their productions
// - for non-terminal N, N*/N+ represents an ATermList with zero/one or more N's
// - each c(a_0, ..., a_n), where c is an alphabetical string, represents an
//   ATermAppl with c as its unquoted head and a_0, ..., a_n as its arguments

//General
//-------

//sort identifier
<SortId>     ::= SortId(<String>) 

//data identifier
<OpId>       ::= OpId(<String>, <SortExprOrUnknown>) 

//action identifier
<ActId>      ::= ActId(<String>, <SortExprOrUnknown>*) 

//process identifier
<ProcessId>  ::= ProcessId(<String>) 

//data variable
<DataVar>    ::= DataVar(<String>, <SortExprOrUnknown>) 

//sort expression or unknown
<SortExprOrUnknown> ::= <SortExpr> 
                      | Unknown()                       (removed in tc phase)

//string or nil
<StringOrNil>::= <String> | Nil() 

//number
<Number>     ::= Number(<NumberString>)                 (removed in dr phase)

//Specification
//-------------

//specification
<Spec>       ::= SpecV1(SortSpec(<SortDecl>*), ConsSpec(<OpDecl>*),
                   MapSpec(<OpDecl>*), EqnSpec(<EqnSect>*), ActSpec(<ActDecl>*),
                   ProcSpec(<ProcDecl>*), Init(<ProcExpr>)
                 )

//sort declaration
<SortDecl>   ::= SortDeclStandard(<String>) 
               | SortDeclRef(<String>, <SortExpr>)      (removed in ?? phase)

//operation declaration
<OpDecl>     ::= OpDecl(<String>, <SortExpr>)

//equation section
<EqnSect>    ::= EqnSect(<DataVarDecl>*, <EqnDecl>+) 

//data variable declaration
<DataVarDecl>::= DataVarDecl(<String>, <SortExpr>)

//equation declaration
<EqnDecl>    ::= EqnDecl(<DataExpr>, <DataExpr>) 

//action declaration
<ActDecl>    ::= ActDecl(<String>, <SortExpr>*) 

//process declaration
<ProcDecl>   ::= ProcDecl(<String>, <DataVarDecl>*, <ProcExpr>) 

//Expressions
//-----------

//sort expression
<SortExpr>   ::= <SortId>
               | SortBool() 
               | SortPos() 
               | SortNat() 
               | SortInt() 
               | SortList(<SortExpr>) 
               | SortSet(<SortExpr>) 
               | SortBag(<SortExpr>) 
               | SortArrow(<SortExpr>+, <SortExpr>) 
               | SortStruct(<StructCons>+)              (removed in ?? phase) 

//constructor declaration of a structured sort
<StructCons> ::= StructCons(<String>, <StructProj>*, <StringOrNil>)
                                                        (removed in ?? phase)

//projection declaration of a structured sort
<StructProj> ::= StructProj(<StringOrNil>, <SortExpr>+) (removed in ?? phase)

//data expression
<DataExpr>   ::= <DataVar>                              (created in tc phase)
               | <OpId>
               | DataAppl(<DataExpr>, <DataExpr>+) 
               | <Number>                               (removed in dr phase)
               | EmptyList()                            (removed in dr phase)
               | EmptySetBag()                          (removed in dr phase)
               | ListEnum(<DataExpr>+)                  (removed in dr phase)
               | SetEnum(<DataExpr>+)                   (removed in dr phase)
               | BagEnum(<BagEnumElt>+)                 (removed in dr phase)
               | SetBagComp(<DataVarDecl>, <DataExpr>)  (removed in dr phase)
               | Forall(<DataVarDecl>+, <DataExpr>)     (removed in dr phase)
               | Exists(<DataVarDecl>+, <DataExpr>)     (removed in dr phase)
               | Lambda(<DataVarDecl>+, <DataExpr>)     (removed in dr phase)
               | Whr(<DataExpr>, <WhrDecl>+)            (removed in ?? phase)

//bag enumeration element
<BagEnumElt> ::= BagEnumElt(<DataExpr>, <DataExpr>) 

//where clause declaration
<WhrDecl>    ::= WhrDecl(<DataVarDecl>, <DataExpr>) 

//process expression
<ProcExpr>   ::= ActProcRef(<String>, <DataExpr>*)      (removed in tc phase)
               | Act(<ActId>, <DataExpr>*)              (created in tc phase)
               | ProcRef(<ProcId>, <DataExpr>*)         (created in tc phase)
               | Delta()
               | Tau() 
               | Sum(<DataVarDecl>+, <ProcExpr>) 
               | Restrict(<MultActName>*, <ProcExpr>)
               | Allow(<MultActName>*, <ProcExpr>)
               | Hide(<MultActName>*, <ProcExpr>)
               | Ren(<RenExpr>*, <ProcExpr>)
               | Comm(<CommExpr>*, <ProcExpr>)
               | Sync(<ProcExpr>, <ProcExpr>)
               | AtTime(<ProcExpr>, <DataExpr>)
               | Seq(<ProcExpr>, <ProcExpr>)
               | Cond(<DataExpr>, <ProcExpr>, <ProcExpr>) 
               | BInit(<ProcExpr>, <ProcExpr>)
               | Merge(<ProcExpr>, <ProcExpr>)
               | LMerge(<ProcExpr>, <ProcExpr>)
               | Choice(<ProcExpr>, <ProcExpr>)

//multiaction identifier
<MultActName>::= MultActName(<String>+) 

//renaming expression
<RenExpr>    ::= RenExpr(<String>, <String>) 

//communication expression
<CommExpr>   ::= CommExpr(<MultActName>, <StringOrNil>) 
