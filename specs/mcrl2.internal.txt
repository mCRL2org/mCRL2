// Date: 12-06-2006
// This document describes the internal format of the mCRL2 language and the
// corresponding mu-calculus formulas. Here:
// - the following phases of implementation are distinguised:
//   tc : type checking
//   di : data implementation
//   lin: linearisation
//   fi : formula implementation
// - (+p)/(-p) at the end of a branch means that this branch is added/removed at
//   the end of phase p 
// - <String> is an arbitrary non-empty string excluding the keywords:
//     sort cons map var eqn act proc init
//     struct List Set Bag
//     lambda forall exists whr end
//     delta tau sum allow block hide rename comm
//     mu nu delay nil
//   Note that this is not as restrictive as user-defined identifiers, which
//   also excludes the following keywords:
//     Bool Pos Nat Int Real
//     true false div mod in 
// - <NumberString> is a string of the format '"0"|("-"?[1-9][0-9]*)'
// - <String> and <NumberString> are represented by a quoted ATermAppl constant
// - the other alphabetical strings within angular brackets are non-terminals
//   that represent all possible branches of their productions
// - for non-terminal N, N*/N+ represents an ATermList with zero/one or more N's
// - each c(a_0, ..., a_n), where c is an alphabetical string, represents an
//   ATermAppl with c as its unquoted head and a_0, ..., a_n as its arguments
// - a number of restrictions apply to the Assignment's, which we denote by A,
//   of an LPESummand:
//   + the lhs of an element of A should be declared by the LPE
//   + A may not contain duplicate lhs's
//   + the lhs's of A should obey the order in which they are declared 
// - the DataVarId's of the Assignment's of an LPEInit should be identical to the
//   DataVarId's of the corresponding LPE
// This description uses the theory of higher-order abstract data types, i.e.
// we have a higher-order signature Sigma = (B, O), where B is set of basic
// sorts and O is a set of operations. From the set B, we can generate the set
// of higher-order sorts as follows:
// - the set of basic sorts B is in B->;
// - for all s, s' in B->, (s -> s') is in B->.
// The set O is a B->-sorted set of operations, where each O_s contains
// constants of sort s, for all s in B->.
// The higher-order signature Sigma determines a first-order signature
// Sigma-> = (B->, O extended with Appl), where Appl is the set of operation
// applications.  This set contains the operation apply: (s -> s') # s -> s'
// for every s,s' in B->.
// Because we modelled the set Appl by the data expression DataAppl, the
// description of the data types below is essentially first-order. Also, we
// only use finite subsets of the infinite set of sorts B-> and the infinite
// set of operations O.


//Sort expressions
//----------------

//sort expression
<SortExpr>    ::= <SortId>
                | SortList(<SortExpr>)                                   (- di)
                | SortSet(<SortExpr>)                                    (- di)
                | SortBag(<SortExpr>)                                    (- di)
                | SortStruct(<StructCons>+)                              (- di)
                | SortArrowProd(<SortExpr>+, <SortExpr>)                 (- di)
                | SortArrow(<SortExpr>, <SortExpr>)                      (+ di)

//sort identifier
<SortId>       ::= SortId(<String>)

//constructor declaration of a structured sort
<StructCons>   ::= StructCons(<String>, <StructProj>*, <StringOrNil>)

//projection declaration of a structured sort
<StructProj>   ::= StructProj(<StringOrNil>, <SortExpr>)

//string or nil
<StringOrNil> ::= <String>
                | Nil

//sort expression or unknown
<SortExprOrUnknown>
               ::= <SortExpr> 
                 | Unknown                                               (- tc)


//Data expressions
//----------------

//data expression
<DataExpr>     ::= DataVarIdOpId(<String>)                               (- tc)
                 | <DataVarId>                                           (+ tc)
                 | <OpId>                                                (+ tc)
                 | DataApplProd(<DataExpr>, <DataExpr>+)                 (- di)
                 | DataAppl(<DataExpr>, <DataExpr>)                      (+ di)
                 | Number(<NumberString>, <SortExprOrUnknown>)           (- di)
                 | ListEnum(<DataExpr>+, <SortExprOrUnknown>)            (- di)
                 | SetEnum(<DataExpr>+, <SortExprOrUnknown>)             (- di)
                 | BagEnum(<BagEnumElt>+, <SortExprOrUnknown>)           (- di)
                 | SetBagComp(<DataVarId>, <DataExpr>)                   (- di)
                 | Forall(<DataVarId>+, <DataExpr>)                      (- di)
                 | Exists(<DataVarId>+, <DataExpr>)                      (- di)
                 | Lambda(<DataVarId>+, <DataExpr>)                      (- di)
                 | Whr(<DataExpr>, <WhrDecl>+)                           (- di)

//data variable identifier
<DataVarId>    ::= DataVarId(<String>, <SortExpr>)

//operation identifier
<OpId>         ::= OpId(<String>, <SortExpr>)

//bag enumeration element
<BagEnumElt>   ::= BagEnumElt(<DataExpr>, <DataExpr>)

//where clause declaration
<WhrDecl>      ::= WhrDecl(<String>, <DataExpr>)


//Process expressions
//-------------------

//process expression
<ProcExpr>     ::= ActionProcess(<String>, <DataExpr>*)                  (- tc)
                 | <Action>                                              (+ tc)
                 | Process(<ProcVarId>, <DataExpr>*)                     (+ tc)
                 | Delta
                 | Tau 
                 | Sum(<DataVarId>+, <ProcExpr>) 
                 | Block(<String>*, <ProcExpr>)
                 | Hide(<String>*, <ProcExpr>)
                 | Rename(<RenameExpr>*, <ProcExpr>)
                 | Comm(<CommExpr>*, <ProcExpr>)
                 | Allow(<MultActName>*, <ProcExpr>)
                 | Sync(<ProcExpr>, <ProcExpr>)
                 | AtTime(<ProcExpr>, <DataExpr>)
                 | Seq(<ProcExpr>, <ProcExpr>)
                 | Cond(<DataExpr>, <ProcExpr>, <ProcExpr>) 
                 | BInit(<ProcExpr>, <ProcExpr>)
                 | Merge(<ProcExpr>, <ProcExpr>)
                 | LMerge(<ProcExpr>, <ProcExpr>)
                 | Choice(<ProcExpr>, <ProcExpr>)

//Action
<Action>       ::= Action(<ActId>, <DataExpr>*)

//action identifier
<ActId>        ::= ActId(<String>, <SortExpr>*)

//process identifier
<ProcVarId>    ::= ProcVarId(<String>, <SortExpr>*)

//multiaction name
<MultActName>  ::= MultActName(<String>+) 

//renaming expression
<RenameExpr>   ::= RenameExpr(<String>, <String>) 

//communication expression
<CommExpr>     ::= CommExpr(<MultActName>, <StringOrNil>)


//mCRL2 specifications
//--------------------

//specification
<Spec>         ::= SpecV1(SortSpec(<SortDecl>*), ConsSpec(<OpId>*),
                     MapSpec(<OpId>*), DataEqnSpec(<DataEqn>*),
                     ActSpec(<ActId>*), <ProcEqnSpec>, <Init>)

//sort declaration
<SortDecl>     ::= <SortId>
                 | SortRef(<String>, <SortExpr>)                         (- di)

//data equation
<DataEqn>      ::= DataEqn(<DataVarId>*, <DataExprOrNil>,
                     <DataExpr>, <DataExpr>)

//data expression or nil
<DataExprOrNil>::= <DataExpr>
                 | Nil

//process equations or LPE
<ProcEqnSpec>  ::= ProcEqnSpec(<ProcEqn>*)                               (-lin)
                 | LPE(<DataVarId>*, <DataVarId>*, <LPESummand>*)        (+lin)

//process equation
<ProcEqn>      ::= ProcEqn(<DataVarId>*, <ProcVarId>, <DataVarId>*, <ProcExpr>)

//LPE summand
<LPESummand>   ::= LPESummand(<DataVarId>*, <DataExpr>, <MultActOrDelta>,
                    <DataExprOrNil>, <Assignment>*)

//multiaction or delta
<MultActOrDelta>
               ::= <MultAct>
                 | Delta

//multiaction
<MultAct>      ::= MultAct(<Action>*)

//assignment
<Assignment>   ::= Assignment(<DataVarId>, <DataExpr>)

//process expressions or data expression
<Init>         ::= Init(<DataVarId>*, <ProcExpr>)                        (-lin)
                 | LPEInit(<DataVarId>*, <Assignment>*)                  (+lin)


//Mu-calculus formulas
//--------------------

//state formula
<StateFrm>     ::= <DataExpr>
                 | StateTrue
                 | StateFalse                                            (- fi)
                 | StateNot(<StateFrm>)
                 | StateAnd(<StateFrm>, <StateFrm>)
                 | StateOr(<StateFrm>, <StateFrm>)                       (- fi)
                 | StateImp(<StateFrm>, <StateFrm>)                      (- fi)
                 | StateForall(<DataVarId>+, <StateFrm>)
                 | StateExists(<DataVarId>+, <StateFrm>)                 (- fi)
                 | StateMust(<RegFrm>, <StateFrm>)
                 | StateMay(<RegFrm>, <StateFrm>)                        (- fi)
                 | StateDelay                                            (- fi)
                 | StateDelayTimed(<DataExpr>)
                 | StateVar(<String>, <DataExpr>*)
                 | StateNu(<String>, <DataVarIdInit>*, <StateFrm>)
                 | StateMu(<String>, <DataVarIdInit>*, <StateFrm>)       (- fi)

//data variable identifier and initialisation
<DataVarIdInit>::= DataVarIdInit(<String>, <SortExpr>, <DataExpr>)

//regular formula
<RegFrm>       ::= <ActFrm>
                 | RegNil                                                (- fi)
                 | RegSeq(<RegFrm>, <RegFrm>)                            (- fi)
                 | RegAlt(<RegFrm>, <RegFrm>)                            (- fi)
                 | RegTrans(<RegFrm>)                                    (- fi)
                 | RegTransOrNil(<RegFrm>)                               (- fi)

//action formula
<ActFrm>       ::= <MultAct>
                 | <DataExpr>
                 | ActTrue
                 | ActFalse                                              (- fi)
                 | ActNot(<ActFrm>)
                 | ActAnd(<ActFrm>, <ActFrm>)
                 | ActOr(<ActFrm>, <ActFrm>)                             (- fi)
                 | ActImp(<ActFrm>, <ActFrm>)                            (- fi)
                 | ActForall(<DataVarId>+, <ActFrm>)
                 | ActExists(<DataVarId>+, <ActFrm>)                     (- fi)
                 | ActAt(<ActFrm>, <DataExpr>)
