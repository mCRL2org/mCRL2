// Date: 09-02-2005
// This document describes the internal format of the GenSpect language. Here:
// - <String> is an arbitrary non-empty string
// - <NumberString> is a string of the format '"0"|("-"?[1-9][0-9]*)'
// - <String> and <NumberString> are represented by a quoted ATermAppl constant
// - the other alphabetical strings within angular brackets are non-terminals
//   that represent all possible branches of their productions
// - for non-terminal N, N*/N+ represents an ATermList with zero/one or more N's
// - each c(a_0, ..., a_n), where c is an alphabetical string, represents an
//   ATermAppl with c as its unquoted head and a_0, ..., a_n as its arguments

// This description uses the theory of higher-order abstract data types, i.e.
// we have a higher-order signature Sigma = (B, O), where B is set of basic
// sorts and O is a set of operations. From the set B, we can generate the set
// of higher-order sorts as follows:
// - the set of basic sorts B is in B->;
// - for all s_0, ..., s_n, s in B->, (s_0 # ... # s_n -> s) is in B->.
// The set O is a B->-sorted set of operations, where each O_s contains
// constants of sort s, for all s in B->.
// The higher-order signature Sigma determines a first-order signature
// Sigma-> = (B->, O extended with Appl), where Appl is the set of operation
// applications.  This set contains the operation apply: (w -> s) # w -> s for
// every w,s in B-> where w = s_0, ..., s_n.
// Because we modelled the set Appl by the data expression DataAppl, the
// description of the data types below is essentially first-order. Also, we
// only use finite subsets of the infinite set of sorts B-> and the infinite
// set of operations O.

//Specification
//-------------

//specification
<Spec>        ::= SpecV1(SortSpec(<SortDecl>*), ConsSpec(<OpId>*),
                    MapSpec(<OpId>*), DataEqnSpec(<DataEqn>*),
                    ActSpec(<ActId>*), ProcEqnSpec(<ProcEqn>*), Init(<ProcExpr>)
                  )

//sort declaration
<SortDecl>    ::= <SortId>
                | <SortRef>                                               (- di)

//sort identifier
<SortId>      ::= SortId(<String>)

//sort reference
<SortRef>     ::= SortRef(<String>, <SortExpr>)                           (- di)

//operation identifier
<OpId>        ::= OpId(<String>, <SortExpr>)

//data equation
<DataEqn>     ::= DataEqn(<DataVarId>*, <DataCond>, <DataExpr>, <DataExpr>)

//data variable identifier
<DataVarId>   ::= DataVarId(<String>, <SortExpr>)

//data condition
<DataCond>    ::= <DataExpr>
                | Nil

//action identifier
<ActId>       ::= ActId(<String>, <SortExpr>*)

//process equation
<ProcEqn>     ::= ProcEqn(<ProcVarId>, <DataVarId>*, <ProcExpr>)

//process identifier
<ProcVarId>   ::= ProcVarId(<String>, <SortExpr>*)

//Expressions
//-----------

//sort expression
<SortExpr>    ::= <SortId>
                | SortList(<SortExpr>)                                    (- di)
                | SortSet(<SortExpr>)                                     (- di)
                | SortBag(<SortExpr>)                                     (- di)
                | SortStruct(<StructCons>+)                               (- di)
                | SortArrowProd(<SortExpr>+, <SortExpr>)                  (- di)
                | SortArrow(<SortExpr>, <SortExpr>)                       (+ di)

//constructor declaration of a structured sort
<StructCons>  ::= StructCons(<String>, <StructProj>*, <StringOrNil>)      (- di)

//projection declaration of a structured sort
<StructProj>  ::= StructProj(<StringOrNil>, <SortExpr>+)                  (- di)

//string or nil
<StringOrNil> ::= <String>
                | Nil

//data expression
<DataExpr>    ::= DataVarIdOpId(<String>)                                 (- tc)
                | <DataVarId>                                             (+ tc)
                | <OpId>                                                  (+ tc)
                | DataApplProd(<DataExpr>, <DataExpr>+)                   (- di)
                | DataAppl(<DataExpr>, <DataExpr>)                        (+ di)
                | Number(<NumberString>, <SortExprOrUnknown>)             (- di)
                | ListEnum(<DataExpr>+, <SortExprOrUnknown>)              (- di)
                | SetEnum(<DataExpr>+, <SortExprOrUnknown>)               (- di)
                | BagEnum(<BagEnumElt>+, <SortExprOrUnknown>)             (- di)
                | SetBagComp(<DataVarId>, <DataExpr>)                     (- di)
                | Forall(<DataVarId>+, <DataExpr>)                        (- di)
                | Exists(<DataVarId>+, <DataExpr>)                        (- di)
                | Lambda(<DataVarId>+, <DataExpr>)                        (- di)
                | Whr(<DataExpr>, <WhrDecl>+)                             (- di)

//sort expression or unknown
<SortExprOrUnknown>
              ::= <SortExpr> 
                | Unknown                                                 (- tc)

//bag enumeration element
<BagEnumElt>  ::= BagEnumElt(<DataExpr>, <DataExpr>)                      (- di)

//where clause declaration
<WhrDecl>     ::= WhrDecl(<String>, <DataExpr>)                           (- di)

//process expression
<ProcExpr>    ::= ActionProcess(<String>, <DataExpr>*)                    (- tc)
                | Action(<ActId>, <DataExpr>*)                            (+ tc)
                | Process(<ProcVarId>, <DataExpr>*)                       (+ tc)
                | Delta
                | Tau 
                | Sum(<DataVarId>+, <ProcExpr>) 
                | Restrict(<String>*, <ProcExpr>)
                | Hide(<String>*, <ProcExpr>)
                | Rename(<RenameExpr>*, <ProcExpr>)
                | Comm(<CommExpr>*, <ProcExpr>)
                | Allow(<MultActName>*, <ProcExpr>)
                | Sync(<ProcExpr>, <ProcExpr>)
                | AtTime(<ProcExpr>, <DataExpr>)
                | Seq(<ProcExpr>, <ProcExpr>)
                | Cond(<DataExpr>, <ProcExpr>, <ProcExpr>) 
                | BInit(<ProcExpr>, <ProcExpr>)
                | Merge(<ProcExpr>, <ProcExpr>)
                | LMerge(<ProcExpr>, <ProcExpr>)
                | Choice(<ProcExpr>, <ProcExpr>)

//multiaction name
<MultActName> ::= MultActName(<String>+) 

//renaming expression
<RenameExpr>  ::= RenameExpr(<String>, <String>) 

//communication expression
<CommExpr>    ::= CommExpr(<MultActName>, <StringOrNil>)
