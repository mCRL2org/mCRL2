\index{}\documentclass[a4paper,10pt]{article}
\usepackage{textcomp,amsmath,amssymb,amsthm,stmaryrd}
\usepackage{geometry}
\usepackage{mymath,mythm}

\theoremstyle{plain}
\newtheorem{thmfs}{Theorem}[section]
\theoremstyle{definition}
\newtheorem{tcase}[thmfs]{Test case}

\newcommand{\lpe}{linear process equation}
\newcommand{\tool}{\textit{lpeconstelm}}
\newcommand{\ovr}{\overrightarrow}
\newcommand{\mcrl}{mCRL2}
\newcommand{\framework}{\textit{LPE framework} \cite{LPEframework}}
\newcommand{\pp}{process parameter}
\newcommand{\pps}{process parameters}
\newcommand{\ti}{\textit}
\newcommand{\tb}{\textbf}
\newcommand{\sv}{\textit{state vector}}
\newcommand{\fv}{\textit{flag vector}}
\newcommand{\svs}{\textit{new state vector set}}
\newcommand{\nfv}{\textit{new flag vector}}
\newcommand{\la}{$\leftarrow$}
\newcommand{\ra}{$\rightarrow$}
\newcommand{\sq}{$\square$}
\newcommand{\ifs}{\ti{influence set}}

\newcommand{\Sig}{\nm{Sig}}
\newcommand{\Sort}{\nm{Sort}}
\newcommand{\Fun}{\nm{Fun}}
\newcommand{\ap}{{:}}

\newcommand{\tab}{\hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm}  \= \hspace*{5.mm}  \= \hspace*{5.mm}  \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm}  \= \hspace*{5.mm}  \= \hspace*{5.mm}\kill}

\font \aap cmmi10        
\newcommand{\at}[1]{\mbox{\aap ,} #1}

\newcommand{\csvs}{new\_state\_vector\_set}
\newcommand{\cfvs}{new\_flag\_vector\_set}


%opening
\title{lpeconstelm \\ DRAFT}
\author{F.P.M. Stappers}

\begin{document}

\maketitle

\begin{abstract}
This documentation describes the usage and implementation of the tool \tool\ within the \mcrl\ toolset.
Basically, \tool\ is a tool which eliminates constant parameters in a \lpe\ (LPE).
\end{abstract}

\tableofcontents

\section{Introduction}
This \tool\ tool is a tool for the \mcrl\ studio. The tool is a
filter which reads from a \ti{input.lpe}. The file \ti{input.lpe} is
a file in \ti{.lpe} format \cite{LPEformat}. We make use of the
\framework\ to read the \ti{input.lpe}. For
each constant \pp\ The filter substitutes its constant value and removes the \pp\ from the
\lpe . After the algorithm (Section \ref{sec:alg}) terminates, \tool\
will write the output to an output file \ti{output.lpe} in the \ti{.lpe} format \cite{LPEformat}.

\section{Definitions} \label{sec:def}

The equation below is a \lpe\ in \mcrl : 
\begin{defn}\lpe\ (LPE) \newline
%\at werkt niet
\begin{tabbing}
\tab
$X (\ovr{d: D}) = $ \> \> \> $ \sum_{i \in I} \sum_{\ovr{e_i: E_i}} \ovr{c_i} ( \ovr{d, e_i }) \rightarrow 
(a_i^1 (\ovr{f_{i,1}}(\ovr{d,e_i})) \vert \ldots \vert a_i^{n(i)}(\ovr{f_{i,n(i)}}(\ovr{d,e_i}))) \at \text{ } t_i(\ovr{d,e_i})  \cdot X(\ovr{g_i}(\ovr{d,e_i})) +$ \\ \\
\> \> \> $ \sum_{j \in j} \sum_{\ovr{e_j: E_j}} \ovr{c_j} ( \ovr{d, e_j} ) \rightarrow 
(a_j^1 (\ovr{f_{j,1}}(\ovr{d,e_j})) \vert \ldots \vert a_j^{n(j)}(\ovr{f_{j,n(j)}}(\ovr{d,e_j}))) \at \text{ } t_j(\ovr{d,e_j}) + $ \\ \\
\> \> \> $\sum_{\ovr{e_\delta}:\ovr{E_\delta}} \ovr{c_\delta} ( \ovr{d, e_\delta}) \rightarrow 
\delta \at \text{ } t_\delta(\ovr{d,e_\delta})$ 
\end{tabbing}

Where $I$ and $J$ are disjoint.\\
\end{defn}

\noindent For the description of the \tool\ tool we only use those elements of an LPE which are relevant. So we use a simplified\footnote{Multiactions and time are not taken into account} representation of an LPE .
\begin{defn}[Simplyfied LPE]\label{def:LPE}
\begin{displaymath}
X (\ovr{d:D}) = \sum_{i \in I} \sum_{\ovr{e_i:E_i}} \ovr{c_i} ( \ovr{d, e_i}) \rightarrow X(\ovr{g_i}(\ovr{d,e_i}))
\end{displaymath}\\
If we speak about an LPE in this article we refer to Definition \ref{def:LPE}.  The different states 
%are $\ovr{d}$ 
of the process are represented by the data vector parameter $\ovr{d: D}$. $\ovr{D}$ may be a Cartesian product of $n$ data types, meaning that $\ovr{d}$ may consist of a tuple $(d_1, \ldots, d_n)$. 
Let $x \in \lbrace 1, \ldots , \vert \ovr{d} \vert$; The $x^{th}$ element in the tuple is notated: $\ovr{d}._x$.
The LPE expresses that in state $\ovr{d}$ %it preforms action $a$, carrying data parameter $\ovr{f_i}(\ovr{d},e_i)$ and 
it can reach the new state $\ovr{g_i}(\ovr{d,e_i})$ under the condition that $\ovr{c_i}(\ovr{d,e_i})$ is \ti{true}. So for each summand $i$ from $I$ we have a function $\ovr{g_i}: \ovr{D} \times \ovr{E_i} \rightarrow \ovr{D}$ and a function $\ovr{c_i}: \ovr{D} \times \ovr{E_i} \rightarrow \mathbb{B}$
Data parameters $\ovr{e_i : E_i}$ are sum variables. These variables are used to let a action range over a data domain. 
If we want to speak about a certain LPE we can instantiate such an LPE with $X(\ovr{init})$. \\

\noindent For an more detailed explanation of \lpe s  we refer to \cite{LPE_info}.
\end{defn}

\section{Free Variables}
\subsection{Explanation}

If in a parameter in a certain state, does not influence the bahavior of an LPE we can assign to this parameter a \ti{free variable} at this state. With these \ti{free variables} we are able to model that \pp\ can have values, which will not influence the behavior of an LPE. %Note: Free variables are not sum variables.\ti{Free variables} are introduced when a \mcrl\ specification is linearized \cite{lin}.

\subsection{Assumptions}
If \ti{free variables} occur in an LPE we make certain assumptions about these variables, otherwise \ti{free variables} would be to complicated. The first assumption is that the value of these variables will not influence the behavior of the LPE. Another assumption is that \ti{free variables} only occur once in an LPE. Therefore each \ti{free variable} is unique. %If a \ti{free variable} would occur more than once a rightside expression, this could lead to unpredictable behavior. That is why we assume that each \ti{free variable} is unique.

%If a \ti{free variables} occurs in a conditions and, we know that the \ti{free variable} will not change the behavior of the LPE. The condition does not depend on the \ti{free variable}, so we may weaken the conjunct in which \ti{free variable} occurs.

 
For further reading about \lpe\ and free variables please refer to \cite{LPEfreevar} 

\section{lpeconstelm definition}
\subsection{lpeconstelm definition - without free variables}\label{subsec:lpedef}

In this definition we do not consider free variables.
A parameter of an LPE can be replaced by its initial value if it can be determined that this parameter remains constant throughout any run of the process, starting at the initial state. The elimination of constant parameters does not reduce the resulting state space, it may however reduce the time and space needed to generate a state space from an LPE. \\
If we have infinite time and space we can inspect each state and check whether a \pp\ changes throughout the execution of the process. For this we define the reachable state set $R$ for each state ($\ovr{v_0}$). 

\begin{defn}\label{def:lpe} Let $L$ be an LPE, where: \\ 
\begin{itemize}
\item $I$ is the set of summand indices, \\ $\ovr{E_i}$ is the set of sum variables of summand $i$, \\ $\ovr{c_i}$ is the condition function of summand $i$ and \\ $\ovr{g_i}$ is the next state function of summand $i$.
\end{itemize}

$R_L(\ovr{v_0})$ is the smallest for which the following holds:
  \begin{itemize}
    \item[-] $\ovr{v_0} \in R_L(\ovr{v_0})$
    \item[-] For all $i \in I$ and $\ovr{e_i} \in \ovr{E_i}$, if $\ovr{v} \in R_L(\ovr{v_0})$ and $\ovr{c_i}(\ovr{v, e_i})$ holds, \\ then $\ovr{g_i}(\ovr{v, e_i}) \in R_L(\ovr{v_0})$ \\
   \end{itemize}
\end{defn}

\begin{defn}\label{def:lpe_comp} We define $S_L(\ovr{v_0})$ to be the set of indices of \pps\ for LPE L which are constant. That is:\\

$S_L(\ovr{v_0}) = \lbrace j \in  \lbrace 1, \ldots, n \rbrace \vert (\forall_{\ovr{v} \in R_L(\ovr{v_0})}( \ovr{v}._j = \ovr{v_{0}}._j)) \rbrace $
\end{defn}

To get $S_L(\ovr{v_0})$ we have to compute $R_L(\ovr{v_0})$. This means we have to generate the entire state space starting from state $\ovr{init}$. Generating the entire state space can take a lot of time and space; it might take infinite time and/or space. However if we can make an approximation of Definition \ref{def:lpe_comp} we do not necessarily have to inspect all states. Note that if we use an approximation there are cases in which not all constant parameters can be found. In practice we don't mind, because these are hard to find.

Because variables can occur in many foms we introduce a form which allows us to take the normal form of such a data term. 

\subsection{lpeconstelm definition - with free variables}

A \pp\ of an LPE can be replaced by its constant value if it can be determined that this parameter remains constant throughout any run of the process, starting at the initial state. However if a \pp\ is initially a free variable and the \pp\ remains constant, the last assigned value (either a specific or a \ti{free variable} value) is used.\\

We define the reachable state set $R^{FV}$ for each state ($\ovr{v_0}$). 
\begin{defn}\label{def:lpe} Let $L$ be an LPE, where\begin{itemize}
\item $I$ is the set of summand indices, \\ $\ovr{E_i}$ is the set of sum variables of summand $i$, \\ $\ovr{c_i}$ is the condition function of summand $i$ and \\ $\ovr{g_i}$ is the next state function of summand $i$. \\
$FV$ is the set of \ti{free variables}.\\
\end{itemize}

$R_L^{FV}(\ovr{v_0})$ is the smallest set which is defined as:
  \begin{itemize}
    \item[-] $\ovr{v_0} \in R_L^{FV}(\ovr{v_0})$
    \item[-] For all $i \in I$ and $\ovr{e_i} \in \ovr{E_i}$, if $\ovr{v} \in R_L^{FV}(\ovr{v_0})$ and $\ovr{c_i}(\ovr{v, e_i})$ holds, \\ then $\ovr{g_i}(\ovr{v, e_i}) \in R_L^{FV}(\ovr{v_0})$ \\
   \end{itemize}
\end{defn}

\begin{defn}\label{def:lpe_comp_fv} We define $S_L^{FV}(\ovr{v_0})$ to be the set of indices of \pps\ which are constant. That is:\\

$S_L^{NF}(\ovr{v_0}) = \lbrace j \in  \lbrace 1, \ldots, n \rbrace \vert \forall_{\ovr{v}, \ovr{w} \in R_L^{FV}(\ovr{v_0})}( \ovr{v}._j \not\in FV \wedge \ovr{w}._j \not\in FV \rightarrow ( \ovr{v}._j = \ovr{w}._j)))
\rbrace $
\end{defn}

To get $S_L^{NF} (\ovr{v_0})$ we have to compute $R_L^{FV}(\ovr{v_0})$, and this means we have to generate the entire state space starting from state $\ovr{init}$. However we interested in an approximation. We take proposal 3 (Section \ref{def:sug3}) as a starting point for constructing Proposal 4 (Section \ref{def:sug4}).

%\subsection{lpeconstelm no singleton removal}
%Each \pp\ used within an LPE is specified on a domain. The size of such a domain can range from very small (empty domains) to very large (infinite domains). By counting the number of constructors we can determine if a sort belongs to a singleton domain or domain which does not exists out of only one element. Note that we don't have empty domains. If we use the \tool\ filter and we have a domain which consist out of only one element, this domain will be removed from the LPE. If you don't want to remove singleton domains an additional check can be preformed, which prohibits the \tool\ filter to remove these \pps .

%\begin{defn}
%Let $\Sig$ be a signature. We call a {\tt Name} $T$ a {\it constructor sort}
%iff $T\in\Sig.\Sort$ and there exists {\tt Name}s $T_1,\ldots, T_k, f$ ($k\geq 0$)
%such that $f\ap T_1\times \cdots\times T_k\rightarrow T\in \Sig.\Fun$.
%\end{defn}

%To detect if $T$ is a singleton, it has to full fill the following criteria:
%\begin{itemize}
%\item $T$ has only one constructor sort. \\
%\item $\forall_{i: 1 \leq i \leq n}(T_{i} = \text{singleton}) $.
%\end{itemize}

\section{Proposals}
\subsection{Proposal 1 - without free variables} \label{sec:prop1}
%Sum variables ($e_i$) can range over an infinite domain so we don't want to fill in all these specific values. These sum variables can range over an infinite domain. We know at forehand that they are not constant, therefore we notate these sum variables as the open data variables $e'$.
We write $NF(t)$ for the normal form of data term $t$. 
We notate sum variables as open data variables $\ovr{e'}$, because these values can range over an infinite domain.
Let $j \in \lbrace 1, \ldots,  n \rbrace $. We assume $\ovr{d}._j$ is a normal form. If $\ovr{d}._j$ is equal to $NF(\ovr{g_i}(\ovr{d,e'})._j)$ for all $i \in I$ we know that $\ovr{d}._j$ is constant. However some conditions $NF(\ovr{c_i}(\ovr{d,e'}))$  might never be \ti{true}, so it useless to compare $NF(\ovr{d}._j)$ with $NF(\ovr{g_i}(\ovr{d,e'})._j)$  if $NF(\ovr{c_i}(\ovr{d,e'}))$ is not  $"true"$. \\

\begin{defn} \label{def:sug1} Let $L$ be an LPE and we define $S_L^1$:
\begin{displaymath}
S_L^1 =
\lbrace   
j \in \lbrace 1, \ldots , n \rbrace \vert \forall_{i\in I} (\forall_{\ovr{d}: \ovr{D}}((NF(\ovr{c_i}(\ovr{d,e'})) = "true")  \Rightarrow (NF(\ovr{d}._j) = NF(\ovr{g_i}(\ovr{d,e'})._j))))\rbrace
\end{displaymath}
If we take a look at Example \ref{cexample:sug1}, it might be possible to improve our proposal to detect more constant \pps .
\begin{example}Let $CE1$ be \label{cexample:sug1}\begin{verbatim}

proc P(x : Nat) = true -> P(x := 2 * x);
init P(x : = 0);

\end{verbatim}
\end{example}
\begin{flushleft}
If we use Definition \ref{def:sug1}, we get:\\
\end{flushleft}
\begin{tabbing}
\tab
\> \> $S_{CE1}^1$\\
\> $\equiv$\\
\> \> $\lbrace j \in \lbrace 1 \rbrace \vert \forall_{x : \mathbb{N}}( x = 2 \ast x ) \rbrace $\\
\> $\equiv$ \\
\> \> $\lbrace j \in \lbrace 1 \rbrace \vert false \rbrace $\\
\> $\equiv$ \\
\> \> $\emptyset$ \\
\end{tabbing}
In Definition \ref{def:sug1} it has to hold for every $\ovr{d}$, however
we don't want to inspect all possible $\ovr{d}$'s. We want to inspect it for a specific LPE; specified by $X(\ovr{init})$.
\end{defn}

\subsection{Proposal 2 - without free variables}
In Section \ref{sec:prop1} we see that Definition \ref{def:sug1} can be improved, if can give a specific $\ovr{d}$. So we try to improve that approximation, by giving $\ovr{d}$ a specific value in $S_L^2$. So we define: 

\begin{defn} Let $L$ be an LPE\label{def:sug2} 
\begin{displaymath}
S_L^2(\ovr{d})=
\lbrace   
j \in \lbrace 1, \ldots , n \rbrace \vert \forall_{i\in I} (NF(\ovr{c_i}(\ovr{d,e'})) = "true") \Rightarrow \ovr{d}._j = NF(\ovr{g_i}(\ovr{d,e'})._j)))\rbrace
\end{displaymath}
%We elimate the problem for checking each state 
We now can "instantiate" the $S^2$ with a $\ovr{d}$. If we instantiate $S^2$ with $\ovr{init}$, there is a problem. If we take a look at Example \ref{cexample:sug2} we can see why:
\begin{example} [Let $E2$ be]\label{cexample:sug2}\begin{verbatim} 
 
proc P(x,y: Nat) = (x=0) -> P(x:= 1, y:= 0) +
                   (x=1) -> P(x:= x, y:= 1);
init P(x := 0, y:= 0);

\end{verbatim}
\end{example}
If we use Defintion \ref{def:sug2}, we get:
\begin{tabbing}
\hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm}  \= \hspace*{5.mm}  \= \hspace*{5.mm}  \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm}\kill
\> \> $S_{E2}^2(\langle 0, 0 \rangle)$\\
\> $\equiv$\\
\> \> $\lbrace j \in \lbrace 1, 2 \rbrace \vert \forall_{i\in I} (NF(\ovr{c_i}( \langle  0,  0\rangle ) = "true") \Rightarrow  \langle  0,  0\rangle._j = NF(\ovr{g_i}( \langle  0,  0\rangle)._j))\rbrace $\\\
\> $\equiv$ \\
\> \>$\lbrace j \in \lbrace 1, 2 \rbrace \vert $ \\
\> \> \> $(NF(\ovr{c_1}( \langle  0,  0\rangle ) = "true") \Rightarrow  \langle  0,  0\rangle._j = NF(\ovr{g_{1}}( \langle  0,  0\rangle)._j)) $\\
\> \> \> $\wedge$ \\
\> \> \> $ (NF(\ovr{c_2}( \langle  0,  0\rangle ) = "true") \Rightarrow  \langle  0,  0\rangle._j = NF(\ovr{g_{2}}( \langle  0,  0\rangle)._j)) $ \\
\> \>$
\rbrace $\\
\> $\equiv$ \\
\> \> $\lbrace j \in \lbrace 1, 2 \rbrace \vert $\\
\> \> \> $("true" \Rightarrow  \langle  0,  0\rangle._j = NF(\ovr{g_{1}}( \langle  0,  0\rangle)._j))$ \\
\> \> \> $\wedge$ \\
\> \> \> $("false" \Rightarrow  \langle  0,  0\rangle._j = NF(\ovr{g_{2}}( \langle  0,  0\rangle)._j))$ \\
\> \> $\rbrace $\\
\> $\equiv$ \\
\> \> $\lbrace j \in \lbrace 1, 2 \rbrace \vert 
\langle  0,  0\rangle._j = NF(\ovr{g_1}( \langle  0,  0\rangle)._j)
\rbrace $\\
\> $\equiv$\\
\> \> $\lbrace j \in \lbrace 1 \rbrace \vert (( 0)  = ( 1)) \rbrace $\\
\> \> $\cup$ \\
\> \> $\lbrace j \in \lbrace 2 \rbrace \vert (( 0)  = ( 0)) \rbrace $\\
\> $\equiv $ \\
\> \> $\lbrace 2 \rbrace$ \\
\end{tabbing}

$S_{E2}^2(\langle 0,0 \rangle) = \lbrace 2 \rbrace$. This indicates that the second \pp\ is constant. However if we take another step from the initial state, we see the the that the second \pp\ is not constant. We only inspect those states which are adjacent to the initial state, which can result in a wrong solution.
\end{defn}

\subsection{Proposal 3 - without free variables}
To overcome the problem in which only the states adjecent to the initial state are compared, we suggest this proposal. First we redefine when a summands should inspected. If we rewrite a condition which is an open term, it might be that this condition will not reduce to a normal form that is either \ti{true} or \ti{false}. In such a case we do not know for certain if the condition holds or not. If this happens we know the condition might be \ti{true} and the corresponding summand next state should be inspected. The summands for which the conditions are \ti{false} are not inspected. \\

We are interested in the largest subset of constant \pps\ so:

Let $X \subseteq \lbrace 1, \ldots, n \rbrace$ be a set of indices of constant \pps\ of an LPE:

\begin{defn} We define $\ovr{\otimes_X}(\ovr{z})$:\\
Let $j \in \lbrace 1, \dots, n \rbrace $. 
If $j \not\in X$ then $\ovr{\otimes_X}._j = \ovr{z}._j$. 
If $j \in X$ then $ovr{\otimes_X}._j = \ovr{init}._j$.
\end{defn}

In order find the largest subset we give: % to the following definition: 

\begin{defn} \label{def:sug3} Let $L$ be an LPE. We define:%// $S_L^3$:

\begin{tabbing}
\tab
\> $ S_L^3(\ovr(init)) \subseteq \lbrace 1, \ldots, n \rbrace $ \\ \\
 \> as the biggest possible set such that:\\ \\
\> $\forall_{i \in I} (NF( \ovr{c_i} ( \ovr{\otimes_{S_L^3}, e'} ) ) \not= "false" \rightarrow \forall_{j \in S_L^3}(ovr{init}._j =  NF( \ovr{g_i}(\ovr{\otimes_{S_L^3}, e'} )._j))) $
\end{tabbing}
%If we compare Definition \ref{def:sug3} to Definition \ref{def:lpe_comp} we see the following:
\begin{thm} Let $L$ be an LPE. \label{thm:sub}
$$S_L^3(\ovr{init}) \subseteq S_L(\ovr{init}) $$
\end{thm} 
\begin{flushleft}
\tb{Proof. \ref{thm:sub}}
\end{flushleft}
We do case distinction on $S_L^3(\ovr{init})$:\\
\begin{itemize}
\item[-] Let $S_L^3(\ovr{init})$ be empty, then $S_L^3 \subseteq S_L$ holds trivially.
\item[-] Let $S_L^3(\ovr{init})$ not be empty. We prove that if there is an element in $S_L^3(\ovr{init})$, then this element is also in $S_L(\ovr{init})$.
\begin{defn} We define $\ovr{\odot_X}(d)$:\\
Let $j \in \lbrace 1, \dots, n \rbrace $. 
If $j \not\in X$ then $\odot_{X_j} = d$. 
If $j \in X$ then $\odot_{X_j} = init_j$.
\end{defn}
So $\otimes_X = \odot_X(d_j)$; next we prove:
\begin{tabbing}
\tab
\> \> $j \in S_L^3(\ovr{init})$\\
\> = \> \> \\
\> \> $j \in \lbrace k \vert \forall_{i \in I} NF(\ovr{c_i}( \ovr{\otimes_{S_L^3}}, e')) \neq false \rightarrow (init_k = NF(\ovr{g_i} (\ovr{\otimes_{S_L^3}}, e' )_k)  \rbrace$\\
\> $\Rightarrow$ \> \> \\
\> \> $j \in \lbrace k \vert \forall_{i \in I} (\forall_{e_i:E_i} (\ovr{c_i}( \ovr{\otimes_{S_L^3}}, e_i) \rightarrow (init_k = \ovr{g_i} (\ovr{\otimes_{S_L^3}}, e_i )_k))  \rbrace$\\
\> $\Rightarrow$ \> \> \\
\> \> $j \in \lbrace k \vert \forall_{i \in I} (\forall_{e_i:E_i} (\forall_{d\in D_k} (\ovr{c_i}( \ovr{\odot_{S_L^3}}(d), e_i) \rightarrow (init_k = \ovr{g_i} (\ovr{\odot_{S_L^3}}(d), e_i )_k))  \rbrace $ \\
%\> $=$ \> $\forall_{ i \in I }\forall_{ e_i \in E_i} ( \ovr{v} \in R_L(\ovr{v_0}) \wedge \ovr{c_i}(\ovr{v}, e_i) ) \rightarrow  \ovr{g_i}(\ovr{v}, e_i) \in R_L(\ovr{v_0})$ \\
\> $=$ \>  \>$ \forall_{i\in I}\forall_{e_i:E_i}\forall_{d:D} : (\odot_{S_L^3}(d),e_i) \in R_L(\ovr{init})) $ and 
$\ovr{c_i}(\odot_{S_L^3}(d),e_i)$ holds, \\
\> \> \> \> then $ \ovr{g_i}( \odot_{S_L^3}(d),e_i) \in R_L(\ovr{init})$ \\
%\> \> $j \in \lbrace k \vert \forall_{\ovr{v} \in \lbrace \ovr{init} \rbrace \cup \lbrace R_L(\ovr{init})\rbrace }(v_k = init_k) \rbrace$ \\
%\> \> \> \> if $(\odot_{S_L^3}}(d),e_i) \in R_L(\ovr{init})$ and $\ovr{c_i}(\odot_{S_L^3}}(d),e_i)$ holds, \\ \> \> \> \>then $\ovr{g_i}(\odot_{S_L^3}}(d),e_i) \in R_L(\ovr{init})$ \\
%\> $=$ \> \\
\> \> $j \in \lbrace k \vert \forall_{\ovr{v} \in R_L(\ovr{init})} (v_k = init_k)) \rbrace$\\
\> $=$ \> \>Definition \ref{def:lpe_comp}\\
\> \> $j \in S_L(\ovr{init})$
 \end{tabbing}
\end{itemize}
So we have derived that each element in $S_L^3(\ovr{init})$, is also in $S_L(\ovr{init})$.
\\ \sq
\end{defn}

\subsection{Proposal 4 - with free variables}

We are interested in the largest subset of constant \pps ; for each \pp\ it should hold that it should equal to all their next state \pps.

Let $X \subseteq \lbrace 1, \ldots, n \rbrace$ of constant \pps\ of an LPE:

\begin{defn} We define $\ovr{\oplus_X}(v)$:\\
Let $j \in \lbrace 1, \dots, n \rbrace $. 
If $j \not\in X$ then $\oplus_{X_j} = d_j$. 
If $j \in X$ then $\oplus_{X_j} = v$.
\end{defn}

\begin{defn} We define $Y(\ovr{m})$:
\begin{tabbing}
\tab
$\forall_{i \in I}($\\
\> $NF(c_i(\ovr{m})) \neq false \rightarrow$ \\
\> ( \> 		\> ( $NF(\ovr{g_i}(\ovr{m})_j) \not\in FV \wedge NF(m_j) \not\in FV \rightarrow (NF(m_j) = NF(\ovr{g_i}(\ovr{m})_j))$ )\\
\> \> $\vee$ 	\> ( $NF( m_j) \in FV $)\\
\> \> $\vee$ 	\>	( $NF(\ovr{g_i}(\ovr{m})_j) \in FV \wedge NF(m_j) \not\in FV \rightarrow Y(\ovr{g_i}(\ovr{m}))$ )\\
\> ) \\
$)$
\end{tabbing}
\end{defn}

\noindent In order find the largest subset we give: % to the following definition: 
\begin{defn} \label{def:sug4} Let $L$ be an LPE. We define $S_L^4$:
\begin{tabbing}
\tab
$ S_L^4 \subseteq \lbrace 1, \ldots, n \rbrace $ \\ \\
such that:\\ \\
$\exists_{z}( \forall_{j \in S_L^4} (Y((\ovr{\oplus_X}(z), e')))$ \\
\end{tabbing}
\end{defn}
If we compare Definition \ref{def:sug4} to Definition \ref{def:lpe_comp_fv} we see the following:
\begin{thm} Let $L$ be an LPE. \label{thm:sub_fv}
$$S_L^4(\ovr{init}) \subseteq S_L^{FV}(\ovr{init}) $$
\end{thm} 
\begin{flushleft}
\tb{Proof. \ref{thm:sub_fv}}
\end{flushleft}
We do case distinction on $S_L^4$
Let $S_L^4(\ovr{init})$ be $\emptyset$, then $S_L^4 \subseteq S_L^{FV}$ holds trivially.
Let $S_L^4(\ovr{init})$ not be $\emptyset$. We prove there is an element in $S_L^4(\ovr{init})$, which is also in $S_L^{FV}(\ovr{init})$.
\begin{tabbing}
$\vdots$ Bewijs
\end{tabbing}

So we have derived that each element in $S_L^4(\ovr{init})$, is also in $S_L^NF(\ovr{init})$.


\section{Algorithm description}
In this section we informally describe the algorithms for finding constant \pps\ in LPEs with and without \ti{free variables}. First a description is given about how to determine the constant \pps\ when an LPE does not contain any free variables. Next an informal description is given for finding constant \pps\ when an LPE contains free variables.

\subsection{without free variables}\label{alg:org}

First the \sv\ is constructed from the initial process of the \lpe. Next the set $S$ is defined, which$S$ contains the indices for all \pps that might be constant. If a \pp\ is detected to be variable, this \pp\ is removed from the set $S$.

We keep on removing elements from $S$ until no more elements can be removed. Removing the elements is done as follows:
First we fill in all values of the \pps , for which the index in $S$ into the conditions. Next all conditions are rewritten and checked for being \ti{false}.
%$For all conditions that are not false ee "evaluate" the condition after substituting the values of the \pp\ from the \sv\ in the condition and rewrite it. Only those \pp\ from the \sv\ are substituted for which the indices are in $S$. 

If the rewritten condition, in its normal form, is other then \ti{false} the condition might be \ti{true}, thus we calculate the nextstate of the current summand.  We compare each element from the \sv\ with the nextstate vector for which the indices are in $S$. If an element is not equal, the corresponding index is removed from the set $S$. The corresponding \pp\ in the \sv\ gets a special value, for indicating that the variable is not constant. Note: When comparing these special values with other variables, the result is always false. 

If no elements are removed from $S$ during the last iteration - either there are no more constant \pps\ or all \pps\ are constant - the algorithm ends. Next all constant \pps\ are substituted with their constant values and are removed from the LPE. 

\subsection{with free variables}
Before describing the algorithm informally we define some rules which should hold when we use \ti{free variables}. The set  $S$ is again the set of indices of constant \pps .

The values of \pps\ can either be given a specific value or a \ti{free variable}. In order to determine if a \pp\ is constant or variable we define rules.

\begin{enumerate}
\item The \pp\ has a specific value and a \ti{free variable} is assigned to this \pp :\\
If \ti{free variable} is assigned to a \pp\ with a specific value, the value of this \pp\ remains unchanged. If the index of \pp\ is in $S$, it will not be removed from $S$. If we would allow replacement of a specific value with a \ti{free variable}, this might lead to a fault result. Consider the next example; Let $x_1$ and $x_2$ be two specific values which are not equal to each other. Let $v_1$ be a \ti{free variable}. Let the index of \pp\ reside in $S$. This \pp\ has the value $x_1$ and is replaced with $v_1$, the index of \pp\ stays in $S$. If in a next state this \pp\ is substituted with $x_2$, the index remains in $S$. This indicates that the \pp\ would remain constant. Clearly this observation is wrong. So we prohibited assigning \ti{free variables} by specific values.

\item A \pp\ which is a \ti{free variable} is substituted with a specific value:\\
The \pp\ gets the value of which is substituted. By construction, the algorithm only allows specific values to be assigned to \ti{free variables} for which the \pp\ are constant. The \pp\ remains in $S$.

\item The \pp\ which is a \ti{free variable} is substituted with another \ti{free variable}:\\
The \pp\ will be substituted with the new \ti{free variable}. Again by construction, only free variables with corresponding constant \pps\ can be substituted with \ti{free variables}. So the \pp\ remains in $S$.

\item The \pp\ which is specific value is substituted with another specific value:\\
If the substituted value differs from the original value, the \pp\ becomes marked variable and is removed from the set $S$.
If they are equal, the \pp\ remains in the set $S$ if it already had been in the set $S$.
\end{enumerate}

In this part we only describe the difference between the algorithm without \ti{free variables}. The algorithm remains basicly the same. We only extend Algorithm Description \ref{alg:org} when comparing elements from the current state with the corresponding next state. When comparing we use the rules associated with \ti{free variables}.

%\subsection{no singleton removal}
%Here we describe how singleton domains are begin detected.


\newpage
\section{Algorithms}
\subsection{without free variables} \label{sec:alg}
\begin{tabbing} 
\hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm}  \= \hspace*{5.mm}  \= \hspace*{5.mm}  \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm}\kill
StateVector := $\ovr{init}$; \\
$S_b$ := $\lbrace 1, \ldots, n \rbrace$; \\
$S$ := $\emptyset$;\\ 
\tb{while}  ($ (S \setminus S_b) = \emptyset $) \tb{do} \ra \\
  \> $S$ := $S_b$; \\
  \> \tb{forall} $i \in I$ \tb{do} \ra \\
  \>	\>	\tb{if} \\
  \>	\>	\sq \> $(NF(c_i(\ovr{\otimes_S},e')) \not= false) \rightarrow$ \\
  \>	\>	\>  	\>  \tb{forall} $j \in S \tb{do} \rightarrow$ \\
  \>	\>	\>  	\>	\>  	    \tb{if} \\
  \>	\>	\>  	\>   	\>         $\square$  \> $(NF($init$_j) \neq NF(\ovr{g_i}(\ovr{\otimes_S}, e')_j)) \rightarrow$ \\
  \>	\>	\>  	\>    	\>       \>    \>       $S$ := $S\setminus \lbrace j \rbrace$;\\
  \> 	\>	\>	\>	\>	\>	\>	StateVector$_j$ := $NF(\ovr{g_i}(\ovr{\otimes_S}, e')_j)$\\
 \>	\>	\>  	\>    	\>        $\square$ \> $ (NF($init$_j) = NF(\ovr{g_i}(\ovr{\otimes_S}, e')_j)) \rightarrow$\\
  \>	\>	\> 	\>    	\>        \> \>  \tb{skip}\\	
  \>	\>	\> 	\> 	\>          \tb{fi}; \\
  \>	\>	\>	\> \tb{od}\\
  \>	\>	\sq 	\>  $(NF(c_i(\ovr{\otimes_S},e')) = false) \rightarrow$ \\
  \>	\>	\> 	\>\tb{skip};\\
  \>	\>	\tb{fi}\\
  \>	\tb{od} \\
 \tb{return} $S$
\end{tabbing} 


\newpage
\subsection{with free variables}
\begin{tabbing} 
\hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm}  \= \hspace*{5.mm}  \= \hspace*{5.mm}  \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm}\kill
StateVector := $\ovr{init}$; \\
$S_b$ := $\lbrace 1, \ldots, n \rbrace$; \\
$S$ := $\emptyset$;\\ 
\tb{while}  ($ (S \setminus S_b) = \emptyset $) \tb{do} \ra \\
  \> $S$ := $S_b$; \\
  \> \tb{forall} $i \in I$ \tb{do} \ra \\
  \>	\>	\tb{if} \\
  \>	\>	\sq \> $(NF(c_i(\ovr{\otimes_S},e')) \not= false) \rightarrow$ \\
  \>	\>	\>  	\>  \tb{forall} $j \in S \tb{do} \rightarrow$ \\
  \>	\>	\>  	\>	\>  	    \tb{if} \\
  \>	\>	\>  	\>   	\>         $\square$  \> $(NF($init$_j) \neq NF(\ovr{g_i}(\ovr{\otimes_S}, e')_j)) \rightarrow$ \\
  \>	\>	\>  	\>    	\>       \>    \>       $S$ := $S\setminus \lbrace j \rbrace$;\\
  \> 	\>	\>	\>	\>	\>	\>	StateVector$_j$ := $NF(\ovr{g_i}(\ovr{\otimes_S}, e')_j)$\\
 \>	\>	\>  	\>    	\>        $\square$ \> $ (NF($init$_j) = NF(\ovr{g_i}(\ovr{\otimes_S}, e')_j)) \rightarrow$\\
  \>	\>	\> 	\>    	\>        \> 	\>  	\tb{if}\\
  \>	\>	\>	\>	\>	  \>	\>	\sq 	\> $NF($init$_j) \in FreeVar \wedge NF(\ovr{g_i}(\ovr{\otimes_S}, e')_j) \in FreeVar$ \ra \\
  \>	\>	\>	\>	\>	  \>	\>		\>	\>	init$_j$ := $NF(\ovr{g_i}(\ovr{\otimes_S}, e')_j)$\\ 

  \>	\>	\>	\>	\>	  \>	\>	\sq 	\> $NF($init$_j) \in FreeVar \wedge NF(\ovr{g_i}(\ovr{\otimes_S}, e')_j) \not\in FreeVar$ \ra \\
  \>	\>	\>	\>	\>	  \>	\>		\>	\>	init$_j := NF(\ovr{g_i}(\ovr{\otimes_S}, e')_j)$\\ 

  \>	\>	\>	\>	\>	  \>	\>	\sq 	\> $NF($init$_j) \not\in FreeVar \wedge NF(\ovr{g_i}(\ovr{\otimes_S}, e')_j) \in FreeVar$ \ra \\
  \>	\>	\>	\>	\>	  \>	\>		\>	\>	\tb{skip};\\ 

  \>	\>	\>	\>	\>	  \>	\>	\sq 	\> $NF($init$_j) \not\in FreeVar \wedge NF(\ovr{g_i}(\ovr{\otimes_S}, e')_j) \not\in FreeVar$ \ra \\
  \>	\>	\>	\>	\>	  \>	\>		\>	\>	\tb{skip};\\ 

 \>	\>	\>	\>	\>	\>	\>	\tb{fi}	\\
  \>	\>	\> 	\> 	\>          \tb{fi}; \\
  \>	\>	\>	\> \tb{od}\\
  \>	\>	\sq 	\>  $(NF(c_i(\ovr{\otimes_S},e')) = false) \rightarrow$ \\
  \>	\>	\> 	\>\tb{skip};\\
  \>	\>	\tb{fi}\\
  \>	\tb{od} \\
 \tb{return} $S$
\end{tabbing} 
\newpage

\section{Test Cases}
All specifications are given in \mcrl\ specification.
\verb"x_1", $\ldots$ , \verb"x_n" the set of process parameters.
Let \verb"action_1", $\ldots$, \verb "action_n" the set of actions.
Let $S$ be the set of indices for which the \pps\ are constant. 

\subsection{Function tests}

\subsection{Application tests}

\subsubsection{Simple without free variables}
\begin{itemize}

\item inputfile: \verb"test_swofv1.mcrl" 
\begin{tcase}
For any given \verb"x" in:
\begin{verbatim}
P(x_1 : Nat) = true -> action_1 . P(x_1 := x_1);
\end{verbatim}
The testcase should give:
$$ S = \lbrace 1 \rbrace $$
\end{tcase}

\item inputfile: \verb"test_swofv2.mcrl" 
\begin{tcase} 
For any given \verb"x_1" in:
\begin{verbatim}
P(x_1 : Nat) = true -> action_1 . P(x_1 := x_1 + 1);
\end{verbatim}
The testcase should give:
$$ S = \emptyset $$
\end{tcase}

\item inputfile: \verb"test_swofv3.mcrl" 
\begin{tcase}
For any given \verb"x_1" in:
\begin{verbatim}
P(x_1, x_2 : Nat) = true -> action_1 . P(x_1 := x_1 + 1 , x_2 := x_1);
\end{verbatim}
The testcase should give:
$$ S = \emptyset $$
\end{tcase}

\item inputfile: \verb"test_swofv4.mcrl" 
\begin{tcase}
For any given \verb"x_1, x_2 : Nat" in:
\begin{verbatim}
P(x_1 : Nat) = false -> action_1 . P(x_1 := x_1);
\end{verbatim}
The testcase should give:
$$ S = \lbrace 1 \rbrace $$
\end{tcase}

\item inputfile: \verb"test_swofv5.mcrl" 
\begin{tcase}
For any given \verb"x_1, x_2 : Nat" in:
\begin{verbatim}
P(x_1 : Nat) = false -> action_1 . P(x_1 := x_1 + 1);
\end{verbatim}
The testcase should give:
$$ S = \lbrace 1 \rbrace  $$
\end{tcase}

\item inputfile: \verb"test_swofv6.mcrl" 
\begin{tcase}
For any given \verb"x_1" in:
\begin{verbatim}
P(x_1 : Nat) = false -> action_1 . P(x_1 := x_1) +
               true  -> action_2 . P(x_1 := x_1 + 1);
\end{verbatim}
The testcase should give:
$$ S = \emptyset $$
\end{tcase}

\item inputfile: \verb"test_swofv7.mcrl" 
\begin{tcase}
For any given \verb"x_1" in:
\begin{verbatim}
P(x_1 : Nat) = true  -> action_1 . P(x_1 := x_1) +
               false -> action_2 . P(x_1 := x_1 + 1);
\end{verbatim}
The testcase should give:
$$ S = \lbrace 1 \rbrace $$
\end{tcase}

\item inputfile: \verb"test_swofv8.mcrl" 
\begin{tcase}
For any given \verb"x_1" in:
\begin{verbatim}
P(x_1 : Nat)	= true -> action_1 . P(x_1 :=  2 * x_1) +
\end{verbatim}
The testcase should give:
\begin{displaymath}
    S = \left\{
        \begin{array}{l l}
            \verb"x_1" = 0                      & \lbrace 1 \rbrace \\
            \verb"x_1" \neq 0                   & \emptyset \\
        \end{array} \right.
\end{displaymath}
\end{tcase}

\item inputfile: \verb"test_swofv9.mcrl" 
\begin{tcase}
For any given \verb"x_1" in:
\begin{verbatim}
P(x_1 : Bool, x_2, x_3) = b      -> action_1 . P(x_1 := 2 * x_1) +
                          not(b) -> action_2 . P(x_1 :=  
\end{verbatim}
The testcase should give:
\begin{displaymath}
    S = \left\{
        \begin{array}{l l}
            \verb"x_1" = 0                      & \lbrace 1 \rbrace \\
            \verb"x_1" \neq 0                   & \emptyset \\
        \end{array} \right.
\end{displaymath}
\end{tcase}

\end{itemize}

\subsubsection{Simple with free variables}

\subsubsection{Complex without free variables}

\subsubsection{Complex with free variables}

\newpage
\begin{thebibliography}{99}  \bibitem{LPE_info} auteur\\
   \textit{article},
   Extra info.
  \bibitem{LPEframework} J.W. Wesselink,
   \textit{http://www.win.tue.nl/~wieger/mcrl2/html/index.html}\\
   A C++ wrapper for the ATerm library.
   \bibitem{LPEformat} Aad Mathijssen\\
   \textit{https://svn.win.tue.nl/viewcvs-checkout/MCRL2/trunk/specs/mcrl2.internal.txt},
   A description of the internal format of the mCRL2 language.
  \bibitem{LPEfreevar} auteur,
   \textit{article}
   Extra info.
  \bibitem{rewrite} M. v. Weerdenburg (e.a??),
   \textit{gsrewrite}
   Extra info.
  \bibitem{lin} J.F. Groote,
   \textit{linear}
   Extra info.

\end{thebibliography}

\newpage



\end{document}
