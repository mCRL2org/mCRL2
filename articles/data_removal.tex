\documentclass[a4paper,fleqn]{article}

% title and author
\title{The Data Removal Phase of the mCRL2 Parser}
\author{Aad Mathijssen} 

% packages
\usepackage[english]{babel}
\usepackage[final]{graphics}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{array}
\usepackage{calc}
\usepackage{xspace}

% General layout
% --------------

%add headings
\pagestyle{headings}

% increase pagewidth
\addtolength{\textwidth}{20mm}
\addtolength{\oddsidemargin}{-10mm}
\addtolength{\evensidemargin}{10mm}

% set the indentation of the math environment to 10mm
\setlength{\mathindent}{10mm}

% equations are unique up to their section
\renewcommand{\theequation}{\arabic{equation}}

% do not put subsubsections in the table of contents
\addtocounter{tocdepth}{-1}

% column types that change column types l,c,r from math mode to LR
% and the other way round
\newcolumntype{L}{>{$}l<{$}}%stopzone%stopzone%stopzone
\newcolumntype{C}{>{$}c<{$}}%stopzone%stopzone%stopzone
\newcolumntype{R}{>{$}r<{$}}%stopzone%stopzone%stopzone

% Environments
% ------------

% equations: eqnarray environment with no outer column spacing and tighter
% intercolumn spacing
\newenvironment{equations}
  {\setlength{\arraycolsep}{2pt}%
   \begin{array}{@{}lll@{}}%
  }
  {\end{array}%
  }

% tightarray: array with no outcolumn spacing and tighter intercolumn spacing
\newenvironment{tightarray}[1]
  {\setlength{\arraycolsep}{2pt}%
   \begin{array}{@{}#1@{}}%
  }
  {\end{array}%
  }

% definitions: list of definitions where:
% - the optional argument denotes the space between successive items
%   (default 0.15em)
% - items are horizontally aligned at the math indent
\newenvironment{definitions}[1][0.15em]
  {\begin{list}%
    {}%
    {\setlength{\parsep}{0pt}%
     \setlength{\itemsep}{#1}%
     \setlength{\leftmargin}{\mathindent}%
     \setlength{\labelwidth}{\mathindent - \labelsep}%
    }
  }
  {\end{list}}

% tdefinitions: list of tagged definitions where:
% - the optional argument denotes the space between successive items
%   (default 0.15em)
% - items are horizontally aligned at the math indent
% - each item is tagged with the mandatory argument
\newenvironment{tdefinitions}[2][0.15em]
  {\begin{list}%
    {#2}%
    {\setlength{\parsep}{0pt}%
     \setlength{\itemsep}{#1}%
     \setlength{\leftmargin}{\mathindent}%
     \setlength{\labelwidth}{\mathindent - \labelsep}%
    }
  }
  {\end{list}}

% edefinitions: list of enumerated definitions where:
% - the optional argument denotes the space between successive items
%   (default 0.15em);
% - items are horizontally aligned at the math indent;
% - each item is numbered with a parenthesized roman numeral.
\newcounter{edefinitioncount}
\newenvironment{edefinitions}[1][0.15em]
  {\begin{list}%
    {(\roman{edefinitioncount})}%
    {\renewcommand{\theenumi}{\roman{enumi}}%
     \renewcommand{\labelenumi}{(\theenumi)}%
     \usecounter{edefinitioncount}%
     \setlength{\parsep}{0pt}%
     \setlength{\itemsep}{#1}%
     \setlength{\leftmargin}{\mathindent}%
     \setlength{\labelwidth}{\mathindent - \labelsep}%
    }
  }
  {\end{list}}
  
% entry: list of entries where:
% - the optional argument denotes the space between successive items
%   (default 0.15em);
% - items are horizontally aligned at the math indent;
% - each item is labelled.
\newenvironment{entry}[2][0.15em]%
  {\begin{list}{}%
    {\renewcommand{\makelabel}[1]{\textsf{##1:}\hfil}%
     \settowidth{\labelwidth}{\textsf{#2:}}%
     \setlength{\leftmargin}{\labelwidth+\labelsep}%     
     \setlength{\parsep}{0pt}%
     \setlength{\itemsep}{#1}%
    }%
  }%
  {\end{list}}

% derivation: calculational derivation where expressions (\expr) are related by
% means of transformations (\tran). A transformation is denoted by a symbol and
% a hint. Expressions and transformations can be broken into several lines
% using \breakexpr and \breaktran.
\newenvironment{derivation}
{\par\addtolength{\baselineskip}{1mm}\begin{tabbing}\hspace{5mm}\=\hspace{5mm}\=\hspace{5mm}\=\kill}
{\end{tabbing}\par}
\newcommand{\expr}[1]{\>\>$#1$}
\newcommand{\tran}[2]{\\*\>$#1$\>\>\{ #2 \}\\}
\newcommand{\breakexpr}{$\\*\>\>$}
\newcommand{\breaktran}{\\*\>\>\>\hspace{8pt}}

% Theorem-like environments that are numbered as s.n, where:
% - s is the section number
% - n is the number of occurrences of all theorem-like environments in s
% We have the following environments:
% - definition
% - theorem
% - lemma
% - corollary
% - property
% - example
% - remark
% - convention
% - specification
% - declaration

\newtheorem{thdefinition}{Definition}[section]
\newenvironment{definition}
  {\begin{thdefinition}\em}
  {\end{thdefinition}}

\newtheorem{ththeorem}[thdefinition]{Theorem}
\newenvironment{theorem}
  {\begin{ththeorem}\em}
  {\end{ththeorem}}

\newtheorem{thcorollary}[thdefinition]{Corollary}
\newenvironment{corollary}
  {\begin{thcorollary}\em}
  {\end{thcorollary}}

\newtheorem{thlemma}[thdefinition]{Lemma}
\newenvironment{lemma}
  {\begin{thlemma}\em}
  {\end{thlemma}}

\newtheorem{thproperty}[thdefinition]{Property}
\newenvironment{property}
  {\begin{thproperty}\em}
  {\end{thproperty}}

\newtheorem{thexample}[thdefinition]{Example}
\newenvironment{example}
  {\begin{thexample}\em}
  {\end{thexample}}

\newtheorem{thremark}[thdefinition]{Remark}
\newenvironment{remark}
  {\begin{thremark}\em}
  {\end{thremark}}

\newtheorem{thconvention}[thdefinition]{Convention}
\newenvironment{convention}
  {\begin{thconvention}\em}
  {\end{thconvention}}

\newtheorem{thspecification}[thdefinition]{Specification}
\newenvironment{specification}
  {\begin{thspecification}\em}
  {\end{thspecification}}

\newtheorem{thdeclaration}[thdefinition]{Declaration}
\newenvironment{declaration}
  {\begin{thdeclaration}\em}
  {\end{thdeclaration}}

% proof: proof of a theorem
\newenvironment{proof}
  {\textbf{Proof}}
  {\frm{\Box}
   \vspace{1ex}%
  }


% Commands
% --------
% --------


% math mode
% ---------

% improvement to $ ... $ such that mathematical formulas cannot be cramped
\newcommand{\frm}[1]{\mbox{\ensuremath{#1}}}

% frm with extra spacing
\newcommand{\for}[1]{\frm{\,#1\,}}


% functions and constants
% -----------------------

% constant
\newcommand{\f}[1]{\ensuremath{\mathit{#1}}}

% function application with 1 argument: f(arg0)
\newcommand{\fa}[2]{\ensuremath{\f{#1}(#2)}}

% function application with 2 arguments: f(arg0, arg1)
\newcommand{\faa}[3]{\ensuremath{\f{#1}(#2, #3)}}

% function application with 3 arguments: f(arg0, arg1, arg2)
\newcommand{\faaa}[4]{\ensuremath{\f{#1}(#2, #3, #4)}}

% function application with 4 arguments: f(arg0, arg1, arg2, arg3)
\newcommand{\faaaa}[5]{\ensuremath{\f{#1}(#2, #3, #4, #5)}}


% functions and types
% -------------------

% to: ->
\newcommand{\To}{\ensuremath{\rightarrow}}

% function application symbol: .
\newcommand{\fap}{\ensuremath{\!\cdot\!}}

% composition: 0
\newcommand{\comp}{\ensuremath{\circ}}

% function composition: o
\newcommand{\fcomp}{\ensuremath{%
  \hspace{0.08em}\mbox{\small\ensuremath{\circ}}\hspace{0.08em}}}
  
% function mapping
\newcommand{\fmap}{
  \hspace{0.08em}\raisebox{0.2ex}{%
  \tiny\ensuremath{\bullet}}\hspace{0.08em}}


% lambda calculus
% ---------------

% abstraction in the typed lambda calculus
\newcommand{\labst}[3]{\ensuremath{\lambda #1\!:\!#2.#3}}

% application in the typed lambda calculus
\newcommand{\lappl}[2]{\ensuremath{#1\ #2}}

% abstraction in the pure (untyped) lambda calculus
\newcommand{\pabst}[2]{\ensuremath{\lambda #1.#2}}

% application in the pure (untyped) lambda calculus
\newcommand{\pappl}[2]{\ensuremath{#1\ #2}}

% sets
% ----

% set of elements: {e}
\newcommand{\set}[1]{\ensuremath{\{\,#1\,\}}}

% bag of elements: {e}
\newcommand{\bag}[1]{\ensuremath{\set{#1}}}

% set difference: s \ t
\newcommand{\sdiff}[2]{\ensuremath{#1\ \backslash\ #2}}

% set comprehension: { e | c }, where e is an expression or a binding and c is
% a condition
\newcommand{\scompr}[2]{\ensuremath{\set{#1\ |\ #2}}}

% powerset: P(s)
\newcommand{\pow}[1]{\ensuremath{\fa{\mathcal{P}}{#1}}}


% tuples
% ------

% tuple of elements: <e>
\newcommand{\tpl}[1]{\ensuremath{\langle\,#1\,\rangle}}

% pair of elements: <e0,e1>
\newcommand{\pair}[2]{\ensuremath{\tpl{#1\hspace{0.08em},#2}}}


% lists
% -----

% list of a certain type: L(t)
\newcommand{\List}[1]{\ensuremath{\mathcal{L}{\I{#1}}}}

% list of elements: [e]
\newcommand{\lst}[1]{\ensuremath{[\,#1\,]}}

% empty list
\newcommand{\el}{\ensuremath{[\,]}}

% cons: |>
\newcommand{\cons}{\ensuremath{\hspace{0.12em}\triangleright\hspace{0.08em}}}
  
% snoc: <|
\newcommand{\snoc}{\ensuremath{\hspace{0.08em}\triangleleft\hspace{0.12em}}}

% concatenation: ++
\newcommand{\concat}{\frm{+\!+}}

% take
\newcommand{\take}{\ensuremath{\lceil}}

% drop
\newcommand{\drop}{\ensuremath{\lfloor}}


% logic
% -----

% boolean type: B
\newcommand{\bool}{\ensuremath{\mathbb{B}}}

% true
\newcommand{\true}{\ensuremath{\f{true}}}

% false
\newcommand{\false}{\ensuremath{\f{false}}}

% implies: =>
\newcommand{\limp}{\ensuremath{\Rightarrow}}

% follows: =>
\newcommand{\lfol}{\ensuremath{\Leftarrow}}

% bi-implies: <=>
\newcommand{\lbimp}{\ensuremath{\Leftrightarrow}}

% not with extra spacing
\newcommand{\Lnot}{\ensuremath{\ \lnot\ }}

% and with extra spacing
\newcommand{\Land}{\ensuremath{\ \land\ }}

% or with extra spacing
\newcommand{\Lor}{\ensuremath{\ \lor\ }}

% implies with extra spacing
\newcommand{\Limp}{\ensuremath{\ \limp\ }}

% bi-implies with extra spacing
\newcommand{\Lbimp}{\ensuremath{\ \lbimp\ }}

% quantification in Dijkstra notation: <Q x : y : z>
\newcommand{\quantD}[4]{\ensuremath{\langle\,{#1} {#2} : #3 : {#4}\,\rangle}}

% universal quantification in Dijkstra notation: <forall x : y : z>
\newcommand{\forallD}[3]{\ensuremath{\quantD{\forall}{#1}{#2}{#3}}}

% existential quantification in Dijkstra notation: <exists x : y : z>
\newcommand{\existsD}[3]{\ensuremath{\quantD{\exists}{#1}{#2}{#3}}}

% derivable in #1: |-_#1
\newcommand{\derivable}[1]{\ensuremath{\vdash_{_{#1}}}}

% valid in #1: |=_#1
\newcommand{\valid}[1]{\ensuremath{\models_{_{#1}}}}

%inference rule with 0 premises and 1 conclusion
\newcommand{\infC}[1]{\ensuremath{
  \begin{array}{c} 
    \\\hline 
    #1 
  \end{array}
}}

%inference rule with 1 premise and 1 conclusion
\newcommand{\infPC}[2]{\ensuremath{
  \begin{array}{c} 
    #1 \\\hline 
    #2 
  \end{array}
}}

% inference rule with 2 premises and 1 conclusion
\newcommand{\infPPC}[3]{\ensuremath{
  \begin{array}{c@{\hspace{2em}}c}
    #1 & #2 \\\hline
    \multicolumn{2}{c}{#3}
  \end{array}
}}

%inference rule with 3 premises and 1 conclusion
\newcommand{\infPPPC}[4]{\ensuremath{
  \begin{array}{c@{\hspace{2em}}c@{\hspace{2em}}c}
    #1 & #2 & #3\\\hline
    \multicolumn{3}{c}{#4}
  \end{array}
}}

% arithmetic
% ----------

% natural type: N
\newcommand{\nat}{\ensuremath{\mathbb{N}}}

% positive type: N+
\newcommand{\pos}{\ensuremath{\mathbb{N}^{+}}}

% integral type: Z
\newcommand{\tint}{\ensuremath{\mathbb{Z}}}

% integer division: "div"
\renewcommand{\div}{\ensuremath{\ \mathbf{div}\ }}

% integer remainder: "mod"
\renewcommand{\mod}{\ensuremath{\ \mathbf{mod}\ }}


% miscellaneous
% -------------

% language of a signature Sigma: L(Sigma)
\newcommand{\lang}[1]{\ensuremath{\fa{\mathcal{L}}{\f{#1}}}}

% meaning of a syntactic element
\newcommand{\mean}[1]{%
  [\hspace{-.15em}[\hspace{.15em}#1\hspace{.15em}]\hspace{-.15em}]%
}

% alternative choice
\newcommand{\alt}{\ensuremath{[\hspace{-0.04em}]}}

% bullet
\newcommand{\bul}{\mbox{\small\ensuremath{\bullet}}}

% complexity according to expression: O(e)
\newcommand{\bigo}[1]{\ensuremath{\mathcal{O}(#1)}}

% print #2 inside #3, where #2 is raised by #1
\newlength{\insidewd}%                        Define length command
\newcommand{\inside}[3][0pt]{%		      Definition of inside:
   \settowidth{\insidewd}{#3}%                - Save width of #3
   \raisebox{#1}[0pt]{%                       - Raise #2 by #1
     \makebox[0pt]{\hspace{\insidewd}#2}}%    - Print #2 centered
   #3}%				              - Print #3

% stack #2 on #3, where #2 is raised by #1
\newlength{\stackht}%                         Define length commands
\newcommand{\stack}[3][0pt]{%		      Definition of stack:
   \settoheight{\stackht}{#3}%                - Save height of #3
   \addtolength{\stackht}{#1}%                - Add to #1 to heigth
   \inside[\stackht]{#2}{#3}}%                - Print #2 in #3 at height #3 + #1

% abbreviations
% -------------

% mCRL
\newcommand{\mCRL}{\frm{\mu}CRL\xspace}

% Miscellaneous local definitions
% -------------------------------

% temporary lengths
\newlength{\tlength}

% mCRL2 keywords
\newcommand{\kwsort}{{\bf sort}}
\newcommand{\kwcons}{{\bf cons}}
\newcommand{\kwmap}{{\bf map}}
\newcommand{\kwvar}{{\bf var}}
\newcommand{\kweqn}{{\bf eqn}}
\newcommand{\kwact}{{\bf act}}
\newcommand{\kwstruct}{{\bf struct}}
\newcommand{\kwwhr}{{\bf whr}}
\newcommand{\kwend}{{\bf end}}


% mCRL Sorts
\newcommand{\srtbool}{\f{Bool}}
\newcommand{\srtpos}{\f{Pos}}
\newcommand{\srtnat}{\f{Nat}}
\newcommand{\srtint}{\f{Int}}

% mCRL Operations
\newcommand{\opzeronat}{{0n}}
\newcommand{\oponenat}{{1}}
\newcommand{\optwonat}{{2}}
\newcommand{\opzeroint}{{0i}}
\newcommand{\opposint}{\ensuremath{\f{pos}}}
\newcommand{\opnegint}{\ensuremath{\f{neg}}}
\newcommand{\opnot}{\ensuremath{\f{not}}}
\newcommand{\opand}{\ensuremath{\f{and}}}
\newcommand{\opor}{\ensuremath{\f{or}}}
\newcommand{\opforall}{\ensuremath{\f{forall}}}
\newcommand{\opexists}{\ensuremath{\f{exists}}}
\newcommand{\opsucc}{\ensuremath{\f{succ}}}
\newcommand{\oppred}{\ensuremath{\f{pred}}}
\newcommand{\opadd}{\ensuremath{\f{add}}}
\newcommand{\opminus}{\ensuremath{\f{minus}}}
\newcommand{\opmonus}{\ensuremath{\f{monus}}}
\newcommand{\optimes}{\ensuremath{\f{times}}}
\newcommand{\opdiv}{\ensuremath{\f{div}}}
\newcommand{\opmod}{\ensuremath{\f{mod}}}
\newcommand{\oppower}{\ensuremath{\f{power}}}
\newcommand{\opdouble}{\ensuremath{\f{double}}}
\newcommand{\opif}{\ensuremath{\f{if}}}
\newcommand{\opeq}{\ensuremath{\f{eq}}}
\newcommand{\opneq}{\ensuremath{\f{neq}}}
\newcommand{\opgrt}{\ensuremath{\f{grt}}}
\newcommand{\opsmt}{\ensuremath{\f{smt}}}
\newcommand{\opgreq}{\ensuremath{\f{greq}}}
\newcommand{\opsmeq}{\ensuremath{\f{smeq}}}
\newcommand{\opint}{\ensuremath{\f{int}}}
\newcommand{\opnat}{\ensuremath{\f{nat}}}
\newcommand{\oplambda}[1]{\ensuremath{\f{lambda\_#1}}}
\newcommand{\opappl}[1]{\ensuremath{\f{appl\_#1}}}
\newcommand{\opsubst}[2]{\ensuremath{\f{subst\_#1\_#2}}}
\newcommand{\opindex}[1]{\ensuremath{\f{index\_#1}}}
\newcommand{\opproj}[2]{\ensuremath{\f{proj_{#1}^{#2}}}}
\newcommand{\opheadsymbol}{\ensuremath{\f{opheadsymbol}}}

\newcommand{\Time}{{\bf Time}}
\newcommand{\Bool}{{\bf Bool}}
\newcommand{\sft}{{\sf t}}
\newcommand{\sff}{{\sf f}}
\newcommand{\nul}{{\bf 0}}
\font \aap cmmi10        
\newcommand{\at}[1]{\mbox{\aap ,} #1}
\newcommand{\before}{\mbox{\footnotesize{\frm{\ll}}}}
\newcommand{\ap}{{:}}
\newcommand{\qed}{\hfill\ensuremath{\quad\Box}}
\newcommand{\leftmerge}{\underline {\parallel}}

\newenvironment{mCRL2}%
{\par\bigskip\noindent%
 \begin{tabular}{@{}>{\bf}p{2.3em}L@{\ }L@{\ }L@{\ }L@{\ }L@{\ }L@{\ }L@{\ }L}%
}%
{\end{tabular}\bigskip\par%
}

\begin{document}

\maketitle

\section{Data removal}

After the parsing and type checking phases comes the data removal phase. In
this phase, all data expressions except for data variables, operation
identifiers and data applications are removed. Also structured sorts are
removed. In this document we show how this is done. To increase readability, we
only show expressions in the external format instead of the internal format.

\subsection{Structured sorts}

A structured sorts is of the form
\begin{mCRL2}
& \kwstruct
    &c_{1}(\f{pr}_{1,1}: A_{1,1}, & \ldots & , \f{pr}_{1,k_{1}}: A_{1,k_{1}})
      ?\f{is\_c_{1}}\\
&\hfill |
    &c_{2}(\f{pr}_{2,1}: A_{2,1}, & \ldots & , \f{pr}_{2,k_{2}}: A_{2,k_{2}})
      ?\f{is\_c_{2}}\\
&                                 & \multicolumn{1}{c}{\vdots}\\
&\hfill |
    &c_{n}(\f{pr}_{n,1}: A_{n,1}, & \ldots & , \f{pr}_{n,k_{n}}: A_{n,k_{n}})
      ?\f{is\_c_{n}},
\end{mCRL2}
\noindent
where \frm{n \in \pos} and \frm{k_{i} \in \nat} with \frm{1 \leq i \leq n}.
All projections \frm{\f{pr}_{i,j}} and recognisers \frm{\f{is\_c_{i}}} are
optional.

For each constructor \frm{c_{i}} the following constructor operation is
declared, where
\frm{S} is the type of the structured sort:
\[c_{i}: A_{i,1} \times A_{i,k_{i}} \To S\]
For each defined projection \frm{p_{i,j}} the following operation is declared:
\[p_{i,j}: S \To A_{i,j}\]
For each defined recogniser \frm{\f{is\_c}_{i}} the following operation is
generated:
\[\f{is\_c}_{i}: S \To \srtbool\]

\subsection{Numerical constants}

For the types \frm{\srtpos}, \frm{\srtnat} and \frm{\srtint}, the following
constructors are provided:

\begin{mCRL2}
&@1:       & \srtpos             & \text{one}\\
&@0.:      & \srtpos \To \srtpos & \text{double the argument}\\
&@1.:      & \srtpos \To \srtpos & \text{double the argument and add one}\\
\\
&@0 :      & \srtnat             & \text{zero}\\
&@cPosNat: & \srtpos \To \srtnat & \text{positive number}\\
\\
&@-:       & \srtpos \To \srtint & \text{negation of a positive number}\\
&@cNatInt  & \srtnat \To \srtint & \text{natural number}\\
\end{mCRL2}

\noindent
Each numerical constant \frm{p} of type \frm{\srtpos} is implemented as a term
build from constructor symbols of type \frm{\srtpos} as follows:
\begin{tdefinitions}{-}
\item if \frm{p} is \frm{1}, use \frm{@1};
\item if \frm{p} is not \frm{1}, use \frm{\fa{@b.}{p'}}, where
\frm{b = p \mod 2} and \frm{p'} is the implementation of \frm{p \div 2}.
\end{tdefinitions}

\noindent
Each constant \frm{n} of type \frm{\srtnat} is implemented as follows:
\begin{tdefinitions}{-}
\item if \frm{n} is \frm{0}, use \frm{@0};
\item if \frm{n} is not \frm{0}, use \frm{\fa{@cPosNat}{n'}}, where \frm{n'} is
the implementation of the \emph{positive} number \frm{n}.
\end{tdefinitions}

\noindent
Each constant \frm{i} of type \frm{\srtint} is implemented as follows:
\begin{tdefinitions}{-}
\item if \frm{i} starts with \frm{-}, use \frm{\fa{@-}{i'}}, where \frm{i'} is
the implementation of the \emph{positive} number \frm{i} ;
\item if \frm{i} does not start with \frm{-}, use \frm{\fa{@cNatInt}{i'}}, where
\frm{i'} is the implementation of the \emph{natural} number \frm{i}.
\end{tdefinitions}

\subsection{List enumerations}

A list enumeration is of the form
\[[e_{0}, \dots, e_{n}]\]
where \frm{n \in \nat} and all \frm{e_{i}} are of the same type, say \frm{S}.
This enumeration is translated to the implementation of the following
expression:
\[e_{0} \cons \cdots \cons e_{n} \cons \el\]
Here, \frm{\el} is of type \frm{S}.

\subsection{Set enumerations}

A set enumeration is of the form
\[\set{e_{0}, \dots, e_{n}}\]
where \frm{n \in \nat} and all \frm{e_{i}}, \frm{0 \leq i \leq n} are of the
same type, say \frm{S}.  This is translated to the implementation of the
following expression:
\[\fa{@set}{\lambda x{:}S.\ (x == e_{0})\ \lor\ \cdots\ \lor\ (x == e_{n})}\]
Here, \frm{\f{@set}} is an operation system identifier of type \frm{S \To
\srtbool \To \fa{Set}{S}}, and \frm{x} is a variable that does not occur free
in \frm{e_{i}}, \frm{0 \leq i \leq n}.

\subsection{Bag enumerations}

A bag enumeration is of the form
\[\set{e_{0}: c_{0}, \dots, e_{n}: c_{n}}\]
where \frm{n \in \nat}, all \frm{e_{i}}, \frm{0 \leq i \leq n} are of the same
type, say \frm{S}, and all \frm{c_{i}} are of type \frm{\srtnat}.  This is
translated to the implementation of the following expression:
\[\fa{@bag}{\lambda x{:}S.\ (\faaa{if}{x == e_{0}}{c_{0}}{\faaa{if}{x ==
e_{1}}{c_{1}}{\ldots \faaa{if}{x == e_{n}}{c_{n}}{0}}})}\]
Here, \frm{\f{@bag}} is an operation system identifier of type \frm{(S \To
\srtnat) \To \fa{Bag}{S}}, and \frm{x} is a variable that does not occur free
in \frm{e_{i}} or \frm{c_{i}}, \frm{0 \leq i \leq n}.

\subsection{Set and bag comprehensions}

A set comprehension is of the form
\[\scompr{x{:}S}{\fa{f}{x}},\]
where \frm{\fa{f}{x}} is an expression of type \frm{\srtbool} in which \frm{x}
may occur. This is translated to the implementation of the following
expression:
\[\fa{@set}{\lambda x{:}S.\ \fa{f}{x}}\]
Here, \frm{\f{@set}} is an operation system identifier of type \frm{(S \To
\srtbool) \To \fa{Set}{S}}.

Bags are implemented in the same way with the exception that all occurrences of
type \frm{\srtbool} in the above are replaced by type \frm{\srtnat}.

\subsection{Quantifications}

A universal quantification is of the form
\[\forall x_{0}{:}S_{0}, \ldots, x_{n}{:}S_{n}. p,\]
where \frm{p} is an expression of type \frm{\srtbool}.

This expression is translated to the implementation of the following
expression:
\[\fa{forall}{\lambda x_{0}{:}S_{0}, \ldots, x_{n}{:}S_{n}. p}\]
Here, \frm{\f{forall}} is an operation system identifier of type
\frm{(S_{0} \To \cdots \To S_{n} \To \srtbool) \To \srtbool}. The
implementation of the lambda abstraction is shown in
subsection~\ref{subsec:lambda}.

The implementation of existential quantifications is completely analogous to
the above implementation.

\subsection{Lambda expressions}
\label{subsec:lambda}

A lambda abstraction is of the form
\[\lambda x_{0}{:}S_{0}, \ldots, x_{n}{:}S_{n}. e,\]
where the body \frm{e} may contain occurrences of the declared variables from
this abstraction and from the context. We denote the context variables that
occur in \frm{e} by \frm{x_{-m}, \ldots, x_{-1}} of type \frm{S_{-m}, \ldots,
S_{-1}}, respectively, where \frm{m \in \nat}.

This expression is translated to the implementation of the following
expression:
\[\fa{lambda@k}{x_{-m}, \ldots, x_{-1}},\]
Here, \frm{\f{lambda@k}} is an operation system identifier of where \frm{k} is
a unique natural number. It has type \frm{S_{-m} \times \cdots \times S_{-1}
\To S_{0} \To \cdots \To S_{n} \To T}, where \frm{T} is the type of expression
\frm{e}. For \emph{klambda} we have the following property:
\[\mathit{lambda@k}(x_{-m}, \ldots, x_{-1})(x_{0})\cdots(x_{n}) = e\]

\subsection{Where clauses}

A where clause is of the form
\[e\ \kwwhr\ x_{0} = e_{0}, \ldots, x_{n} = e_{n}\ \kwend\]
This expression is translated to the implementation of a the following
expression, where \frm{S_{i}} represents the type of \frm{e_{i}}, \frm{0 \leq i
\leq n}:
\[(\lambda x_{0}{:}S_{0}, \ldots, x_{n}{:}S_{n}. e)(e_{0})\cdots(e_{n})\]

\end{document}
