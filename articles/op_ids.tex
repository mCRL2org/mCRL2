\documentclass[a4paper,fleqn]{article}

% title and author
\title{Operation Identifiers for GenSpect}
\author{Aad Mathijssen} 

% packages
\usepackage[english]{babel}
\usepackage[final]{graphics}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{array}
\usepackage{calc}
\usepackage{xspace}

% General layout
% --------------

%add headings
\pagestyle{headings}

% increase pagewidth
\addtolength{\textwidth}{20mm}
\addtolength{\oddsidemargin}{-10mm}
\addtolength{\evensidemargin}{10mm}

% set the indentation of the math environment to 10mm
\setlength{\mathindent}{10mm}

% equations are unique up to their section
\renewcommand{\theequation}{\arabic{equation}}

% do not put subsubsections in the table of contents
\addtocounter{tocdepth}{-1}

% column types that change column types l,c,r from math mode to LR
% and the other way round
\newcolumntype{L}{>{$}l<{$}}%stopzone%stopzone%stopzone
\newcolumntype{C}{>{$}c<{$}}%stopzone%stopzone%stopzone
\newcolumntype{R}{>{$}r<{$}}%stopzone%stopzone%stopzone

% Environments
% ------------

% equations: eqnarray environment with no outer column spacing and tighter
% intercolumn spacing
\newenvironment{equations}
  {\setlength{\arraycolsep}{2pt}%
   \begin{array}{@{}lll@{}}%
  }
  {\end{array}%
  }

% tightarray: array with no outcolumn spacing and tighter intercolumn spacing
\newenvironment{tightarray}[1]
  {\setlength{\arraycolsep}{2pt}%
   \begin{array}{@{}#1@{}}%
  }
  {\end{array}%
  }

% definitions: list of definitions where:
% - the optional argument denotes the space between successive items
%   (default 0.15em)
% - items are horizontally aligned at the math indent
\newenvironment{definitions}[1][0.15em]
  {\begin{list}%
    {}%
    {\setlength{\parsep}{0pt}%
     \setlength{\itemsep}{#1}%
     \setlength{\leftmargin}{\mathindent}%
     \setlength{\labelwidth}{\mathindent - \labelsep}%
    }
  }
  {\end{list}}

% tdefinitions: list of tagged definitions where:
% - the optional argument denotes the space between successive items
%   (default 0.15em)
% - items are horizontally aligned at the math indent
% - each item is tagged with the mandatory argument
\newenvironment{tdefinitions}[2][0.15em]
  {\begin{list}%
    {#2}%
    {\setlength{\parsep}{0pt}%
     \setlength{\itemsep}{#1}%
     \setlength{\leftmargin}{\mathindent}%
     \setlength{\labelwidth}{\mathindent - \labelsep}%
    }
  }
  {\end{list}}

% edefinitions: list of enumerated definitions where:
% - the optional argument denotes the space between successive items
%   (default 0.15em);
% - items are horizontally aligned at the math indent;
% - each item is numbered with a parenthesized roman numeral.
\newcounter{edefinitioncount}
\newenvironment{edefinitions}[1][0.15em]
  {\begin{list}%
    {(\roman{edefinitioncount})}%
    {\renewcommand{\theenumi}{\roman{enumi}}%
     \renewcommand{\labelenumi}{(\theenumi)}%
     \usecounter{edefinitioncount}%
     \setlength{\parsep}{0pt}%
     \setlength{\itemsep}{#1}%
     \setlength{\leftmargin}{\mathindent}%
     \setlength{\labelwidth}{\mathindent - \labelsep}%
    }
  }
  {\end{list}}
  
% entry: list of entries where:
% - the optional argument denotes the space between successive items
%   (default 0.15em);
% - items are horizontally aligned at the math indent;
% - each item is labelled.
\newenvironment{entry}[2][0.15em]%
  {\begin{list}{}%
    {\renewcommand{\makelabel}[1]{\textsf{##1:}\hfil}%
     \settowidth{\labelwidth}{\textsf{#2:}}%
     \setlength{\leftmargin}{\labelwidth+\labelsep}%     
     \setlength{\parsep}{0pt}%
     \setlength{\itemsep}{#1}%
    }%
  }%
  {\end{list}}

% derivation: calculational derivation where expressions (\expr) are related by
% means of transformations (\tran). A transformation is denoted by a symbol and
% a hint. Expressions and transformations can be broken into several lines
% using \breakexpr and \breaktran.
\newenvironment{derivation}
{\par\addtolength{\baselineskip}{1mm}\begin{tabbing}\hspace{5mm}\=\hspace{5mm}\=\hspace{5mm}\=\kill}
{\end{tabbing}\par}
\newcommand{\expr}[1]{\>\>$#1$}
\newcommand{\tran}[2]{\\*\>$#1$\>\>\{ #2 \}\\}
\newcommand{\breakexpr}{$\\*\>\>$}
\newcommand{\breaktran}{\\*\>\>\>\hspace{8pt}}

% Theorem-like environments that are numbered as s.n, where:
% - s is the section number
% - n is the number of occurrences of all theorem-like environments in s
% We have the following environments:
% - definition
% - theorem
% - lemma
% - corollary
% - property
% - example
% - remark
% - convention
% - specification
% - declaration

\newtheorem{thdefinition}{Definition}[section]
\newenvironment{definition}
  {\begin{thdefinition}\em}
  {\end{thdefinition}}

\newtheorem{ththeorem}[thdefinition]{Theorem}
\newenvironment{theorem}
  {\begin{ththeorem}\em}
  {\end{ththeorem}}

\newtheorem{thcorollary}[thdefinition]{Corollary}
\newenvironment{corollary}
  {\begin{thcorollary}\em}
  {\end{thcorollary}}

\newtheorem{thlemma}[thdefinition]{Lemma}
\newenvironment{lemma}
  {\begin{thlemma}\em}
  {\end{thlemma}}

\newtheorem{thproperty}[thdefinition]{Property}
\newenvironment{property}
  {\begin{thproperty}\em}
  {\end{thproperty}}

\newtheorem{thexample}[thdefinition]{Example}
\newenvironment{example}
  {\begin{thexample}\em}
  {\end{thexample}}

\newtheorem{thremark}[thdefinition]{Remark}
\newenvironment{remark}
  {\begin{thremark}\em}
  {\end{thremark}}

\newtheorem{thconvention}[thdefinition]{Convention}
\newenvironment{convention}
  {\begin{thconvention}\em}
  {\end{thconvention}}

\newtheorem{thspecification}[thdefinition]{Specification}
\newenvironment{specification}
  {\begin{thspecification}\em}
  {\end{thspecification}}

\newtheorem{thdeclaration}[thdefinition]{Declaration}
\newenvironment{declaration}
  {\begin{thdeclaration}\em}
  {\end{thdeclaration}}

% proof: proof of a theorem
\newenvironment{proof}
  {\textbf{Proof}}
  {\frm{\Box}
   \vspace{1ex}%
  }


% Commands
% --------
% --------


% math mode
% ---------

% improvement to $ ... $ such that mathematical formulas cannot be cramped
\newcommand{\frm}[1]{\mbox{\ensuremath{#1}}}

% frm with extra spacing
\newcommand{\for}[1]{\frm{\,#1\,}}


% functions and constants
% -----------------------

% constant
\newcommand{\f}[1]{\ensuremath{\mathit{#1}}}

% function application with 1 argument: f(arg0)
\newcommand{\fa}[2]{\ensuremath{\f{#1}(#2)}}

% function application with 2 arguments: f(arg0, arg1)
\newcommand{\faa}[3]{\ensuremath{\f{#1}(#2, #3)}}

% function application with 3 arguments: f(arg0, arg1, arg2)
\newcommand{\faaa}[4]{\ensuremath{\f{#1}(#2, #3, #4)}}

% function application with 4 arguments: f(arg0, arg1, arg2, arg3)
\newcommand{\faaaa}[5]{\ensuremath{\f{#1}(#2, #3, #4, #5)}}


% functions and types
% -------------------

% to: ->
\newcommand{\To}{\ensuremath{\rightarrow}}

% function application symbol: .
\newcommand{\fap}{\ensuremath{\!\cdot\!}}

% composition: 0
\newcommand{\comp}{\ensuremath{\circ}}

% function composition: o
\newcommand{\fcomp}{\ensuremath{%
  \hspace{0.08em}\mbox{\small\ensuremath{\circ}}\hspace{0.08em}}}
  
% function mapping
\newcommand{\fmap}{
  \hspace{0.08em}\raisebox{0.2ex}{%
  \tiny\ensuremath{\bullet}}\hspace{0.08em}}


% lambda calculus
% ---------------

% abstraction in the typed lambda calculus
\newcommand{\labst}[3]{\ensuremath{\lambda #1\!:\!#2.#3}}

% application in the typed lambda calculus
\newcommand{\lappl}[2]{\ensuremath{#1\ #2}}

% abstraction in the pure (untyped) lambda calculus
\newcommand{\pabst}[2]{\ensuremath{\lambda #1.#2}}

% application in the pure (untyped) lambda calculus
\newcommand{\pappl}[2]{\ensuremath{#1\ #2}}

% sets
% ----

% set of elements: {e}
\newcommand{\set}[1]{\ensuremath{\{\,#1\,\}}}

% bag of elements: {e}
\newcommand{\bag}[1]{\ensuremath{\set{#1}}}

% set difference: s \ t
\newcommand{\sdiff}[2]{\ensuremath{#1\ \backslash\ #2}}

% set comprehension: { e | c }, where e is an expression or a binding and c is
% a condition
\newcommand{\scompr}[2]{\ensuremath{\set{#1\ |\ #2}}}

% powerset: P(s)
\newcommand{\pow}[1]{\ensuremath{\fa{\mathcal{P}}{#1}}}


% tuples
% ------

% tuple of elements: <e>
\newcommand{\tpl}[1]{\ensuremath{\langle\,#1\,\rangle}}

% pair of elements: <e0,e1>
\newcommand{\pair}[2]{\ensuremath{\tpl{#1\hspace{0.08em},#2}}}


% lists
% -----

% list of a certain type: L(t)
\newcommand{\List}[1]{\ensuremath{\mathcal{L}{\I{#1}}}}

% list of elements: [e]
\newcommand{\lst}[1]{\ensuremath{[\,#1\,]}}

% empty list
\newcommand{\el}{\ensuremath{[\,]}}

% cons: |>
\newcommand{\cons}{\ensuremath{\hspace{0.12em}\triangleright\hspace{0.08em}}}
  
% snoc: <|
\newcommand{\snoc}{\ensuremath{\hspace{0.08em}\triangleleft\hspace{0.12em}}}

% concatenation: ++
\newcommand{\concat}{\frm{+\!+}}

% take
\newcommand{\take}{\ensuremath{\lceil}}

% drop
\newcommand{\drop}{\ensuremath{\lfloor}}


% logic
% -----

% boolean type: B
\newcommand{\bool}{\ensuremath{\mathbb{B}}}

% true
\newcommand{\true}{\ensuremath{\f{true}}}

% false
\newcommand{\false}{\ensuremath{\f{false}}}

% implies: =>
\newcommand{\limp}{\ensuremath{\Rightarrow}}

% follows: =>
\newcommand{\lfol}{\ensuremath{\Leftarrow}}

% bi-implies: <=>
\newcommand{\lbimp}{\ensuremath{\Leftrightarrow}}

% not with extra spacing
\newcommand{\Lnot}{\ensuremath{\ \lnot\ }}

% and with extra spacing
\newcommand{\Land}{\ensuremath{\ \land\ }}

% or with extra spacing
\newcommand{\Lor}{\ensuremath{\ \lor\ }}

% implies with extra spacing
\newcommand{\Limp}{\ensuremath{\ \limp\ }}

% bi-implies with extra spacing
\newcommand{\Lbimp}{\ensuremath{\ \lbimp\ }}

% quantification in Dijkstra notation: <Q x : y : z>
\newcommand{\quantD}[4]{\ensuremath{\langle\,{#1} {#2} : #3 : {#4}\,\rangle}}

% universal quantification in Dijkstra notation: <forall x : y : z>
\newcommand{\forallD}[3]{\ensuremath{\quantD{\forall}{#1}{#2}{#3}}}

% existential quantification in Dijkstra notation: <exists x : y : z>
\newcommand{\existsD}[3]{\ensuremath{\quantD{\exists}{#1}{#2}{#3}}}

% derivable in #1: |-_#1
\newcommand{\derivable}[1]{\ensuremath{\vdash_{_{#1}}}}

% valid in #1: |=_#1
\newcommand{\valid}[1]{\ensuremath{\models_{_{#1}}}}

%inference rule with 0 premises and 1 conclusion
\newcommand{\infC}[1]{\ensuremath{
  \begin{array}{c} 
    \\\hline 
    #1 
  \end{array}
}}

%inference rule with 1 premise and 1 conclusion
\newcommand{\infPC}[2]{\ensuremath{
  \begin{array}{c} 
    #1 \\\hline 
    #2 
  \end{array}
}}

% inference rule with 2 premises and 1 conclusion
\newcommand{\infPPC}[3]{\ensuremath{
  \begin{array}{c@{\hspace{2em}}c}
    #1 & #2 \\\hline
    \multicolumn{2}{c}{#3}
  \end{array}
}}

%inference rule with 3 premises and 1 conclusion
\newcommand{\infPPPC}[4]{\ensuremath{
  \begin{array}{c@{\hspace{2em}}c@{\hspace{2em}}c}
    #1 & #2 & #3\\\hline
    \multicolumn{3}{c}{#4}
  \end{array}
}}

% arithmetic
% ----------

% natural type: N
\newcommand{\nat}{\ensuremath{\mathbb{N}}}

% positive type: N+
\newcommand{\pos}{\ensuremath{\mathbb{N}^{+}}}

% integral type: Z
\newcommand{\tint}{\ensuremath{\mathbb{Z}}}

% integer division: "div"
\renewcommand{\div}{\ensuremath{\ \mathbf{div}\ }}

% integer remainder: "mod"
\renewcommand{\mod}{\ensuremath{\ \mathbf{mod}\ }}


% miscellaneous
% -------------

% language of a signature Sigma: L(Sigma)
\newcommand{\lang}[1]{\ensuremath{\fa{\mathcal{L}}{\f{#1}}}}

% meaning of a syntactic element
\newcommand{\mean}[1]{%
  [\hspace{-.15em}[\hspace{.15em}#1\hspace{.15em}]\hspace{-.15em}]%
}

% alternative choice
\newcommand{\alt}{\ensuremath{[\hspace{-0.04em}]}}

% bullet
\newcommand{\bul}{\mbox{\small\ensuremath{\bullet}}}

% complexity according to expression: O(e)
\newcommand{\bigo}[1]{\ensuremath{\mathcal{O}(#1)}}

% print #2 inside #3, where #2 is raised by #1
\newlength{\insidewd}%                        Define length command
\newcommand{\inside}[3][0pt]{%		      Definition of inside:
   \settowidth{\insidewd}{#3}%                - Save width of #3
   \raisebox{#1}[0pt]{%                       - Raise #2 by #1
     \makebox[0pt]{\hspace{\insidewd}#2}}%    - Print #2 centered
   #3}%				              - Print #3

% stack #2 on #3, where #2 is raised by #1
\newlength{\stackht}%                         Define length commands
\newcommand{\stack}[3][0pt]{%		      Definition of stack:
   \settoheight{\stackht}{#3}%                - Save height of #3
   \addtolength{\stackht}{#1}%                - Add to #1 to heigth
   \inside[\stackht]{#2}{#3}}%                - Print #2 in #3 at height #3 + #1

% abbreviations
% -------------

% mCRL
\newcommand{\mCRL}{\frm{\mu}CRL\xspace}

% Miscellaneous local definitions
% -------------------------------

% temporary lengths
\newlength{\tlength}

% GenSpect keywords
\newcommand{\kwsort}{{\bf sort}}
\newcommand{\kwcons}{{\bf cons}}
\newcommand{\kwmap}{{\bf map}}
\newcommand{\kwvar}{{\bf var}}
\newcommand{\kweqn}{{\bf eqn}}
\newcommand{\kwact}{{\bf act}}
\newcommand{\kwstruct}{{\bf struct}}
\newcommand{\kwwhr}{{\bf whr}}
\newcommand{\kwend}{{\bf end}}


% mCRL Sorts
\newcommand{\srtbool}{\f{Bool}}
\newcommand{\srtpos}{\f{Pos}}
\newcommand{\srtnat}{\f{Nat}}
\newcommand{\srtint}{\f{Int}}

% mCRL Operations
\newcommand{\opzeronat}{{0n}}
\newcommand{\oponenat}{{1}}
\newcommand{\optwonat}{{2}}
\newcommand{\opzeroint}{{0i}}
\newcommand{\opposint}{\ensuremath{\f{pos}}}
\newcommand{\opnegint}{\ensuremath{\f{neg}}}
\newcommand{\opnot}{\ensuremath{\f{not}}}
\newcommand{\opand}{\ensuremath{\f{and}}}
\newcommand{\opor}{\ensuremath{\f{or}}}
\newcommand{\opforall}{\ensuremath{\f{forall}}}
\newcommand{\opexists}{\ensuremath{\f{exists}}}
\newcommand{\opsucc}{\ensuremath{\f{succ}}}
\newcommand{\oppred}{\ensuremath{\f{pred}}}
\newcommand{\opadd}{\ensuremath{\f{add}}}
\newcommand{\opminus}{\ensuremath{\f{minus}}}
\newcommand{\opmonus}{\ensuremath{\f{monus}}}
\newcommand{\optimes}{\ensuremath{\f{times}}}
\newcommand{\opdiv}{\ensuremath{\f{div}}}
\newcommand{\opmod}{\ensuremath{\f{mod}}}
\newcommand{\oppower}{\ensuremath{\f{power}}}
\newcommand{\opdouble}{\ensuremath{\f{double}}}
\newcommand{\opif}{\ensuremath{\f{if}}}
\newcommand{\opeq}{\ensuremath{\f{eq}}}
\newcommand{\opneq}{\ensuremath{\f{neq}}}
\newcommand{\opgrt}{\ensuremath{\f{grt}}}
\newcommand{\opsmt}{\ensuremath{\f{smt}}}
\newcommand{\opgreq}{\ensuremath{\f{greq}}}
\newcommand{\opsmeq}{\ensuremath{\f{smeq}}}
\newcommand{\opint}{\ensuremath{\f{int}}}
\newcommand{\opnat}{\ensuremath{\f{nat}}}
\newcommand{\oplambda}[1]{\ensuremath{\f{lambda\_#1}}}
\newcommand{\opappl}[1]{\ensuremath{\f{appl\_#1}}}
\newcommand{\opsubst}[2]{\ensuremath{\f{subst\_#1\_#2}}}
\newcommand{\opindex}[1]{\ensuremath{\f{index\_#1}}}
\newcommand{\opproj}[2]{\ensuremath{\f{proj_{#1}^{#2}}}}
\newcommand{\opheadsymbol}{\ensuremath{\f{opheadsymbol}}}

\newcommand{\Time}{{\bf Time}}
\newcommand{\Bool}{{\bf Bool}}
\newcommand{\sft}{{\sf t}}
\newcommand{\sff}{{\sf f}}
\newcommand{\nul}{{\bf 0}}
\font \aap cmmi10        
\newcommand{\at}[1]{\mbox{\aap ,} #1}
\newcommand{\before}{\mbox{\footnotesize{\frm{\ll}}}}
\newcommand{\ap}{{:}}
\newcommand{\qed}{\hfill\ensuremath{\quad\Box}}
\newcommand{\leftmerge}{\underline {\parallel}}

\newenvironment{genspect}%
{\par\bigskip\noindent%
 \begin{tabular}{@{}>{\bf}p{2.3em}L@{\ }L@{\ }L@{\ }L@{\ }L@{\ }L@{\ }L@{\ }L}%
}%
{\end{tabular}\bigskip\par%
}

\begin{document}

\maketitle

\noindent
Operation identifiers are used in data expressions. They may be system defined
or user defined. An identifier is called user defined if the user supplied a
declaration for it. It is called system defined if it is defined in this
document.

System identifiers are created during the parsing phase and the data
implementation phase. After the parsing phase the types of system identifiers
are not known; these are determined in the type check phase. More precisely,
after parsing system identifiers are available as \f{DataVarOpId}'s. During the
type checking phase these system identifiers are translated to \f{OpId}'s with
the correct type. System identifiers created in the data implementation phase
are marked by a \frm{^*} sign.

In the following, tables are provided that list the name, type, description and
external representation of each system identifier. This last column indicates
how the identifier is used as a data expression by the user. We have system
identifiers for booleans, numbers, lists, sets, bags and lambda expressions.

\subsection*{Booleans}

The system identifiers for booleans are listed in table~\ref{tab:ptc:booleans}.
Here, \frm{S} stands for an arbitrary sort expression.

\begin{table}[!htb]
\centering
\begin{tabular}{l|L|l|l}
Name          & \text{Type}                     & Description & External repr.\\
\hline
\verb+true+   & \srtbool                              & true         & constant\\
\verb+false+  & \srtbool                              & false        & constant\\
\verb+!+      & \srtbool \To \srtbool                 & logical negation
                                                                     & prefix\\
\verb+&&+     & \srtbool \times \srtbool \To \srtbool & conjunction  & infix\\
\verb+||+     & \srtbool \times \srtbool \To \srtbool & disjunction  & infix\\
\verb+=>+     & \srtbool \times \srtbool \To \srtbool & implication  & infix\\
\verb+==+     & S \times S \To \srtbool               & equality     & infix\\
\verb+!=+     & S \times S \To \srtbool               & inequality   & infix\\
\verb+if+     & \srtbool \times S \times S \To S
& conditional of sort \frm{S} & functional\\
\verb+forall+$^*$ & (S \To \srtbool) \To \srtbool
& universal quantification over \frm{S} & functional\\
\verb+exists+$^*$ & (S \To \srtbool) \To \srtbool
& existential quantification over \frm{S} & functional\\
\end{tabular}
\caption{System identifiers for booleans}
\label{tab:ptc:booleans}
\end{table}
\newpage
\subsection*{Numbers}

The system identifiers for positive numbers, natural numbers and integers are
listed in table~\ref{tab:ptc:numbers}. Here, \frm{A,B \in \set{\srtpos,
\srtnat, \srtint}} with \frm{A \neq B}:

\begin{table}[!htb]
\centering
\begin{tabular}{l|L|l|l}
Name        & \text{Type}                  & Description      & External repr.\\
\hline
\verb+@1+$^*$     & \srtpos                & 1                    & number\\
\verb+@cDub+$^*$  & \srtbool \To \srtpos \To \srtpos
                                           & double and add a bit & number\\
\verb+@0+$^*$     & \srtnat                & 0                    & number\\
\verb+@cNat+$^*$  & \srtpos \To \srtnat    & create natural from positive
                                                                  & number\\
\verb+@cNeg+$^*$  & \srtpos \To \srtint    & negate positive      & number\\
\verb+@cInt+$^*$  & \srtnat \To \srtint    & create integer from natural
                                                                  & number\\
\verb+A2B+        & A \To B                & convert \frm{A} to \frm{B}
                                                                  & functional\\
\verb+<=+         & A \times A \To \srtbool& less than or equal   & infix\\
\verb-<-          & A \times A \To \srtbool& less than            & infix\\
\verb+>=+         & A \times A \To \srtbool& greater than or equal& infix\\
\verb->-          & A \times A \To \srtbool& greater than         & infix\\
\verb+max+        & A \times A \To A       & maximum              & functional\\
\verb+min+        & A \times A \To A       & minimum              & functional\\
\verb+abs+        & \srtint \To \srtnat    & absolute value       & functional\\
\verb+-+          & A \To \srtint          & negation             & prefix\\
\verb+succ+       & \srtpos \To \srtpos    & successor            & functional\\
\verb+succ+       & \srtnat \To \srtpos    & successor            & functional\\
\verb+succ+       & \srtint \To \srtint    & successor            & functional\\
\verb+pred+       & \srtpos \To \srtnat    & predecessor          & functional\\
\verb+pred+       & \srtnat \To \srtint    & predecessor          & functional\\
\verb+pred+       & \srtint \To \srtint    & predecessor          & functional\\
\verb+@dub+$^*$   & \srtbool \To A \To A   & double and add a bit & functional\\
\verb-+-          & A \times A \To A       & addition             & infix\\
\verb+@addc+$^*$  & \srtbool \To \srtpos \To \srtpos \To \srtpos
                                           & addition with carry  & functional\\
\verb+-+          & A \times A \To \srtint & subtraction          & infix\\
\verb+@subtb+$^*$ & \srtbool \To \srtpos \To \srtpos \To \srtint
                                        & subtraction with borrow & functional\\
\verb+*+          & A \times A \To A       & multiplication       & infix\\
\verb+@multir+$^*$& \srtbool \To \srtpos \To & multiplication with& functional\\
           &\hfill \srtpos \To \srtpos \To \srtpos &\hfill intermediate result\\
\verb+div+        & \srtnat \times \srtpos \To \srtnat & quotient after division
                                                                  & infix\\
\verb+div+        & \srtint \times \srtpos \To \srtint & quotient after division
                                                                  & infix\\
\verb+mod+        & \srtnat \times \srtpos \To \srtnat & remainder after division
                                                                  & infix\\
\verb+mod+        & \srtint \times \srtpos \To \srtnat & remainder after division
                                                                  & infix\\
\verb+exp+        & A \times \srtnat \To A & exponentation        & functional\\
\verb+@even+      & \srtnat \To \srtbool   & even                 & functional\\
\end{tabular}
\caption{System identifiers for numbers}
\label{tab:ptc:numbers}
\end{table}
\newpage
\subsection*{Lists}

The system identifiers for lists are listed in table~\ref{tab:ptc:lists}. Here,
\frm{S} stands for an arbitrary sort expression:

\begin{table}[!htb]
\centering
\begin{tabular}{l|L|l|l}
Name & \text{Type} & Description & External repr.\\
\hline
\verb+[]+    & \fa{List}{S}
& empty list                     & constant\\
\verb+#+     & \fa{List}{S} \To \srtnat
& size of a list                 & prefix\\
\verb+|>+    & S \times \fa{List}{S} \To \fa{List}{S}
& element at the head of a list  & infix\\
\verb+<|+    & \fa{List}{S} \times S \To \fa{List}{S}
& element at the tail of a list  & infix\\
\verb-++-    & \fa{List}{S} \times \fa{List}{S} \To \fa{List}{S}
& concatenation                  & infix\\
\verb+.+     & \fa{List}{S} \times \srtnat \To S
& element at position            & infix\\
\verb+lhead+ & \fa{List}{S} \To S
& first element of a list        & functional\\
\verb+ltail+ & \fa{List}{S} \To \fa{List}{S}
& list without its first element & functional\\
\verb+rhead+ & \fa{List}{S} \To S
& last element of a list         & functional\\
\verb+rtail+ & \fa{List}{S} \To \fa{List}{S}
& list without its last element  & functional\\
\end{tabular}
\caption{System identifiers for lists}
\label{tab:ptc:lists}
\end{table}

\subsection*{Sets}

The system identifiers for sets are listed in table~\ref{tab:ptc:sets}. Here,
\frm{S} stands for an arbitrary sort expression.

\begin{table}[!htb]
\centering
\begin{tabular}{l|L|l|l}
Name & \text{Type} & Description & External repr.\\
\hline
\verb+@set+    & (S \To \srtbool) \To \fa{Set}{S}
& set comphrehension & set comprehension\\
\verb+{}+      & \fa{Set}{S}
& empty set          & constant\\
\verb+#+       & \fa{Set}{S} \To \srtnat
& size               & prefix\\
\verb+in+      & S \times \fa{Set}{S} \To \srtbool
& element test       & infix\\
\verb-<=-      & \fa{Set}{S} \times \fa{Set}{S} \To \srtbool
& subset             & infix\\
\verb-<-      & \fa{Set}{S} \times \fa{Set}{S} \To \srtbool
& proper subset      & infix\\
\verb-+-       & \fa{Set}{S} \times \fa{Set}{S} \To \fa{Set}{S}
& union              & infix\\
\verb+-+       & \fa{Set}{S} \times \fa{Set}{S} \To \fa{Set}{S}
& difference         & infix\\
\verb+*+       & \fa{Set}{S} \times \fa{Set}{S} \To \fa{Set}{S}
& intersection       & infix\\
\verb+!+       & \fa{Set}{S} \To \fa{Set}{S}
& complement         & prefix\\
\verb+Set2Bag+ & \fa{Set}{S} \To \fa{Bag}{S}
& convert set to bag & functional\\
\end{tabular}
\caption{System identifiers for sets}
\label{tab:ptc:sets}
\end{table}
\newpage
\subsection*{Bags}

The system identifiers for bags are listed in table~\ref{tab:ptc:bags}. Here,
\frm{S} stands for an arbitrary sort expression.

\begin{table}[!htb]
\centering
\begin{tabular}{l|L|l|l}
Name & \text{Type} & Description & External repr.\\
\hline
\verb+@set+    & (S \To \srtbool) \To \fa{Bag}{S}
& bag comphrehension & bag comprehension\\
\verb+{}+      & \fa{Bag}{S}
& empty bag          & constant\\
\verb+#+       & \fa{Bag}{S} \To \srtnat
& size               & prefix\\
\verb+in+      & S \times \fa{Bag}{S} \To \srtbool
& element test       & infix\\
\verb+count+   & S \times \fa{Bag}{S} \To \srtnat
& multiplicity   & infix\\
\verb-<=-      & \fa{Bag}{S} \times \fa{Bag}{S} \To \srtbool
& subbag             & infix\\
\verb+<+       & \fa{Bag}{S} \times \fa{Bag}{S} \To \srtbool
& proper subbag      & infix\\
\verb-+-       & \fa{Bag}{S} \times \fa{Bag}{S} \To \fa{Bag}{S}
& union              & infix\\
\verb+-+       & \fa{Bag}{S} \times \fa{Bag}{S} \To \fa{Bag}{S}
& difference         & infix\\
\verb+*+       & \fa{Bag}{S} \times \fa{Bag}{S} \To \fa{Bag}{S}
& intersection       & infix\\
\verb+Bag2Set+ & \fa{Bag}{S} \To \fa{Set}{S}
& convert bag to set & functional\\
\end{tabular}
\caption{System identifiers for bags}
\label{tab:ptc:bags}
\end{table}

\subsection*{Lambda expressions}

A lambda expression is of the form
\begin{equation}
\lambda x_{0}{:}S_{0}, \ldots, x_{n}{:}S_{n}.e,
\label{eq:lambda}
\end{equation}
with context variables \frm{x_{-m}{:}S_{-m}, \ldots, x_{-1}{:}S_{-1}} occurring
in \frm{e}. A system identifier for this expression is \verb+lambda@k+$^*$, of
type \frm{S_{-m} \times \cdots \times S_{-1} \To S_{0} \To \cdots \To S_{n} \To
S}. Here, \frm{S} is the type of \frm{e} and \frm{k} is a natural number that
ensures the uniqueness of the identifier. Expression~\eqref{eq:lambda} is
implemented by an application of \verb+lambda@k+ to terms of sort \frm{S_{-m},
\ldots, S_{-1}}, respectively.

\end{document}
