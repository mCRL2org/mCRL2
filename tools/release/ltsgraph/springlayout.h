// Author(s): Rimco Boudewijns and Sjoerd Cranen
// Copyright: see the accompanying file COPYING or copy at
// https://github.com/mCRL2org/mCRL2/blob/master/COPYING
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//

/**

  @file springlayout.h
  @author S. Cranen, R. Boudewijns

  This file contains an implementation and user interface which enables
  automatic positioning for a graph.

*/

#ifndef SPRINGLAYOUT_H
#define SPRINGLAYOUT_H

#include <map>

#include <QDockWidget>
#include <QtOpenGL>
#include <QElapsedTimer>

#include "ui_springlayout.h"
#include "ui_advancedspringlayoutdialog.h"

#include "glwidget.h"
#include "layoututility.h"
#include "attractionfunctions.h"
#include "repulsionfunctions.h"
#include "applicationfunction.h"

namespace Graph
{

class WorkerThread;
class SpringLayoutUi;
class CustomQWidget;

class SpringLayout
{
  friend class SpringLayoutUi;

  public:

  enum TreeMode
  {
    octree,
    quadtree,
    none
  };

  enum ThreadingMode
  {
    normal,
  };

  private:


  std::size_t m_max_num_nodes = 0;
  std::size_t m_total_num_nodes = 0;

  Octree m_node_tree;
  Octree m_handle_tree;
  Octree m_trans_tree;
  Quadtree m_node_tree2D;
  Quadtree m_handle_tree2D;
  Quadtree m_trans_tree2D;

  // UI parameters
  const float m_min_speed = 0.00001f;
  const float m_max_speed = 10.0f;
  float m_speed; ///< The rate of change each step.
  float m_speed_scale_func(float s) const
  {
    return s * s;
  }
  float m_speed_inverse_scale_func(float s) const
  {
    return std::sqrt(s);
  }
  const float m_min_attraction = 0.0f;
  const float m_max_attraction = 1.0f;
  float m_attraction; ///< The weight of the attraction of the edges.
  const float m_min_repulsion = 0.0f;
  const float m_max_repulsion = 1.0f;
  float m_repulsion; ///< The weight of the repulsion of other nodes.
  const float m_min_natLength = 0.0f;
  const float m_max_natLength = 100.0f;
  float m_natLength; ///< The natural length of springs.
  const float m_min_handleDeviation = 0.0f;
  const float m_max_handleDeviation = 30.0f;
  float m_handleDeviation; ///< The natural distance of a transition handle from its straight position between the states it connect. */
  const float m_labelDistance = 3.0; ///< The distance of a label to the handle */
  const float m_min_accuracy = 5.0f;
  const float m_max_accuracy = 0.0f;
  float m_accuracy; ///< Controls the Barnes-Hut criterion in the approximation
                    ///< of repulsive forces
  bool m_tree_enable_for_large_graphs = true;
  float m_stabilityThreshold = 1e-4;
  int m_stabilityMaxCount = 500; // Number of iterations in which change has to be within threshold before 'stable'
  int m_stabilityCounter = 0;
  float m_previous_energy = 1e25;
  std::vector<QVector3D> m_nforces, m_hforces, m_lforces,
      m_sforces; ///< Vector of the calculated forces..

  QVector3D center_of_mass_offset; ///< When un-anchoring offset should be kept
                                   ///< in mind
  bool any_anchored = false;
  QElapsedTimer drift_timer = QElapsedTimer(); ///< Timing since last anchoring
  const float time_to_center = 3; ///< After 1s of nothing anchored we want the center
                                  ///< of mass to be back at (0, 0, 0)

  WorkerThread* m_thread=nullptr;
  Graph& m_graph;       ///< The graph on which the algorithm is applied.
  SpringLayoutUi* m_ui; ///< The user interface generated by Qt.

  std::map<AttractionFunctionID, AttractionFunction*> attrFuncMap;
  AttractionFunction* m_attrFunc;
  AttractionFunctionID m_option_attractionCalculation;

  std::map<RepulsionFunctionID, RepulsionFunction*> repFuncMap;
  RepulsionFunction* m_repFunc;
  RepulsionFunctionID m_option_repulsionCalculation;

  private:
  /**
   * @brief Returns approximate accumulation of all repulsive forces from other
   * particles exerted on @e a
   *
   * @param a Particle
   * @param tree Octree containing all particles
   * @param repulsion Scaling constant
   * @param natlength Other scaling constant
   * @return QVector3D Force exerted by all particles on particle @e a
   */
    template<typename TreeType>
    QVector3D approxRepulsionForce(const QVector3D& a, TreeType& tree, float ideal_distance);

    void forceAccumulation(bool sel,
      std::size_t nodeCount,
      std::size_t edgeCount,
      TreeMode treeMode,
      ThreadingMode threadingMode);

    template<TreeMode mode>
    void repulsionAccumulation(bool sel, std::size_t nodeCount, std::size_t edgeCount);

    template<ThreadingMode mode>
    void attractionAccumulation(bool sel, std::size_t nodeCount, std::size_t edgeCount);

  public:
  GLWidget& m_glwidget;

  /**
   * @brief Constructor of the algorithm for the given @e graph.
   * @param graph The graph on which the algorithm should be applied.
   * @param thread The thread in which this process is running.
   */
  SpringLayout(Graph& graph, GLWidget& glwidget);
  virtual ~SpringLayout();

  /**
   * @brief Calculate the forces and update the positions.
   */
  void apply();

  void setAttractionCalculation(AttractionFunctionID c);
  AttractionFunctionID attractionCalculation();

  void setRepulsionCalculation(RepulsionFunctionID c);
  RepulsionFunctionID repulsionCalculation();

  /**
   * @brief Randomly moves nodes along the Z axis, at most [z] units
   * @param z The maximum distance that nodes are moved
   */
  void randomizeZ(float z);

  /**
   * @brief Pass-through whether graph is stable or not
   */
  const bool& isStable()
  {
    return m_graph.stable();
  };

  /**
   * @brief Returns the user interface object. If no user interface is
   * available, one is created using the provided @e parent.
   * @param The parent of the user inferface in the case none exists yet.
   */
  SpringLayoutUi* ui(QAction* advancedDialogAction = nullptr,
                     CustomQWidget* advancedWidget = nullptr,
                     QWidget* parent = nullptr);

  // Getters and setters
  int speed() const
  {
    return unlerp(m_speed_inverse_scale_func(m_speed),
                  m_speed_inverse_scale_func(m_min_speed),
                  m_speed_inverse_scale_func(m_max_speed));
  }
  int attraction() const
  {
    return unlerp(m_attraction, m_min_attraction, m_max_attraction);
  }
  int repulsion() const
  {
    return unlerp(m_repulsion, m_min_repulsion, m_max_repulsion);
  }
  int handleDeviation() const
  {
    return unlerp(m_handleDeviation, m_min_handleDeviation,
                  m_max_handleDeviation);
  }
  int naturalTransitionLength() const
  {
    return unlerp(m_natLength, m_min_natLength, m_max_natLength);
  }

  bool treeEnableForLargeGraphs() const
  {
    return m_tree_enable_for_large_graphs;
  }

  void notifyNewFrame();
  void setTreeEnabled(bool b);
  void setSpeed(int v);
  void setAccuracy(int v);
  void setAttraction(int v);
  void setRepulsion(int v);
  void setControlPointWeight(int v);
  void setNaturalTransitionLength(int v);

  /// @brief Used to invalidate graph when settings change (i.e.
  /// attraction/repulsion)
  void rulesChanged();

  void resetPositions();
};

struct Data
{
  Data(){};
  virtual QString toQString() = 0;
};

template <class T> struct TypedData : public Data
{
  T* m_data = nullptr;
  explicit TypedData(T* data) : Data(), m_data(data){};
  QString toQString() override
  {
    if (m_data)
    {
      return QStringLiteral("%1").arg(*m_data);
    }
    else
    {
      return "NaN";
    }
  }
};


class CustomQWidget : public QWidget
{
  Q_OBJECT

  public:
  CustomQWidget(QAction* act, QWidget* parent = nullptr)
      : QWidget(parent), m_act(act){};

  void closeEvent(QCloseEvent* e) override
  {
    m_act->setChecked(false);
    QWidget::closeEvent(e);
  }

  private:
  QAction* m_act;
};


class WorkerThread : public QThread
{
  Q_OBJECT

private:
  SpringLayout& m_layout;
  bool m_stopped=false;

public:
  signals:
    void draw_new_frame();

public:
  WorkerThread(SpringLayout& layout, QObject* parent = nullptr)
      : QThread(parent),
        m_layout(layout)
  {
    m_layout.m_glwidget.update();
  }

  void signal_draw_new_frame() 
  { 
    emit draw_new_frame();
  }

  void stop() 
  { 
    m_stopped = true; 
  }

  void run() override
  {
    while (!m_stopped)
    {
      if (m_layout.isStable())
      {
        msleep(50); // We don't want to keep computing if the layout is stable
      }
      else
      {
        m_layout.apply();
      }
    }
  }
};

//

class SpringLayoutUi : public QDockWidget
{
  Q_OBJECT
  private:
  SpringLayout& m_layout; ///< The layout algorithm that corresponds to this
                          ///< user interface.
  WorkerThread* m_thread; ///< The thread that is used to calculate the new positions.
  CustomQWidget* m_ui_advanced_dialog; ///< The QWidget object used to
                                       ///< instantiate the advanced Ui.
  public:
  Ui::DockWidgetLayout m_ui; ///< The user interface generated by Qt.
  Ui::AdvancedSpringLayoutDialog m_ui_advanced;

  /**
   * @brief Constructor.
   * @param layout The layout object this user interface corresponds to.
   * @param parent The parent widget for this user interface.
   */
  SpringLayoutUi(SpringLayout& layout, CustomQWidget* advancedWidget,
                 QWidget* parent = nullptr);

  /**
   * @brief Destructor.
   */
  ~SpringLayoutUi() override;

  /**
   * @brief Get the current state of the settings.
   */
  QByteArray settings();

  /**
   * @brief Restore the settings of the given state.
   * @param state The original state
   */
  void setSettings(QByteArray state);

  /**
   * @brief Indicates that the settings of the layout have changed, forcing a redraw of the graph.
   *
   */
  void layoutChanged();

  public:
    signals:
  /**
   * @brief Indicates that the thread is started or stopped.
   */
  void runningChanged(bool);

  public slots:
  void onStabilityThresholdChanged(const QString&);
  void onStabilityIterationsChanged(const QString&);
  void onResetPositionsPressed();

  void onAttractionChanged(int value);
  void onRepulsionChanged(int value);
  void onSpeedChanged(int value);
  void onAccuracyChanged(int value);
  void onHandleWeightChanged(int value);
  void onNatLengthChanged(int value);
  void onAttractionCalculationChanged(int value);
  void onRepulsionCalculationChanged(int value);

  void onStartStop();
  void onStarted();
  void onStopped();
  void onDrawNewFrame();

  void onTreeToggled(bool);
  void setActive(bool active);
  void onAdvancedDialogShow(bool);

  friend class SpringLayout;
};

} // namespace Graph

#endif // SPRINGLAYOUT_H
