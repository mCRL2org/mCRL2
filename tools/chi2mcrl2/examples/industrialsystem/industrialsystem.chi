// Studying industrial systems by simulation enables the designer to study
// their dynamic behaviour and to determine characteristics of the system.
// Unfortunately, simulation also has some disadvantages. These can be
// overcome by using formal methods. Formal methods allow a thorough analysis
// of the possible behaviours of a system, parameterised system analysis and
// a modular approach to the analysis of systems. We present a case study in
// which a model of an industrial system is studied in a formal way. For this
// purpose, the model is first specified and simulated using the CSP-based
// executable specification language χ. The model is translated into a model
// in the process algebra μCRL. This enables us to give a correctness proof
// of the parameterised model and to study the model in isolation.

model STMC()=
|[ chan st, tm: nat,
        mt, ts: [nat],
        ct, cm: bool,
        //Dummy process
        es: nat,
        se: [nat]
::  S(es, st, ts, se)
 || T(st, tm , mt ,ts, ct)
 || M(tm, mt, cm)
 || C(ct, cm, 10)
 // Dummy process
 || Din(es)
 || Dout(se)
]|

proc Din(chan es!: nat)=
|[ *(es!1)
]|

proc Dout(chan se?: [nat])=
|[ var store : [nat]
:: *(se?store)
]|

proc S(chan es?: nat, st!: nat, ts?: [nat], se!: [nat]) =
|[ var x : nat,
       xs, y: [nat],
       ys: [[nat]]
:: xs := []
 ; ys := []
 ; *( es?x; xs := xs ++ [x]
    | len(xs) > 0 -> st!hd(xs); xs := tl(xs)
    | ts?y; ys := ys ++ [y]
    | len(ys) > 0 -> se!hd(ys); ys := tl(ys)
    )
]|

proc T(chan st?: nat, tm!:nat, mt?: [nat], ts!:[nat], ct?:bool)=
|[ var x:  nat
     , xs: [nat]
     , z : bool
:: xs := []
 ; z := true
 ; *(
      ( z     -> st?x; xs := xs ++[x]; tm!hd(xs); xs := []
      | not z -> mt?xs; ts!xs; xs := []
      )
    ; ct?z
    )
]|

proc M(chan tm?: nat, mt!: [nat], cm?: bool)=
|[ var x: nat
     , xs: [nat]
     , z : bool
:: xs := []
 ; z := true
 ; *(
      ( z -> tm?x  ; xs := xs ++[x]
      | not z -> mt!xs ; xs := []
      )
    ; cm?z
    )
]|

proc C(chan ct!, cm!: bool, var s: nat)=
|[ var i : nat
:: i := 0
 ; *(
      ct!(i + 1 /= s); cm!(i+1 /= s)
    ; i := (i + 1) mod (s + 1)
    )
]|


