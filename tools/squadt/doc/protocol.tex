\documentclass{article}
\usepackage[UKenglish]{babel}
\usepackage{pslatex}
\usepackage{graphicx}
\usepackage{calc}
\usepackage{latexsym,amssymb,amsfonts,amsthm,amsmath}
\usepackage{float}
\usepackage{verbatim}
\usepackage{xspace}

\usepackage[top=3cm,left=3.3cm,bottom=3cm,right=3.3cm]{geometry}

\title{A Communication Protocol for Interactively \\ Controlling Software Tools}
\author{J. van der Wulp}
\date{}

\newtheorem{example}{Example}

\newcommand{\msg}[1]{\texttt{#1}}
\newcommand{\squadt}{SQuADT\xspace}
\newcommand{\String}{\ensuremath \mathbb{S}\xspace}
\newcommand{\Id}{\texttt{ID}\xspace}
\newcommand{\URI}{\texttt{URI}\xspace}
\newcommand{\MIMEtype}{\texttt{MIME-type}\xspace}

\makeatletter
\renewcommand{\paragraph}{\@startsection
  {paragraph}%
  {4}%
  {-1.3em}%
  {-\baselineskip}%
  {0.1\baselineskip}%
  {\normalfont\normalsize\textbf}}
\makeatother

%\setlength{\parindent}{0cm}
%\setlength{\parskip}{\baselineskip}

\bibliographystyle{alpha}

\begin{document}
%\maketitle
\begin{center}
\Large{A Communication Protocol for Interactively \\
           Controlling Software Tools } \\[8pt]
\large{J. van der Wulp} \\[4pt]
\normalsize{Technische Universiteit Eindhoven} \\
\normalsize{PO Box 513, 5600MB Eindhoven, The Netherlands} \\
\normalsize{j.v.d.wulp@tue.nl} \\[18pt]
\end{center}
\begin{abstract} \noindent %
 We present a protocol for interactively using software tools in a loosely
 coupled tool environment. Such an environment can assist the user in doing
 tasks that require the use of multiple tools. For example, it can invoke tools
 on certain input, set processing parameters, await task completion and have
 tools communicate the resulting output. It can also keep track of files
 produced by tools and prevent tools from reading and writing to the same file
 at the same time.  The protocol serves as an interface between the tools and a
 central tool manager. Generally, the manager controls the tools and forms an
 interface to a human user.  The protocol is used to connect our tool manager
 \squadt to a variety of tools, hereby allowing these tools to be used on all
 major software platforms.
\end{abstract}

\thispagestyle{empty}
\enlargethispage*{20pt}

 \section{Introduction}

  The mCRL2 toolset (see \cite{groote_et_al:DSP:2007:862}) is a collection of
  tools around the formal modelling language mCRL2 that can be used for formal
  verification and analysis of process behaviour.  Most of the tools have a
  traditional command line interface and today not everyone is comfortable with
  this way of working.  Therefore we started working on a tool integration
  framework to make the toolset usable for a broader audience. The idea is that
  a uniform graphical user interface should make it easier to use tools without
  having too much knowledge about the specifics of every tool.  The focus is
  simplifying the use of individual tools as well as combinations of tools and
  to automate frequently occurring tasks that involve the use of multiple
  tools.

  The \squadt desktop application is a graphical user interface layer around a
  new tool integration framework, within which a central part is played by the
  communication protocol described in this text.  The name \squadt, stands for
  Systems Quality, Analysis and Design Toolset, which refers to the kind of
  tasks that can be performed with the connected tools. The connected tools are
  those found in the mCRL2 toolset. Most of these tools can be used
  stand-alone by means of a traditional command line interface and some with a
  graphical user interface.  The only communication between the tools is
  uni-directional by means of files or file streams (also known as piping). The
  design of the \squadt graphical user interface as well as much of its
  functionality have, so far been targeted at tools with this specific
  behaviour.

  The idea of using a graphical user interface to simplify the use of a toolset
  is is not new. The \squadt application is very much influenced by the
  Eucalyptus application (see \cite{CADP}) in the CADP toolset. Eucalyptus was
  developed (around 1996) in the context of CADP for a very similar purpose as
  \squadt is for the mCRL2 toolset. However, this does not mean that all the
  underlying ideas of \squadt are the same as those of Eucalyptus.

  %  Ever since the first version, \squadt communicates with tools using the
  %  communication protocol described in this document.

  Contrary to Eucalyptus, in \squadt every action is performed in the context
  of a project. This approach is adapted from integrated development
  environments (IDE), see \cite{Eclipse,NetBeans} for two popular examples.
  An IDE is an integration framework for software development; it integrates a
  number of often stand-alone software tools that are used for software
  development. In the project context \squadt manages a collection of files and
  a collection of tools that can be used to add new files to a project. The
  user observes and directs this process through a graphical user interface.
  The core of that user interface is focused around an interactive visual
  overview of all data dependencies within a project.  Every dependency
  represents an application of a tool on a set of files with another (disjoint)
  set of files as the result (where output depends on input).  Within the
  context of a project \squadt keeps track of tool applications and through it
  the dependencies between files in the project. The file dependencies are then
  used to monitor consistency (explained shortly).

  Consistency is an relationship between input and output established by an
  arbitrary tool. Nothing is known about the exact relationship since nothing
  is known about the tool. So any change to either an input or output file can
  potentially violate consistency. Operations on files within a project can be
  monitored so operations that may violate consistency can be detected and
  signalled to the user automatically.

\enlargethispage*{20pt}
%  One important use of those dependencies is the detection of possible
%  inconsistencies between files. As an illustration of the purpose consider the
%  following scenario. Picture a project containing a file representing a log
%  generated by a tool as a result of the task it performed. Now another tool is
%  applied in the context of the same project to generate a report of this log
%  file. For some reason the user decides to reapply the tool that generates the
%  log file thereby updating this file.  Depending on the intend of the user the
%  report is possibly no longer up-to-date (or inconsistent) with the data in
%  the log file. Inconsistencies arise frequently as a result of working with
%  multiple tools on multiple files. Sometimes such inconsistencies are
%  overlooked and as a result the user analyses the wrong results. The idea is
%  to help the user to become aware of such inconsistencies when they arise.
  A file can be added to a project either by having the user select it as such
  or it can be produced by applying a tool to a set of files in the project. In
  the latter case the file is called \textit{derived}. Ideally it should be
  possible to recreate all derived files from non-derived files (those added
  manually by the user). To this end we have imposed the restriction in \squadt
  projects that tool applications may either modify or add files to a project,
  not both at the same time. When tool application results in creation of both
  new (output) files and modification of files in the project then all
  information regarding this tool application including the new output files is
  removed from the project.  Basically this means that the project context can
  store all file dependencies in a project as a directed acyclic graph. Notice
  that we could have avoided the restriction for instance by adding a version
  attribute to every project file such that the dependencies between the
  versioned files form an acyclic graph. We decided against this approach
  because of the associated complexity and the fact that it does not add any
  immediate benefits for any of the tools in the mCRL2 toolset.

%  Normal operations on files in a project.
%  A Using file dependencies it is possible to file consistency.
%  Consistency is a property between two disjoint sets of files,
%  called input and output. The property is established by the application of a
%  tool to the files of the input, which (re)produces the files of the output. A
%  change to a file in any of the two sets violates the property. A derived file
%  is called \textit{consistent} if and only if reapplication of the tool on the
%  input (with the same configuration) yields the exact same contents of all
%  output files, and provided that the set of input files is consistent. By
%  convention user added files are always called consistent. Derived files that
%  are not consistent are called inconsistent.

  Monitoring consistency can help the user to find problems that result from
  the changes made to files in the project. This is not a novel idea. In much
  the same way IDEs monitor changes to files in a project in order to
  conservatively rebuild executables from source files. The main difference
  between the two is that an IDE takes care of generation and maintenance of
  all derived files, whereas in our case the user is expected to actively do
  these tasks.

%  Inconsistency can result from legitimate tool application within the scope of
%  a project, but also from unexpected tool behaviour or system/hardware
%  failure. A limiting assumption in this regard is that file contents cannot be
%  inspected by the framework other than to create a checksum for detection of
%  changes.  The integration framework as well as the individual connected tools
%  must cooperate in order to maximise the effectiveness of any inconsistency
%  detection mechanism.  Firstly, creation and modification of files by tools
%  must be restricted, i.e.\ directed pro-actively by the integration framework.
%  Note that this is in line with the assumption that a derived file must be
%  producible in a unique way. Secondly, tools must communicate the complete
%  input and output.  When tools behave accordingly the set of dependencies
%  among files in a project is complete and the dependencies together form a
%  directed acyclic graph.

  Integrating tools works better `when tools are aware' of the integration
  context. For example, tools and tool integration framework must cooperate in
  order to maximise the effectiveness of any inconsistency detection mechanism.
  Another example is an application built on top of an integration framework,
  that will likely offer a different user interface to the functionality
  provided by a tool (than for instance a command line interface).  A different
  user interface may have different information requirements. For example in
  the context of a graphical user interface it is convenient and accepted
  practise to visualise state and progress. Showing state or progress when
  operating within the integration context may requires that a tool is tailored
  to this setting. Our communication interface is built on the idea of such a
  symbiosis between integration context and tool.

%  The access to functionality provided by the integration
%  framework will be provided by means of a custom communication protocol.

%%%  All functionality described above can in essence be obtained by an
%%%  integration system that just uses existing tools and their command line
%%%  interfaces. Making tools available in such a system would be a matter of
%%%  ad-hoc connection for instance by means of a plugin framework. This is the
%%%  approach chosen for Eucalyptus, the graphical front-end of the CADP toolset.
%%%  This approach is portable and works fine but connecting tools often takes a
%%%  lot of effort. One step further than Eucalyptus is to consider a facility at
%%%  user interface level that allows a tool to visualise task progress, and
%%%  interact with the user. This offers additional opportunities that were not
%%%  available to a tool with just a command line interface. So we decided on
%%%  using a custom communication protocol instead of existing command-line
%%%  interfaces in order to force tool builder to design new interfaces for
%%%  operating in a \squadt context.
%%%
%%%  As a matter of reference to an existing solution, a popular approach to an
%%%  interface is WSDL (see \cite{2001-WSDL}). Which is an interface description
%%%  language that is used to power web services, based on XML.  A web service is
%%%  ``a software system designed to support interoperable machine to machine
%%%  interaction over a network''. Technically it is possible to use the web
%%%  services model as intermediate interface between tool and integration system.
%%%  However, because of the static nature of interface description in WSDL it is
%%%  not easily possible to read additional input or produce additional output.
%%%  Several of the mCRL2 tools create new output files based on the input.
%%%  This is not something that is easily described in WSDL.
%%%
%%%  For tools without a graphical user interface
%%%  it would be possible to create a web service layer around the tool. For tools
%%%  with a graphical user interface this would only work. Tools with graphical user Our
%%%  focus is on a protocol for controlling tools from start to finish.

%  In abstract, the platform provides a number of facilities that can be used by
%  tools to communicate with the user. The tools provide services that are made
%  accessible to the user of the platform. The platform acts as a controller
%  (possibly for multiple tools at the same time) and therefore the system will
%  mostly be referred to as (the) controller in the remainder of this document.
%  Similarly, a tool is the communication partner of the controller.

  The following section introduces a number of important concepts and their
  connections. This is followed by a high level overview of the communication
  protocol.  The purpose of this abstract perspective is to give the reader a
  picture of the structure of communication: what is communicated, in what way
  and why, without going into detail. Next is a more detailed description of
  the protocol, consisting of a description of the contents of messages, and
  their representation.  At the end is a short comparison between integration
  frameworks that we know of (at least those with similar scope and purpose).
% IDE comparison
% note control aspect: user asserts control over a tool by means of the system

 \section{Concepts}

   It is only useful to consider integration between software tools when there
   is a meaningful way in which the tools can be used together. The purpose is
   then to obtain a result that cannot be obtained by any of the individual
   tools in isolation.

   The tool integration problem can be characterised by the manner in which a
   given set of software tools can be used together in order to achieve a given
   goal. Notice that, when the goal is not compatible with the functionality
   (or any combination thereof) provided by the available tools, then the
   problem does not have a solution.

   The \squadt tool integration framework assists the user in solving tool
   integration problems. To this end the framework has functionality for
   execution of individual tools, monitors consistency of files produced as
   input/output of tool application, and it offers communication facilities for
   communication between a user and a tool. All of this functionality is tied
   to the communication protocol for interactively controlling software tools,
   which functions as interface between tool and tool integration applications
   such as \squadt.

% The consistency monitoring functionality has profoundly influenced protocol
% design at several points.

%   The remainder of this section introduces a number of other important
%   concepts around which a communication protocol will be built later on.

  \subsection{Tool}

%   A regular English dictionary defines the meaning of the word tool as: the
%   means whereby some act is accomplished.
   A \textit{(software) tool} is a program that processes input and produces
   output that functionally depends on that input. Both input and output of a
   tool are sets of references to sources and sinks respectively consisting of
   binary data.  The output of a tool is the result or accomplishment. In
   practise a data source/sink is often a file in the local filesystem, but it
   could also be a stream or data associated with user interaction through
   connected human interface devices. The latter are are treated specially.

   Any tool is always used with a particular purpose in mind. Let's assume that
   the use serves the purpose (i.e.\ the tool is right for the job). A tool may
   serve different purposes and for each unique purpose the tool is said to
   have a \emph{function} for that particular purpose. For all thinkable
   purposes, the largest set of functions for a particular tool makes up its
   \textit{total functionality}.

%   Modern operating systems allow programs to be executed as processes either
%   concurrently or in a time-sharing fashion. The consequence of is that a tool
%   can be running multiple times at the same moment on the same machine. Notice
%   that a tool's input and output function as communication channels between
%   processes. % where to put unidirectional requirement?

  \subsection{Task}

   A \textit{task} for a tool is the use of a specific combination of functions
   of that tool. This combination determines input and output requirements. The
   input of a tool needed for a task, called \textit{task input}, is a
   non-empty set of resource identifiers (discussed shortly). Similarly output
   of a tool for a task, called \textit{task output}, is a non-empty set of
   resource identifiers. Every input as well as output is associated with a
   type that is specified using the MIME format (Multipurpose Internet Mail
   Extensions, \cite{rfc2822}). The input/output requirements for tasks
   typically include constraints on the types of inputs and outputs.

   A resource identifier is a name of a file or stream associated.  The principle method of
   specifying input/output files or streams is the Uniform Resource Identifier
   (or URI, see \cite{rfc3305}). A URI that is specified as part of input must
   identify an existing resource before a tool can be applied. Similarly, a URI
   that is specified as output must identify an existing resource after the
   tool completes its task.

  \subsection{Task Configuration} \label{concepts::task_configuration}

%Whether the use actually satisfies the purpose depends on the
%   functionality the tool provides and how the tool is used.

   The process of bringing a tool in the state where it can perform a specified
   task is called \textit{task configuration}. After task configuration is
   complete the state of a tool can be made explicit by capturing it as a task
   specification.  A \textit{task specification} for a tool is a concrete
   specification that uniquely defines a task for that tool (without accounting
   for user-interaction).

   A task specification, as depicted in figure \ref{figure:task_specification},
   consists of a description of the task input/output and it specifies the
   specific combination of functions that define the task. The task input is a
   set of URIs that all identify an existing resource. The task output is a set
   of URIs of potentially non-existing resources. Every input as well as output
   is associated with a type. A tool may fail completing its task if the actual
   resource identified by the URI does not match the type.

   \begin{figure}[H]
    \begin{center}
     \includegraphics{task_configuration.eps}
    \end{center}
    \caption{Graphic overview of the contents of a task specification}
    \label{figure:task_specification}
    \vspace{-0.4cm}
   \end{figure}

   % creation and manipulation (tool and system)

   A tool creates its own task specification and communicates it afterwards
   with the integration framework. The framework can read and modify the part
   that specifies the task input and output, e.g.\ it can rename input files.
   The remainder of the task specification is tool-specific, the framework can
   only store this information but not interpret. The purpose of communicating
   the configuration with the framework is to have a means to preserve it.

   Task execution is the process of using a tool to fulfil a configured task.
   To configure a task the tool must create a task specification in cooperation
   with the user and communicate it with the integration framework. To actually
   start execution the framework communicates a task specification with the
   tool that must either accept or reject it. Once a task specification is
   accepted actual task execution may commence.

   % note on user interaction
%   Some tools always require interaction with the user. In such a case a task cannot
%   be unambiguously specified. The task specification only specifies a starting
%   point from where the user interaction . The actions of the user may
%   completely change the configuration in any way.

   % note on failure
%   Since tools are programs, and programs can fail, task execution may fail.
%   Nothing can be concluded about a task that failed. If output exists it
%   must be assumed to be corrupted.

  \subsection{Display}

   Since tools create task specifications themselves, with the user as
   beneficiary, the tool must have means of communicating with the user. The
   \textit{(interaction) display} is a tool-controlled graphical user interface
   that acts as a direct communication channel between a running tool and the
   user. Every running instance of a tool has its own display. The display can
   also be used for instance to show task progress or to query a user during
   task execution.

%   There are no limits to the use of the display. Once a tool is running it can
%   make use of the display facility.

%%   Ideal integration would present a single user interface for all supported
%%   tools. Naturally a tool integration framework sits between the user and a
%%   set of tools. Tools would use the facilities of the integration framework to
%%   create a (graphical) user interface for communication with the user. This
%%   level of integration is very nice for a user but is too restrictive for our
%%   purposes.  Tools that have not been developed with integration in mind, can
%%   still be adapted to work in the context of an integration framework.  Many
%%   such existing tools have their own (graphical) user interface which cannot
%%   easily be recreated just for the purpose of obtaining a more uniform
%%   interface when the tool is used from the integration framework.

%%   As an example on the use of the display consider the following scenario. In
%%   order to arrive at a task-configuration, a tool must communicate with the
%%   user. As a result \textit{the tool} produces this task-configuration.  The
%%   complete procedure is as follows. First the user selects a tool that has the
%%   functionality to complete the task at hand.  The tool is started and must be
%%   configured to actually complete that task.  The tool can gather the
%%   information it needs to produce a task specification from the user through
%%   its interaction display. After the process of task configuration a task can
%%   be started. The tool will commence task execution during which it can use
%%   the display to inform the user about progress, or request further input.

   % added value
%   As hinted at before, the interaction display can be used for other purposes
%   than configuration. It could be used to add a graphical user interface to a
%   tool that otherwise does not have one. The tool controls the contents of
%   its display as long as it runs. An example of its use in a
%   non-configuration setting may be giving progress indication during task
%   execution.

%  \subsection{Tool Integration}
%
%   The \squadt application is a tool for interactive software tool
%   integration.  It is built on top of a tool integration framework that
%   currently only consists of a tool control interface. The main tasks of the
%   framework are running tools and directing communication between tools
%   whether running or not. The integration level functionality that \squadt
%   provides using the framework are:
%
%    \begin{itemize}
%     \item help guide users to find tools that offer the desired functionality
%     \item automate frequently (re)occurring tasks that involves running tools
%     \item offer a uniform way in which users can interact with tools
%    \end{itemize}
%
%   There are some more but these are the most significant ones and all have
%   directly affected the design of the tool control interface.

 \section{Communication Protocol (high level)} \label{s:high_level_specification}

  The \squadt application is built on top of a portable tool integration
  framework built in C++. At the heart of this framework is a communication
  protocol for interactively controlling tools. That is, \squadt is responsible
  for controlling tools on behalf of a user; and the user can directly
  communicate with a tool through the display facility. So there are three
  communication parties: user, framework and tool.

  \begin{figure}[H]
   \begin{center}
    \includegraphics[width=8.5cm]{parties.eps}
   \end{center}
   \vspace{-0.3cm}
   \caption{Communication parties}
  \end{figure}

  The protocol only concerns framework and tool, and from here on those parties
  are referred to as \textit{controller} and \textit{tool} respectively.  The
  role of a tool is that of a configurable service, that of a controller is to
  orchestrate tool actions on behalf of the user.

  The smallest unit of communication is a message. Messages are sent and
  received in a particular order and the protocol specifies how each message
  must be interpreted. Every message is equipped with a type that identifies
  its purpose.  The type indicates how the message should be interpreted and
  provides a means to specify restrictions on message order. Interpretation of
  a message is based on both its type and the role of the party that receives
  it.

  Message interpretation, besides type and role of the receiving party, is also
  affected by the messaging context.  A \textit{message context} is a
  chronologically ordered list of messages that were all either sent or
  received by the same communication partner in that particular order.  More
  formally let $p$ and $q$ be communication partners. The \textit{receiving
  context} of $p$ (pertaining to $q$) is the sequence of \emph{all} messages
  $m_{1}, m_{2}, m_{3}, \ldots$ that were sent by $q$ and received by $p$ in
  this particular order.  The \textit{sending context} of $p$ (pertaining to
  $q$) is the sequence of \emph{all} messages $m_{1}, m_{2}, m_{3}, \ldots$
  that were sent by $p$ and received by $q$ in this particular order. From
  hereon we will assume that every message that is sent will also be received
  and that message order is preserved. More precisely, the receiving context of
  $p$ pertaining to $q$ is a prefix of the sending context of $q$ pertaining to
  $p$.

  A basic pattern used in the protocol is a request-response sequence. The
  tool, as well as the controller, can issue a request that the other party
  \emph{must} respond to. So a request in the sending context can always be
  uniquely paired to a response in the receiving context. Besides this clear
  pattern there are also notification messages, e.g.\ messages that do not
  require any response.

  The remainder of this section provides a high level overview of the protocol
  in terms of the different message types and their purpose. The next section
  zooms in on the concrete representation of the different messages.

  \subsection{Message Presentation}

   Messages have a name and are specified as a tuple consisting of a type, a
   direction and a specification of the structure of its contents. In practise,
   the type is meta-information that is kept on the message `envelope' which
   hides the contents of the message. The direction is used for specifying
   which communication party is allowed to send such a message. In practise the
   direction is always clear for the party that sends/receives a message.
   Whether a message (contains data) can be established without `opening the
   envelope' (or inspecting the data).
   %The combination of message type, direction and whether it contains data,
   %identify the purpose of a message; so message names are only of
   %presentational use.

   Message types are introduced on demand; they are names that serve to
   identify message purpose. The type determines the way in which a
   communication partner should interpret the data. The way in which data
   inside a message is structured is described in terms of named types that may
   be composed of other (nested) types. The type notation is adapted from the
   mCRL2-data syntax for specification of data types
   \cite{groote_et_al:DSP:2007:862}. A BNF specification style is used to
   highlight the structure of the data and hint at the represented information.
   Concrete representational details are not discussed until section
   \ref{s:protocol_implementation}.

   The names of the types in the data field hint at both the purpose and
   inter-dependencies between messages. There is a small number of standard
   types, namely \Id, \URI, \MIMEtype, $\mathbb{B}$, $\mathbb{N}$, and
   $\String$.  An \Id represents a textual identifier with the purpose of
   referring to communicated information objects across message boundaries.
   Types \URI, \MIMEtype are string types that specify a URI \cite{rfc3305} and
   MIME-type \cite{rfc2045} respectively.
   Types may be composed using the $\times$ operator, as usual, and there are
   the parametrised types $Set$ and $List$ for specifying sets and lists (in
   the usual mathematical sense). Structured sorts are used for specification
   of sum types and compact representation of named product types.

%   As an example of type composition
%   take the type expression $\Id \times \mathbb{N}$ which represents an ordered
%   pair of $\Id$ and a natural number.  Using a structured sort the same pair
%   can also be expressed as: \[ \textit{struct } id\_nat\_pair(id : \Id, number
%   : \mathbb{N}) \] For sets and lists consider $Set(\mathbb{N})$ and
%   $List(\mathbb{B})$ which represents a set of natural numbers and a list of
%   Booleans respectively.

   The following two tables specify messages named `example request' and
   `example response' respectively. The request is sent by the controller and
   the response by a tool. The idea is that the tool computes distances for a
   trajectory specified by a list of time periods and relative orientation
   changes. Picture a tool that acts as a simulator for mars rover movement on
   a complex terrain.

   \begin{table}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{example request}} \\
      \hline
       message type:    & \msg{example} \\
      \hline
       direction:       & tool to controller \\
       data:            & List(\textit{struct } distances(minimum : $\mathbb{R}$, maximum : $\mathbb{R}$) \\
      \hline
     \end{tabular}
    \end{center}
    \vspace{-0.5cm}
   \end{table}

   \noindent The request contains a list of pairs of \texttt{Duration} and
   \texttt{Direction}. Think of duration as time range type that coincides
   with the (actually positive) Real number domain. The direction is used for
   specification of relative orientation either forward for no change in
   orientation or some degrees left or right.

   \begin{table}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{example response}} \\
      \hline
       message type:    & \msg{example} \\
      \hline
       direction:       & controller to tool \\
      \hline
       data:            & List(Duration $\times$ Direction) \\
                        & \ Direction = \textit{struct } left(Angle) $|$ straight $|$ right(Angle) \\
                        & \ Duration  = $\mathbb{R}$ \\
                        & \ Angle     = $\mathbb{N}$ \\
      \hline
     \end{tabular}
    \end{center}
    \vspace{-0.5cm}
   \end{table}

   \noindent The response consists of a list of pairs of minimum and maximum
   distances travelled. The result may of course depend on minimum/maximum
   acceleration initial trajectory velocity, and robot and terrain
   characteristics etc. The message content description in terms of types is
   simply used as high-level specification of input versus output of a tool for
   this specific task.

  \subsection{Communication behaviour}

   State diagrams are used to specify the allowed communication behaviour. An
   action label on a transition is the name of the message being sent. Special
   cases are connection initiation and severing transitions.  An incoming arrow
   from no state identifies the initial state. Figure
   \ref{figure:process_example} shows an example of how we specify allowed
   communication behaviour.

   \begin{figure}[H]
    \vspace{-0.3cm}
    \begin{center}
     \includegraphics{example.eps}
    \end{center}
    \vspace{-0.5cm}
    \label{figure:process_example}
    \vspace{-0.2cm}
   \end{figure}

   \noindent From the initial state an example request takes place, meaning that a
   communication action occurs between the partners. Subsequently an example
   response must occur, after which a state is reached from which a start
   notification can occur. A start notification can only be followed by a stop
   notification and vice-versa. The starting and stopping can be repeated ad
   infinitum.

  \subsection{Instance identification} \label{s:instance_identification}

   Although the integration framework (controller-side) starts tools, this
   does not automatically mean that protocol communication with that tool has
   been established. The tool must initiate communication and the framework is
   to wait for this to happen. In the meanwhile the framework may be
   communicating with other tools. So when communication is established the
   controller must identify the its communication partner as a tool that was
   started previously. Instance identification is the means by which a tool
   (instance) must somehow identify itself to the controller.

%   The integration framework that plays the part of controller starts tools on
%   demand, e.g.\ to allow a user to configure a task, and waits for each tool to
%   start communicating. The framework may be waiting for multiple tools to
%   report as communication partner which makes it necessary to identify
%   communication partners with tools that were started.
   Actual identification requires a pre-communicated secret. This secret takes
   the shape of an identification token, which is passed to the tool at
   startup.  When the tool subsequently initiates communication, the first
   communication action consists of exchanging the identification token. The
   framework then validates the token and in case of failure it cuts off
   further communication.

   A new messaging context (connection) is established for both partners when a
   tool initiates communication with a controller. The \message{identification
   notification} message is used for exchanging identification tokens; it looks
   as follows.

   \begin{figure}[H]
    \begin{center}
     \vspace{-0.3cm}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{identification notification}} \\
      \hline
       message type:    & \msg{identification} \\
      \hline
       direction:       & tool to controller \\
       data:            & Token \\
                        & \ Token = $\String$ \\
      \hline
     \end{tabular}
     \vspace{-0.5cm}
    \end{center}
   \end{figure}

   \noindent There is no response to such a message, after this message was
   communicated the controller-side has the initiative. The result is that
   either the connection is severed or the controller will send any command or
   request message (which will be treated shortly). Figure
   \ref{fig::identification} shows the combined behaviour of a controller and a
   tool with regard to instance identification.

   \begin{figure}[H]
    \begin{center}
     \includegraphics{connection_and_identification.eps}
    \end{center}
    \vspace{-0.5cm}
    \caption{Process of instance identification}
    \vspace{-0.2cm}
    \label{fig::identification}
   \end{figure}
\enlargethispage{1cm}
   \noindent A tool initiates a connection, sends an identification
   notification and starts waiting for incoming messages.  At the side of
   controller the value of the token is used to choose between breaking the
   connection and accepting the identity of the tool on the other side.
\pagebreak
  \subsection{Capabilities} \label{ss:capabilities}

   Capabilities represent both an information facility for one communication
   partner to learn about the capabilities of the other, as well as a protocol
   extension mechanism. The extension mechanism currently only consists of a
   means to check for the protocol version supported by a communication
   partner. This provides some limited backward and forward compatibility
   between protocol versions.  For example it allows a tool developer to check
   controller side support for facilities that have been introduced in specific
   protocol versions. The exchange process follows the basic request-response
   pattern and is symmetric for both communication parties. A request for
   capabilities message looks as follows.

   \begin{table}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{capabilities request}} \\
      \hline
       message type:    & \msg{capabilities} \\
      \hline
       direction:       & controller to tool \\
      \hline
       data:            & \\
      \hline
     \end{tabular}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{capabilities request}} \\
      \hline
       message type:    & \msg{capabilities} \\
      \hline
       direction:       & tool to controller \\
      \hline
       data:            & \\
      \hline
     \end{tabular}
     \vspace{-0.5cm}
    \end{center}
   \end{table}

   \noindent The partner that receives a capabilities request \emph{must} send
   a capabilities response message. For a controller the response only contains
   the protocol version number and looks as follows.

   \begin{table}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{capabilities response (controller)}} \\
      \hline
       message type:   & \msg{capabilities} \\
      \hline
       direction:      & controller to tool \\
      \hline
       data:           & Version = \textit{struct} version(major : $\mathbb{N}$, minor : $\mathbb{N}$) \\
      \hline
     \end{tabular}
    \end{center}
    \vspace{-0.5cm}
   \end{table}

   \noindent The response for a tool additionally contains a sort of
   `advertisement' of the tools functionality in the shape of a non-empty set
   of input configurations.  An \textit{input configuration} is a pair of a
   \textit{category}, and a non-empty list of names for inputs associated with
   a type (storage format).  The category is a descriptive name for the type of
   functionality that a tool offers for that specific input configuration.

   \begin{table}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{capabilities response (tool)}} \\
      \hline
       message type:   & \msg{capabilities} \\
      \hline
       direction:      & tool to controller \\
      \hline
       data:           & Version $\times$ Set(InputConfiguration) \\
                       & \ Version = \textit{struct} version(major : $\mathbb{N}$, minor : $\mathbb{N}$) \\
                       & \ InputConfiguration = Category $\times$ List(\Id $\times$ \MIMEtype) \\
                       & \ \ Category = $\String$ \\
      \hline
     \end{tabular}
    \end{center}
    \vspace{-0.5cm}
   \end{table}

   \noindent The exchange of capabilities follows a request-response sequence
   as illustrated by the following figure.

   \begin{figure}[H]
    \vspace{-0.4cm}
    \begin{center}
     \includegraphics{exchange_of_capabilities.eps}
    \end{center}
    \vspace{-0.7cm}
    \caption{Process of exchange of capabilities}
   \end{figure}

   \noindent The set of input configurations partition the entirety of tasks
   that a tool can perform into classes that have the same input requirements
   and whose functionality falls in the same category. Every task specification
   is based on a single input combination. The input combination expresses a
   set of basic input requirements for configuration and abstractly
   characterises what functionality of the tool will be used.

%   It is important to realise that the content of capabilities response
%   messages described here represent only a bare minimum. Protocol extension
%   requires extension to contents and therefore the structure of these
%   messages (see section \ref{ss:structure}).

  \subsection{Task Configuration} \label{ss:task_configuration}

%   The controller makes use of the services provided by a tool through task
%   configuration. After that, the task that is performed makes use of a
%   selection of the functionality that the tool provides.  Configuration and
%   task execution are separated, the latter is discussed in section
%   \ref{ss::task_execution}.

   The process of task configuration starts as soon as a user selects a tool
   for use of some of its functionality.  An input configuration (see section
   \ref{ss:capabilities}) serves as a concrete representation of the selected
   functionality and represents the starting point of further configuration. A
   task specification can be obtained in two ways, either by constructing it
   from an input configuration, or receiving one as the result of a task
   configuration process. Important to note is that every task configuration
   process starts by sending a task specification as part of a configuration
   request. The request message looks like:

%   Let $sc$ be the sending context of a controller and $rc$ be the receiving
%   context (pertaining to one tool). If both controller and tool are still
%   running and every configuration message in $sc$ can be paired to a unique
%   configuration message in the receiving context then \emph{no} task
%   configuration is in progress.

   \begin{table}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{configuration request}} \\
      \hline
       message type:   & \msg{configuration} \\
      \hline
       direction       & controller to tool \\
      \hline
       data:           & Interactivity $\times$ Configuration \\
                       & \ Interactivity = $\mathbb{B}$ \\
                       & \ TaskSpecification = Category $\times$ List(ConfigurationItem) \\
                       & \ \ Category = $\String$ \\
                       & \ \ ConfigurationItem = \textit{struct} object(\Id,Object) $|$ option(List($\String$ $\times$ DataType)) \\
                       & \ \ \ Object = \textit{struct} input(\URI $\times$ \MIMEtype) $|$ output(\URI $\times$ \MIMEtype) \\
                       & \ \ \ DataType = \textit{struct} boolean $|$ string $|$ real\_range($\mathbb{R}$,$\mathbb{R}$) $|$ integer\_range($\mathbb{Z}$,$\mathbb{Z}$) \\
      \hline
     \end{tabular}
     \vspace{-0.3cm}
    \end{center}
   \end{table}

   \noindent The request message consists of a pair of a Boolean, the
   \textit{interactivity flag}, and a task specification. The interactivity
   flag specifies whether or not further configuration through interaction with
   the user is desired. Notice that a tool may initiate interaction with the
   user regardless the interactivity flag. The intended purpose however, is that
   when no interactivity is desired the user is consulted as little as
   possible. A more detailed explanation of a task specification follows after
   the introduction of the response message.

   Configuration details, as part of task specifications, can now exist outside
   the tool.  A consequence is that it opens up the opportunity that a tool
   receives an invalid task specification, e.g.\ it does not uniquely specify a
   configuration. Whatever the cause, it is necessary on the tool-side to check
   whether task specifications are usable.  In other words a tool developer
   must provide a procedure to test task specification for validity. Moreover
   in the case a task specification is not valid the tool developer must
   resolve this problem through communication with the user.

   Before sending a response the tool may initiate arbitrary interaction with
   the user (see subsection \ref{ss:user_interaction}). The user as beneficiary
   is supposed to direct the process of task-configuration.

   \begin{table}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{configuration response}} \\
      \hline
       message type:   & \msg{configuration} \\
      \hline
       direction       & tool to controller \\
      \hline
       data:           & Validity $\times$ TaskSpecification \\
                       & \ Validity = $\mathbb{B}$ \\
                       & \ TaskSpecification = Category $\times$ List(ConfigurationItem) \\
                       & \ \ Category = $\String$ \\
                       & \ \ ConfigurationItem = \textit{struct} object(\Id,Object) $|$ option(List($\String$ $\times$ DataType)) \\
                       & \ \ \ Object = \textit{struct} input(\URI $\times$ \MIMEtype) $|$ output(\URI $\times$ \MIMEtype) \\
                       & \ \ \ DataType = \textit{struct} boolean $|$ string $|$ real\_range($\mathbb{R}$,$\mathbb{R}$) $|$ integer\_range($\mathbb{Z}$,$\mathbb{Z}$) \\
      \hline
     \end{tabular}
    \end{center}
    \vspace{-0.4cm}
   \end{table}

   \noindent The response carries a judgement, the validity flag, and the final
   configuration.  Depending on the value of the validity flag the embedded
   configuration was judged usable and the configuration is accepted. Notice
   that the task specification that is sent as part of a request is not
   necessarily the same as that in the response.

   A task specification  is modelled after the non-interactive part of a
   traditional command line interface.  Traditionally non-interactive command
   line interfaces are used to capture the configuration of a program into a
   single string, the command. A command can be decomposed into an identifier
   of the program and a list of options that have a list of arguments. The
   purpose of a non-interactive command line interface is exactly the same as
   that of a configuration specification.  Namely capturing the configured
   state of a tool with the purpose of reproducing that state automatically at
   a later time.

   A minimal task specification consists of a category specifier and a
   non-empty list of configuration items. The category specifier is a name that
   characterises the functionality of the tool, which is used to classify the
   tool in the user interface of an integration context. Configuration items
   are either objects (corresponding to input/output source, see figure
   \ref{figure:process_example}) or options (as in their command line
   equivalents) with an arbitrary number of arguments.  The options represent
   the language for task specification. A single option is a parametrised
   entity that represents the smallest part of optional configurable behaviour.
   The list of options identifies a combination of functions that make up the
   task.

%   It is assumed that the task-configuration that is returned in a response has
%   a strong resemblance to the task-configuration sent in the request. At the
%   very least they should share the same main-input, the rest is up to the
%   creativity of the tool developer.

%   \noindent About the configuration specifications: every option is uniquely
%   identified, and so is every object. The reason is to make it easier for a
%   tool developer to test for availability of options/objects.  An option
%   represents an atomic unit in the configurable behaviour of a tool. For
%   validation purposes a data type can be specified against which the values
%   for the option are matched. An object is a file associated with a format and
%   a location.

   The following figure depicts the basic (isolated) communication behaviour of
   the task configuration process.

   \begin{figure}[H]
    \begin{center}
     \includegraphics{configuration_execution.eps}
    \end{center}
    \vspace{-0.3cm}
    \label{fig:configuration_execution}
    \caption{Schematic overview of the process of task configuration and execution}
   \end{figure}

   \noindent The process of task configuration is a straight-forward application of the
   request-response pattern. The state with label \texttt{C} represents the
   configured state, i.e.\ the state from which task execution may commence.
   Similarly the state with label \texttt{E} represents the state in which the
   tool is executing a task. Section \ref{ss::task_execution} introduces the
   messages that deal with task execution.

  \subsection{Task Execution} \label{ss::task_execution}

   When configuration is complete the controller may start task execution by
   sending a task start command. Configuration is complete when the controller
   receives a configuration response message with an accepted configuration and
   it has not sent a new configuration request.  A task is called \textit{in
   progress} as soon as a task start signal is sent, and as long as no task
   stop signal has been received. See figure \ref{fig:configuration_execution}
   for a schematic overview of the process of task execution.

   A message representing a task start command looks as in the leftmost table
   below.  When a tool receives a task start command it must start executing
   the configured task. As task execution completes the tool must send a task
   stop notification as shown in the table on the right.

   \begin{table}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{task start command}} \\
      \hline
       message type:   & \msg{task} \\
      \hline
       direction       & controller to tool \\
       data:           & \\
                       & \\
      \hline
     \end{tabular}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{task stop notification}} \\
      \hline
       message type:   & \msg{task} \\
      \hline
       direction       & tool to controller \\
       data            & Result \\
                       & \ Result = $\mathbb{B}$ \\
      \hline
     \end{tabular}
    \end{center}
    \vspace{-0.3cm}
   \end{table}

   \noindent The data in the stop notification signifies success or failure
   of task execution. In case of failure the user should probably be notified
   of the details of the failure using the display or the reporting facility
   both of which will be discussed shortly.

%%   A side remark on task
%%   execution: the controller has the responsibility to ensure that the inputs
%%   in a configuration exist prior to starting a task that depends on them. Also
%%   it must ensure that they remain unchanged (by the environment) during task
%%   execution. Likewise, the outputs must not exist or be modifiable by the tool
%%   prior to starting a task, and it must ensure that the environment leaves the
%%   outputs unchanged during task execution.
  \pagebreak
  \subsection{Reporting}

   The purpose of the reporting facility is to inform the user (through the
   controller) of individual task activities and their progress. A report may
   be sent from any context and signifies either a warning, error or just
   notification of some event. The facility is intended as secondary source of
   information (next to the display) that a user may consult to get more
   feedback on configuration or task execution. A report message looks as follows:

   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{report notification}} \\
      \hline
       message type:   & \msg{report} \\
      \hline
       direction:      & tool to controller \\
      \hline
       data:           & ReportType $\times$ Description \\
                       & \ ReportType = \textit{struct} notice $|$ warning $|$ error \\
                       & \ Description = $\String$ \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}
   \vspace{-0.3cm}

   \noindent This facility is meant as an indirect method of communication with
   the user. The information from the reporting facility ends up in a log that
   is only visible when the user wants it. So the reporting facility must not
   be relied on as a part of the user regular user interface.  The reporting
   facility is intended as additional source of information for the user and
   \emph{not} an exception handling facility for the tool developer.

  \subsection{Termination}

   The termination facility allows the controller to terminate a tool in a
   controlled fashion.  In this way a tool is allowed to free resources
   and remove inconsistent outputs. A termination command/request and the
   message that is sent as response are depicted below.

   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{termination command}} \\
      \hline
       message type:    & \msg{termination} \\
      \hline
       direction:       & controller to tool \\
      \hline
     \end{tabular}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{termination notification}} \\
      \hline
       message type:   & \msg{termination} \\
      \hline
       direction:      & tool to controller \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}
   \vspace{-0.5cm}

   \noindent The response such a request is a termination notification.  The
   mandatory response signifies that the tool is shutting down (making
   preparations for termination) and will terminate soon.  Additionally the
   notification can also be send by a tool when it is shutting down for other
   reasons than after a prior termination request. This functionality is meant
   to be used only in exceptional cases such as that a tool must terminate
   after an unrecoverable error.

   The following figure shows the communication behaviour with regard to
   termination commands and notifications.

   \begin{figure}[H]
    \begin{center}
     \includegraphics{termination.eps}
    \end{center}
    \vspace{-0.5cm}
    \caption{termination behaviour}
   \end{figure}

   \noindent When a tool fails to respond to a termination request, the
   integration framework may force a tool to terminate by other means.

  \subsection{Display} \label{ss:user_interaction}

   The display facility represents the primary means of a tool to communicate
   with the user.  Think of it as an interactive bulletin board containing a
   set of user interface primitives (called \textit{widgets}) in some
   arrangement.  Every change to the widgets as a result of user interaction is
   directly communicated with the tool.  The set of widgets on the display and
   their arrangement are controlled by the tool that owns the display.  A
   \textit{layout specification} is a description of a set of widgets and a set
   of constraints of how to position them relative to each other on the space
   made available by the display. A message that looks as follows is used to
   communicate layout specifications.

   \begin{table}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{display change command}} \\
      \hline
       message type:   & \msg{display\_layout} \\
      \hline
       direction:      & tool to controller \\
      \hline
       data:           & LayoutManager \\
                       & \ LayoutManager = BoxLayoutManager \\
                       & \ \ BoxLayoutManager = \textit{struct} horizontal(ElementList) $|$ vertical(ElementList) \\
                       & \ \ \ ElementList = List(LayoutConstraints $\times$ \Id $\times$ LayoutElement)) \\
                       & \ \ \ LayoutConstraints = Visibility $\times$ Status $\times$ Margins $\times$ Alignment \\
                       & \ \ \ \ Visibility = \textit{struct} visible $|$ hidden \\
                       & \ \ \ \ Status = \textit{struct} enabled $|$ disabled \\
                       & \ \ \ \ Margins = \textit{struct} margins(top : $\mathbb{N}$, left : $\mathbb{N}$, bottom : $\mathbb{N}$, right : $\mathbb{N}$) \\
                       & \ \ \ \ Alignment = HorizontalAlignment $\times$ VerticalAlignment \\
                       & \ \ \ \ \ HorizontalAlignment = \textit{struct} left $|$ centre $|$ right \\
                       & \ \ \ \ \ VerticalAlignment = \textit{struct} bottom $|$ middle $|$ top \\
                       & \ \ \ LayoutElement = \textit{struct} layout\_manager(LayoutManager) $|$ widget(Widget) \\
                       & \ \ \ \ Widget = \textit{struct} progress\_bar($\mathbb{N} \times \mathbb{N} \times \mathbb{N}$) $|$
                                                          radio\_button($\String \times \mathbb{B}$) $|$ \\
                       & \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
                                                          button($\String \times \mathbb{B}$) $|$
                                                          checkbox($\String \times \mathbb{B}$) $|$
                                                          label($\String$) $|$
                                                          text\_field($\String$) \\
      \hline
     \end{tabular}
    \end{center}
   \vspace{-0.4cm}
   \end{table}

   \noindent Every widget \emph{must} have an identifier, that uniquely
   identifies it in a layout.  Subsequent communication of changes to the state
   of a widget rely on the identifier as widget specifier. A special subsection
   \ref{subsection:widgets_and_layout} is devoted to explaining the structure
   of a layout specification. For now we focus on communication of display
   interaction data and changes to the state of widgets on the display.

   User interaction with widgets on the display is relayed to the
   associated tool as soon after the interaction took place. On the other
   hand a tool can change the internal state of widgets, e.g.\ change the label
   of a button from `okay' to `cancel'. In both cases information from
   individual widgets, called \textit{display data}, is exchanged between the
   communication partners. A tool can request a state change for a set of
   widgets on the display using a message that looks as follows.

   \begin{table}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{display manipulation command}} \\
      \hline
       message type:   & \msg{display\_data} \\
      \hline
       direction:      & tool to controller \\
      \hline
       data:           & List(\Id $\times$ Widget) \\
                       & \ Widget = \textit{struct} progress\_bar($\mathbb{N} \times \mathbb{N} \times \mathbb{N}$) $|$
                                                    radio\_button($\String \times \mathbb{B}$) $|$ \\
                       & \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
                                                    button($\String \times \mathbb{B}$) $|$
                                                    checkbox($\String \times \mathbb{B}$) $|$ \\
                       & \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
                                                    label($\String$) $|$
                                                    text\_field($\String$) \\
      \hline
     \end{tabular}
    \end{center}
   \vspace{-0.4cm}
   \end{table}

   \noindent When a controller receives such a message it is interpreted as a
   state change of a widget that matches the identifier. The controller manages
   the display on behalf of a tool and needs to process these updates as
   follows.  Let ($id$, $s$) be a pair of identifier and widget state
   specification. If $id$ does not identify a widget on the display the state
   update represented by the pair is ignored. If $id$ identifies a
   widget on the display and the type of this widget is not the same as that of
   $s$ the state update is ignored.  Otherwise $s$ becomes the new state of the
   widget on the display that is identified by $id$.

   \pagebreak

   As noted before, changes to widgets on the display as a result of user
   interaction are directly communicated with the tool. The tool does not have
   direct access to the display and is assumed to a local representation of the
   contents of the display in order to interpret the results. Communication of
   changes due to interaction is performed with a message that looks like:

   \begin{table}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{display interaction notification}} \\
      \hline
       message type:   & \msg{display\_data} \\
      \hline
       direction:      & controller to tool \\
      \hline
       data:           & List(\Id $\times$ Widget) \\
                       & \ Widget = \textit{struct} progress\_bar($\mathbb{N} \times \mathbb{N} \times \mathbb{N}$) $|$
                                                    radio\_button($\String \times \mathbb{B}$) $|$ \\
                       & \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
                                                    button($\String \times \mathbb{B}$) $|$
                                                    checkbox($\String \times \mathbb{B}$) $|$
                                                    label($\String$) $|$
                                                    text\_field($\String$) \\
      \hline
     \end{tabular}
    \end{center}
   \vspace{-0.0cm}
   \end{table}

%   The $box$ and $properties$ elements represent a set of constraints on the
%   relative layout of elements contained in the layout manager (box layout
%   manager in this case). A layout consists of set of nested box elements that
%   contain widgets.  The horizontal or vertical direction of a box layout
%   manager determines the way it lays out the elements it contains above or
%   beside each other respectively. The layout properties further affect layout
%   of elements relative to each other or the containing box. Visibility
%   determines whether a layout element is visible or not. Status determines
%   whether a widget is active, i.e.\  whether it allows user interaction, e.g.\
%   a text field that is disabled is read only for the user. Margins control the
%   distance between the directly adjacent elements.  For first and last
%   elements this means the distance to the borders of the containing box. A box
%   equally divides the amount of available space over the available widgets.
%   When there is plenty of space after deduction of margins the alignment can
%   be used to control either the vertical or horizontal position of a widget
%   within the available space.

   \noindent When a tool receives a display interaction notification it is
   interpreted as a state change of the widgets that matches any of the
   identifiers. Let ($id$, $s$) be a pair of identifier and widget state
   specification. If $id$ does not identify a widget on the display the state
   update represented by the pair is ignored.  If $id$ identifies a widget on
   the display and the type of this widget is not the same as that of $s$ the
   state update is ignored. Otherwise $s$ becomes the new state of the widget
   on the display that is identified by $id$.

%    A tool can change the state of widgets on a display by means of their
%    identifier. The following message must be used for this purpose.

   Initially the display contains no widgets. User interaction without widgets
   is not possible, so display interaction notification messages will not be
   sent by the controller. Similarly display manipulation requests will not be
   sent by a tool and otherwise will be ignored. The figure below shows the
   communication behaviour regarding use of the display facility.

   \begin{figure}[H]
    \begin{center}
     \includegraphics{display.eps}
    \end{center}
    \caption{Communication behaviour with regard to use of the display facility}
    \label{figure:display_manipulation}
    \vspace{-0.0cm}
   \end{figure}

   \noindent A display manipulation command is ignored when the controller
   cannot identify the widget that was targeted or when the state is not a
   valid state description for the targeted widget. The display becomes
   non-empty when a layout change command with a valid non-empty layout
   specification is communicated.  A display interaction notification is
   ignored when the tool cannot identify the widget that was targeted or when
   the state is not a valid state description for the targeted widget.

   \subsubsection*{Widgets and Layouts} \label{subsection:widgets_and_layout}

    The display facility shows an arrangement of widgets with which the user
    can interact, e.g.\ a button. To keep the message structure simple only a
    small set of basic widgets is supported. A very basic relative positioning
    scheme is available for positioning widgets in the available display space.
    As we have seen, altering the contents of the display is only possible by
    substituting one set of widgets and a layout for another.  Furthermore the
    state of widgets can be altered by a tool, their arrangement (their layout)
    is immutable.

    A layout specification subdivides the available space by recursively
    assigning space to so-called layout managers. A \textit{layout manager}
    specifies the way in which elements are laid out across the display. The
    display always contains at least one layout manager, called the \textit{top
    layout manager} that indirectly contains all other elements on the display.
    The top layout manager partitions the available space of the display to its
    child elements. The elements of a layout manager consist of either widgets
    or layout managers that themselves may contain a number of elements.

    The following figure shows an example of how widgets can be laid out
    using nested layout managers.

    \begin{figure}[H]
     \begin{center}
      \includegraphics{example_layout.eps}
     \end{center}
     \caption{Example layout with annotation}
     \label{figure:example_layout}
    \end{figure}

    \noindent The dotted lines in figure \ref{figure:example_layout} mark the
    boundaries of space allocated to different layout managers at the same
    nesting level. A \textit{box layout manager} is a special type of layout
    manager that arranges its child elements on the screen either horizontally,
    or vertically and expands elements (to fill space) in the direction
    perpendicular to the chosen direction.

    Besides the layout managers that distribute available space among widgets
    there are also layout properties for further control over how elements are
    positioned and whether they are visible/hidden and usable
    (mutable/immutable for the end user).  Figure \ref{figure:example_layout}
    also illustrates the use of some of the layout properties.  Element
    visibility determines whether this element is visible or not. The effect
    can can be used to create empty spaces with the dimensions of the invisible
    widgets.  A widget can be enabled or disabled for user interaction. A
    widget is called \textit{active} or \textit{enabled} when the user can
    interact with it, otherwise it is \textit{disabled}. Actual positioning
    properties: alignment, margins (in pixels) one of (top, right, bottom,
    left), vertical alignment (top, middle, bottom), horizontal-alignment
    (left, center, right).

  \subsection{Protocol Extension}

   Protocol extension is supported in the form of adding new message types and
   changing the structure for any of the existing message types. Depending on
   the nature of the changes it is necessary to increase the major or minor
   component of the protocol version tag (as returned after a capabilities
   request).  Backwards incompatible changes require an increase of the major
   component. Naturally the changes to the version number are supposed to make
   it easy to test for additional functionality and/or to implement a fall-back
   mode for compatibility.  Extension to the information exchanged with the
   capabilities facility can be used to provide means and check for even finer
   degrees of compatibility.


 \section{Implementation details} \label{s:protocol_implementation}

   Up until here we have presented only a high level view of the communication
   protocol for controlling tools in our integration framework. This section
   focuses on the implementation details and addresses important design
   decisions.

   Our communication protocol represents an interface between a our rather
   abstract notion of a tool and a tool integration framework. An important
   design goal was to make the use of this interface as simple as possible
   e.g.\ to not restrict its use to specific operating systems or programming
   languages. For implementation we have only looked at established
   inter-process communication mechanisms available as part of standard
   facilities provided by operating systems such as sockets and pipes.  To
   further simplify the use of the interface from other programming languages
   it was decided to create a text-based message format based on XML
   \cite{XML-1_0-4}.

   We decided not to pay to much attention to security aspects.  At the time we
   felt that putting a focus on security would have slowed down the development
   process too much. The main goal has been on getting a proof-of-concept
   implementation of a communication interface on top of which to build the
   \squadt application.

   The OSI model \cite{Day1983} is a popular way of analysing and describing
   communication protocols. Our use of this model only serves to provide a
   frame of reference. The OSI model divides communication into subproblems
   (using seven layers) that can be solved independently. Layers 1 through 5
   represent basic functionality covered by widely available standard
   communication protocols. Those five layers provide a data communication
   connection between applications along which data can be transported.  Our
   communication protocol covers the $6^{th}$ (presentation) layer. The
   integration framework that is used as part of the \squadt application covers
   the $7^{th}$ (application) layer.

  \subsection{Transport} \label{ss:transport}

   For transport of data layers 1 through 5 of the OSI model the Internet (or
   TCP/IP) protocol suite is used (see \cite{rfc793} and \cite{rfc791} for
   TCP(-v4) respectively IP). The TCP/IP protocol provides reliable
   bi-directional order-preserving delivery of a byte stream (layers 1 through
   4 of OSI). TCP/IP also offers session functionality ($5^{th}$ layer OSI) or a
   connection between applications on top of which a messaging context can be
   implemented. As a result one-time tool identification (section
   \ref{s:instance_identification}) is possible, i.e.\ when a new messaging
   context is established. % The use of TCP/IP is widespread and modern
%   operating systems have built-in support. As a result usable from a wide variety of
%   programming languages.

%   An alternative is to use
%   standard input/output streams (or piping).  But the main disadvantage of
%   this facility is that there is not built-in support in many programming
%   languages to do non-blocking communication. This is a strict requirement
%   because of the asynchronous nature of the protocol.  A further disadvantage
%   over TCP/IP is that all communication is limited to the same machine.

%   The TCP/IP protocol suite is chosen as the recommended means of
%   transport. It is well-known and supported by a lot of programming languages.
%   The protocol requires connection-state, a tool is authenticated once and on
%   failure the connection is terminated. In addition, because meaning is
%   assigned to the order of messages, the protocol requires that messages are
%   delivered in the same order as which they were offered to the sender. All
%   requirements are all supported by TCP/IP, note that for UDP/IP this is not
%   the case.

  \subsection{Messaging}

   The presentation layer of the OSI model is about mapping between application
   level concepts (with their own syntax and semantics) and data representation
   in communication (data in messages). The topic of this subsection is the
   representation of the messages presented in section
   \ref{s:high_level_specification} and their interpretation in the domain of the
   application.

%   XMPP has the notion of a message that can be sent from client to client, on
%   top of it our protocol can be implemented.   Unfortunately no single
%   client/server side implementations exist at the time that are usable on all
%   target platforms without also introducing quite a number of other
%   dependencies. Creating our own implementation would have taken to much time,
%   especially when we would have implemented all of XMPP.  So we choose a lightweight
%   custom implementation, instead of using XMPP with 3rd-party client and
%   server implementations.

%   The choice for XML is obvious we aim for extensibility and XML to some
%   extend allows changes to the format extensions to the format there is wide
%   support in many programming languages. With XML it is possible to create a
%   good parser that is to some extent resistant to extensions, meaning it will
%   also work on future versions of the format that may contain additional
%   information.  Another benefit of using XML is it makes the messages
%   readable, making it easy to print and manually verify the structure and
%   contents.

   \subsubsection{Basic Structure: Envelope} \label{ss:structure}

    \noindent Messages are wrapped in the \textit{message} element. A mandatory
    attribute is \textit{type} that specifies the type of the message. The type
    attribute can occur only once and its value must be among those introduced
    in the previous section: \textit{identification}, \textit{capabilities},
    \textit{configuration}, \textit{display\_layout}, \textit{display\_data},
    \textit{termination}, \textit{task},
    \textit{report}. As an example consider the following message with type
    `termination'.

    \begin{verbatim}
     <message type="termination"><![CDATA[message content]]></message>\end{verbatim}

    \noindent The content of a message is wrapped in a so-called CDATA section. The
    contents of a CDATA section is treated as character-only data and not
    parsed as markup. This allows embedding arbitrary character data into XML
    documents. To deal with data that contains fragments that match the
    end-marker \verb']]>', any instance of \verb']]>' in the message content
    \textit{must} be replaced by \verb']]]><![CDATA[]>'.

    \noindent Below the message structure is specified for all the message
    types. Usually the structure of an XML document is specified using XML
    Document Type Definition (\cite{Sperberg-McQueen:06:EML}) or the XML Schema
    standard \cite{Malhotra:06:XSP}. An XML Schema specification for the
    complete set of messages is available but not included. For presentation
    purposes either of the two specification methods is very suboptimal; so we
    use tables to introduce the different elements and their usage constraints.

%  \subsubsection{Authentication}

%   Instead of a full-featured authentication scheme we chose a simple instance
%   identification scheme. Of course security is something that should be part
%   of the design of the protocol. Security is not a main concern, so it is
%   postponed until it can be added as an extension somewhere in the future.

%   The only authentication that is of importance to the functioning of the
%   system that uses the protocol is identifying the peer as one of the tools
%   that was started. For this purpose the instance identification message,
%   described in section \ref{s:instance_identification} was devised. When
%   starting a tool the system must somehow pass the tool a token that can be
%   used later to uniquely identify it.

  \subsubsection{Capabilities}

   Capabilities are exchanged to inform each of the communication partners
   about the precise capabilities of the other. A request for capabilities
   is an empty message of type \textit{capabilities} that looks as follows.

   \small \begin{verbatim}
  <message type="capabilities"></message>\end{verbatim}
  \normalsize

   \noindent Depending on which party sent the request message the response
   message looks different but it carries at least the protocol version. A
   response message as sent by the controller looks as follows:

   \small \begin{verbatim}
  <message type="capabilities">
   <capabilities>
    <protocol-version major="1" minor="0" />
   </capabilities>
  </message>\end{verbatim}
  \normalsize

   \noindent In subsequent examples the message tags will often be omitted if
   the type of the message is clear from the context. The table below describes
   the protocol-version element. All attributes are mandatory except for those
   that are marked with $\sp{*}$.

   \begin{table}[H]
    \begin{center}
    \begin{tabular}{|l|l|}
      \hline
       \multicolumn{2}{|l|}{\textit{element}: protocol-version} \\
      \hline \hline
       \textit{attribute} & \textit{description} \\
      \hline
       major      & integer that represents the major version component \\
       minor      & integer that represents the minor version component \\
      \hline
       \multicolumn{2}{|l|}{\textit{contents}: empty} \\
      \hline
    \end{tabular}
    \end{center}
    \caption{XML element descriptions for protocol version}
   \end{table}

   \noindent Any other child elements of the capabilities element must be
   ignored. The response as sent by a tool looks differently. The capabilities
   element must contain a non-empty set of input-configurations. An
   input-configuration is represented by means of the
   \textit{input-configuration} element.

   \begin{table}[H]
    \begin{center}
    \begin{tabular}{|l|l|}
      \hline
       \multicolumn{2}{|l|}{\textit{element}: input-configuration} \\
      \hline
       \textit{attribute} & \textit{description} \\
      \hline
       category   & short string that specifies a category \\
      \hline
       \multicolumn{2}{|l|}{\textit{contents}: an arbitrary number of object elements} \\
      \hline
        &
        \begin{tabular}[t]{|l|l|}
            \hline
             \multicolumn{2}{|l|}{\textit{element}: object} \\
            \hline
             \textit{attribute} & \textit{description} \\
            \hline
             id         & string without white-space \\
             format     & MIME-type that specifies a storage format \\
            \hline
             \multicolumn{2}{|l|}{\textit{contents}: empty} \\
            \hline
         \end{tabular} \\
      & \\
      \hline
    \end{tabular}
    \end{center}
    \caption{XML element descriptions for input configurations}
   \end{table}

   \noindent As an example consider the following fragment that represents the
   contents of a capabilities response message. As input the tool can take a
   file in the text based format called `mcrl2' and then behaves either as an
   editor or as a visualiser. Alternatively it can also take a file in the
   binary `lps' format and behave as an editor.

   \small \begin{verbatim}
  <capabilities>
   <protocol-version major="1" minor="0" />
   <input-configuration category="editing">
    <object id="mcrl2_in" format="text/mcrl2" />
   </input-configuration>
   <input-configuration category="visualisation">
    <object id="mcrl2_in" format="text/mcrl2" />
   </input-configuration>
   <input-configuration category="editing">
    <object id="lps_in" format="application/lps" />
   </input-configuration>
  </capabilities>\end{verbatim}
  \normalsize

%   \noindent The attribute \textit{category} is mandatory and represents the
%   category of functionality associated with this input configuration. The
%   \textit{input-configuration} section contains an arbitrary amount of
%   \textit{object} sections each representing a source of input. An
%   \textit{object} element has two mandatory attributes: \textit{id} a unique
%   identifier within the scope of an input-configuration section and
%   \textit{format} a MIME-type (see Multipurpose Internet Mail Extensions,
%   \cite{rfc2822}) that specifies the type of the input.

  \subsubsection{Configuration} \label{ss:implementation_configuration}

%   The purpose of a configuration specification is to differentiate between
%   behaviours of a tool in order to allow for selection of behaviour. Depending
%   on the developer of a tool different behaviour can be observed from the
%   outside. It also depends on the developer to what extend this behaviour can
%   be selected before task execution is started.

%   Traditionally most programs with a command line interface take arguments
%   that are used to (re)produce a configured state non-interactively by means
%   of a command which is a single specially formatted string. The model behind
%   this method of expressing a task-specification is based on the idea that
%   tasks consist of a sequence of operations or sub tasks each of which can be
%   parametrised.  A configuration is a selection between available operations
%   and values for the parameters for operations or the combinations thereof. On
%   the command line such a configuration is represented as a string that
%   consists of so-called options followed by values for the arguments of this
%   option. Our approach of expressing a configuration follows the same pattern
%   of options with arguments.

   By design, our integration framework is oblivious to the format of any data
   (as in files) that are produced by connected tools. As noted earlier, the
   reason for this is generality in order not to inhibit applicability of the
   framework for software tools developed elsewhere. There is a critical
   dependency from framework on tool to supply complete information on files
   that have been produced as output and the format of these files. The
   configuration process and the resulting task specifications play a critical
   part in this.

   Task specifications are both the source for dependencies for running tools
   in a project as well as for information about file formats. Initially there
   is no knowledge about any specific data format. MIME-type specifiers
   contained in task specifications provide the necessary information on the
   data format used in output files.  The primary motivation for adopting the
   use of the MIME standard for representing the type of data sources is that
   it contains additional information about what the data represents. When used
   properly it can be used to determine whether the data represents a video
   stream or whether it is stored as text. In addition it gives opportunities
   for interoperability with other software applications such as the use of
   text editors or web-browsers.

   Before looking in detail to the configuration related messages we have a
   quick look at typed arguments to options. The purpose of adding types to
   options is to allow automated sanity checks for checking task
   specifications. When an argument is of type Boolean but it was supposed to
   be an integer this mismatch can be established automatically. The details of
   how the available types are represented are shown below.

   \begin{table}[H]
    \begin{center}
    \begin{tabular}{|l|l|}
      \hline
       \multicolumn{2}{|l|}{\textit{element}: boolean} \\
      \hline
       \multicolumn{2}{|l|}{\textit{contents}: either empty and otherwise `true' or `false'} \\
      \hline
    \end{tabular}
    \begin{tabular}{|l|l|}
      \hline
       \multicolumn{2}{|l|}{\textit{element}: string} \\
      \hline
       \multicolumn{2}{|l|}{\textit{contents}: an arbitrary string} \\
      \hline
    \end{tabular}
    \end{center}
    \vspace{-0.5cm}
    \caption{XML element description: boolean, string}
   \end{table}

   \noindent An empty element e.g.\ \verb'<boolean />' is a place holder for a value of
   the appropriate type. Concrete examples for a Boolean argument are
   \verb'<boolean>false</boolean>' and \verb'<boolean>true</boolean>'. Since
   all values are represented as strings these first two types are not very
   interesting by themselves. Numeric arguments are more interesting and
   expected to occur quite commonly.

   \begin{table}[H]
    \begin{center}
    \begin{tabular}{|l|l|}
      \hline
       \multicolumn{2}{|l|}{\textit{element}: integer-range} \\
      \hline
        \textit{attribute} & \textit{description} \\
      \hline
        minimum & an integer number in decimal notation \\
        maximum & an integer number in decimal notation \\
      \hline
       \multicolumn{2}{|l|}{\textit{contents}: either empty} \\
      \hline
    \end{tabular}
    \begin{tabular}{|l|l|}
      \hline
       \multicolumn{2}{|l|}{\textit{element}: real-range} \\
      \hline
        \textit{attribute} & \textit{description} \\
      \hline
        minimum & a real number in decimal notation \\
        maximum & a real number in decimal notation \\
      \hline
       \multicolumn{2}{|l|}{\textit{contents}: either empty} \\
      \hline
    \end{tabular}
    \end{center}
    \vspace{-0.5cm}
    \caption{XML element description: integer-range, real-range}
   \end{table}

   \noindent Any tool will probably use the finite approximations of the numeric types
   that are supported in hardware. The two supported range types represent
   intervals over the integers and real numbers.

%   Please recall the structure of a configuration request \ref{ss:task_configuration}
   \noindent A configuration request consists of a single configuration section
   from which a task specification can be obtained. A configuration section
   consists of configuration element which has the following properties.

   \begin{table}[H]
    \begin{center}
    \begin{tabular}{|l|l|}
      \hline
       \multicolumn{2}{|l|}{\textit{element}: configuration} \\
      \hline \hline
       \textit{attribute} & \textit{description} \\
      \hline
       interactive$\sp{*}$ & Boolean specifying whether interactive (re)configuration is desired \\
       valid$\sp{*}$       & Boolean specifying whether the contents is a valid task specification \\
       category            & short string that specifies a category \\
      \hline
       \multicolumn{2}{|l|}{\textit{contents}: arbitrary number of option or object elements} \\
      \hline
        &
        \begin{tabular}[t]{|l|l|}
            \hline
             \multicolumn{2}{|l|}{\textit{element}: object} \\
            \hline
             \textit{attribute} & \textit{description} \\
            \hline
             id         & string without white-space \\
             type       & either `input' or `output' \\
             location   & URI that specifies a file in the local filesystem \\
             format     & MIME-type that specifies a storage format \\
            \hline
             \multicolumn{2}{|l|}{\textit{contents}: empty} \\
            \hline
         \end{tabular} \\
        &
        \begin{tabular}[t]{|l|l|}
            \hline
             \multicolumn{2}{|l|}{\textit{element}: option} \\
            \hline
             \textit{attribute} & \textit{description} \\
            \hline
             id         & string without white-space \\
            \hline
             \multicolumn{2}{|l|}{\textit{contents}: any sequence of boolean, integer\_range, real\_range or string} \\
            \hline
         \end{tabular} \\
      & \\
      \hline
    \end{tabular}
    \end{center}
    \caption{XML element description: configuration, object and option}
   \end{table}

   \noindent The object and option elements correspond to sources of
   input/output and options respectively. The sequence of arguments that can be
   specified as children of \textit{option} represent the list of arguments to
   this option.

   The contents of a response message is exactly the same as that of the
   request, with the exception that attribute \textit{valid} is mandatory in a
   response message. The following fragment shows an example configuration
   request, recognisable by the absence of the \textit{valid} attribute.

   \small \begin{verbatim}
  <message type="configuration">
   <configuration interactive="true" category="debugging">
    <option id="-v">
     <integer_range>1</integer_range>
    </option>
    <object id="in" type="input" location="/dev/random" format="application/octet-stream"/>
    <object id="out" type="output" location="/tmp/out" format="application/octet-stream"/>
   </configuration>
  </message>\end{verbatim}
  \normalsize

%   \noindent The \textit{category} attribute is mandatory and should contain a
%   short string that identifies a category that characterises the functionality
%   of the tool that is used when a tool is configured accordingly.  The
%   interactive attribute is optional and signifies a request for user
%   interactive configuration when it is set to `true' . A
%   \textit{configuration} element may contain an arbitrary number of
%   \textit{object} and \textit{option} elements in any order, they represent
%   data sources and options respectively.

%   The \textit{id} attributes of \textit{option} and \textit{object} elements
%   represent the identifiers and all must be unique within the context of a
%   task specification (the containing \textit{configuration} element).  An
%   \textit{object} element must contain the \textit{type} attribute, which
%   specifies whether the tool takes it as input or produces it as output. The
%   \textit{location} attribute must specify a URI (see \cite{rfc3305}), and the
%   \textit{format} attribute contains a data format specifier using the MIME
%   standard.  An \textit{option} element may contain an arbitrary number of
%   \textit{argument} elements that each represent a single typed-argument to
%   the option. A number of predefined types is available for arguments to
%   options: string, integer, natural, positive, real. A configuration response
%   is similar to the request but it has the interactive attribute set to true.

   \noindent A valid (initial) configuration can be obtained from an input
   configuration as follows.  Create an empty \textit{configuration} section
   and add an attribute \textit{interactive} set to true and add the contents
   of an input-configuration section (section
   \ref{ss:implementation_configuration}).

\pagebreak

  \subsubsection{Display}

   Display manipulation is restricted to replacing the entire content of the
   display at once or modifying the state of individual widgets on the display.
   In particular it is not possible to manipulate the layout itself. More
   complete manipulation capabilities rapidly increase complexity. A
   conservative approach was chosen to keep initial complexity low and save on
   development time.

   A small set of graphical user interface components (widgets) is available
   for tool developers to choose from for constructing display layouts. The
   downside of this limited choice is that a tool developer has little choice
   for constructing a graphical user interface using the display facility.
   Nevertheless layout construction and manipulation are by far the most
   complex functionality the protocol currently has to offer.  Should the need
   arise, adding new widgets should be easy, however the protocol will have to
   be refined in order to realise this.

   \paragraph{Widgets}

    We assume that the reader is familiar with the purpose and basic functions
    of each of the widgets presented earlier. Nowadays the use of graphical
    user interfaces is ubiquitous. The name and function of widgets we use and
    the way in which widgets are put together in a layout are based on concepts
    and terminology used in Java Swing.

    Every widget has a mandatory \textit{id} attribute that must be unique
    within the scope of the containing \textit{display-layout} section
    (introduced shortly). The following two tables specify the XML elements
    that correspond with a label and button.

    \begin{table}[H]
     \begin{center}
     \begin{tabular}{|l|l|}
       \hline
        \multicolumn{2}{|l|}{\textit{element}: label} \\
       \hline \hline
        \textit{attribute} & \textit{description} \\
       \hline
        id                 & mandatory identifier \\
       \hline \hline
        \multicolumn{2}{|l|}{\textit{contents}: text-only} \\
       \hline
         \multicolumn{2}{|l|}{The text for the label.} \\
       \hline
     \end{tabular}
     \begin{tabular}{|l|l|}
       \hline
        \multicolumn{2}{|l|}{\textit{element}: button} \\
       \hline \hline
        \textit{attribute} & \textit{description} \\
       \hline
        id                 & mandatory identifier \\
       \hline \hline
        \multicolumn{2}{|l|}{\textit{contents}: text-only} \\
       \hline
         \multicolumn{2}{|l|}{The text on the button.} \\
       \hline
     \end{tabular}
     \end{center}
     \caption{XML element descriptions for label (left) and button (right)}
    \end{table}

    \noindent As an example consider the following XML fragment that describes
    a label, a button and a checkbox (see table \ref{figure:element_checkbox}) all
    with with text ``Cancel''.
    \small \begin{verbatim}
  <label id="x"><![CDATA[Cancel]]></label>
  <button id="y"><![CDATA[Cancel]]></button>
  <checkbox id="z" checked="true"><![CDATA[Cancel]]></checkbox>\end{verbatim}
  \normalsize
    Notice how the id attribute is unique for all the elements. This to be the
    case for all widget elements in every layout specification. When a button
    is pressed, or a checkbox is toggled this fact is communicated by sending a
    \msg{display\_data} message. The contents of this message is the complete
    widget specification.

    A more interesting widget is the checkbox. The checkbox has a description
    and is always in one of two states: checked or not.

    \begin{table}[H]
     \begin{center}
     \begin{tabular}{|l|l|}
       \hline
        \multicolumn{2}{|l|}{\textit{element}: checkbox} \\
       \hline \hline
        \textit{attribute} & \textit{description} \\
       \hline
        id                 & mandatory identifier \\
        checked            & optional Boolean argument for presence of tick mark \\
       \hline \hline
        \multicolumn{2}{|l|}{\textit{contents}: text-only} \\
       \hline
         \multicolumn{2}{|l|}{The text for a label that accompanies the checkbox.} \\
       \hline
     \end{tabular}
     \end{center}
     \label{figure:element_checkbox}
     \caption{XML element description for checkbox}
    \end{table}

    \noindent The radio button widget is a more complex entity, because it is
    not a stand-alone widget. Radio buttons are always grouped and only a
    single button in the group is selected (pressed).  By default the radio
    button in a group is selected that is found the highest (textually) in a
    layout specification. A radio button element is specified as follows.

    \begin{table}[H]
     \begin{center}
     \begin{tabular}{|l|l|}
       \hline
        \multicolumn{2}{|l|}{\textit{element}: radio-button} \\
       \hline \hline
        \textit{attribute} & \textit{description} \\
       \hline
        id                 & mandatory identifier \\
        connected          & matches the \textbf{id} attribute of another radio button element \\
        selected           & optional Boolean attribute that represents whether the radio button is checked \\
       \hline \hline
        \multicolumn{2}{|l|}{\textit{contents}: text-only} \\
       \hline
         \multicolumn{2}{|l|}{The text for a label that accompanies the radio button.} \\
       \hline
     \end{tabular}
     \end{center}
     \label{figure:element_radio_button}
     \caption{XML element description for radio-button}
    \end{table}

   \noindent The \textit{select} attribute can be used to select a different button. A
   radio button group is formed by means of the connected attributes in all of
   the radio buttons in the group. Every \textit{connected} attribute
   identifies another radio button in the group, within a group the \textit{id}
   of every radio button occurs exactly once as value of a \textit{connected}
   attribute.  Every radio button in the group can be found by repeatedly
   following the \textit{connected} attribute to find the connected
   radio-button by its identifier. If the selection changes then only the
   specification of the radio button that gets selected must be sent by means
   of a \msg{display\_data} message to inform the other side of this event.
   Such an update message could look as follows:

    \small \begin{verbatim}
  <radio-button id="y" connected="x" selected="true"><![CDATA[second]]></radio-button>\end{verbatim}
  \normalsize

   \noindent A text field displays an input widget for the user to input text.
   A specification of the text-field element:

    \begin{table}[H]
     \begin{center}
     \begin{tabular}{|l|l|}
       \hline
        \multicolumn{2}{|l|}{\textit{element}: text-field} \\
       \hline \hline
        \textit{attribute} & \textit{description} \\
       \hline
        id                 & mandatory identifier \\
       \hline \hline
        \multicolumn{2}{|l|}{\textit{contents}: text-only} \\
       \hline
         \multicolumn{2}{|l|}{The initial text for the text field.} \\
       \hline
     \end{tabular}
     \end{center}
     \label{figure:element_text_field}
     \caption{XML element description for text-field}
    \end{table}

%   \small \begin{verbatim}
%  <text-field id="x"><text><![CDATA[100]]><text></text-field>\end{verbatim}
%  \normalsize

%   Input validation may be added in the future. The framework then has the means
%   to check and inform the user whether the data entered by the user matches
%   the expectations of the tool developer.  For example if the input box should
%   contain a number then it can be automatically checked to not contain
%   non-digit characters.

   \noindent The progress bar is used to show progress to a user. It models progress by
   means of a sub range of the integer domain, specified by a minimum and
   maximum value and shows progress by colouring part of this domain up to some
   `current' value that \emph{must} be in the domain $[ minimum \ldots maximum
   ]$. The element looks as follows

    \begin{table}[H]
     \begin{center}
     \begin{tabular}{|l|l|}
       \hline
        \multicolumn{2}{|l|}{\textit{element}: progress-bar} \\
       \hline \hline
        \textit{attribute} & \textit{description} \\
       \hline
        id                 & identifier \\
        minimum            & the minimum, integer value \\
        maximum            & the maximum, integer value \\
        current            & current state of progress as an integer value in range [minimum,maximum]  \\
       \hline \hline
        \multicolumn{2}{|l|}{\textit{contents}: empty} \\
       \hline
     \end{tabular}
     \end{center}
     \label{figure:element_progress_bar}
     \caption{XML element description for progress-bar}
    \end{table}

%   \small \begin{verbatim}
%  <progress-bar id="x" minimum="10" maximum="20" current="15"/>\end{verbatim}
%  \normalsize
%
   \noindent Updates to the state of a widget are specified in the same way as
   in the layout specification. The \textit{id} attribute identifies the
   widget of which the state is to be updated. The attributes then specify the
   new value for the attribute with the same name and child elements specify
   other aspects of the state. When attributes are missing, their value remains
   unchanged.

   \paragraph{Layout}

   A display layout specification is represented by a \textit{display-layout}
   element that contains a single \textit{layout-manager} element, the top
   layout manager.

   \small \begin{verbatim}
  <display-layout>
   <layout-manager>
    <box-layout-manager variant="vertical" id="x">
     ...
    </box-layout-manager>
   </layout-manager>
  </display-layout>\end{verbatim}
  \normalsize

   \noindent The \textit{box-layout-manager} has a \textit{variant} attribute that
   specifies the direction in which the elements directly contained in it are
   laid out on the available space. Every child element is associated with a
   value for each of the available layout properties. An implicit set of
   default values is assumed that can be used to reduce specification size.
   The default properties are as follows: alignment is left, no margins,
   elements are enabled and visible. The effective properties of an element are
   relative to that of the previous child. For example:

   \small \begin{verbatim}
 <box-layout-manager variant="vertical" id="">
  <properties margin-top="1" margin-bottom="1" horizontal-alignment="right" />
  <button><![CDATA[Ok]]></button>
  <properties />
  <button><![CDATA[Cancel]]></button>
 </box-layout-manager>\end{verbatim}
 \normalsize

   \noindent The layout properties for both buttons are the same, top and bottom margins
   are one pixel, vertical alignment is middle and horizontal alignment is
   right and both elements are visible and enabled. The \textit{properties}
   element directly preceding a widget specifies the layout
   constraints/properties for that widget. When there is no properties element
   (or it is empty) then the last specified values for each of the properties
   are in effect.

   As a non contrived example there is a complete listing of the XML
   specification that can be used to generate a layout similar to the one
   depicted in figure \ref{figure:example_layout} is given in appendix
   \ref{figure:example_layout_listing}.

%   Pay careful attention to the use of properties for controlling margins and
%   alignment. Especially the default values of attributes relative to the
%   previous \textit{properties} element.

  \section{Comparison}

   How does our approach measure up to other approaches to tool integration?  In
   Eucalyptus, the graphical front-end to CADP, detailed knowledge about the
   capabilities of individual tools as well as file formats seems to be
   integrated. Such coupling is very tight and limits its applicability. For
   \squadt we set the target higher. We have chosen to avoid building in
   knowledge about particular tools or even file formats.

   Other approaches we know of are the electronic tool integration platform
   (ETI) \cite{RICVT} and repository (\cite{SFAV}). Both are built around
   web-services technology (using SOAP \cite{SOAP} and WSDL \cite{2001-WSDL}).
   The tools either are a web service or wrapped inside a web service which
   allows loosely connect tools in a way very similar to ours. In ETI a tool
   can be connected by means of filling in a web-form that generates an XML
   file that represents the tools' interface.  This is very similar to the XML
   formatted message on tools capabilities. Connected tools are aware of the
   integration context and ETI offers facilities that are usable to tools via
   Java-specific remote procedure calls.

   Repository also uses web-services but in contrast to ETI, the connection
   between tool and framework is through specialised scripts. This puts it
   somewhere in between Eucalyptus and ETI. The tools are not aware of the
   integration context so a script is needed to make a tool behave properly in
   the integration context.

   For all of the above approaches it seems that tools communicate through
   files.  A serious consideration on our side was that files could grow very
   big and that you do not want to copy those files unnecessarily across a
   network. This does not necessarily preclude the use of web-services as
   interface between tools and an integration framework; but it does not make
   it the most logical candidate either. Truthfully the use of web-services was
   not considered until a protocol implementation was already available.

%  \section{Afterthoughts}
%
%   After work had started on implementation our XML-based communication protocol called
%   XMPP core came into view.  Quickly summarised: it is a relatively compact open
%   communication protocol that that relies on TCP/IP to transport two XML
%   streams (one for each direction), also see \cite{Sperberg-McQueen:06:EML}.
%   At some point XMPP core (Extensible Messaging and Presence Protocol,
%   \cite{rfc3920}) even became an official standard. This protocol offers basic
%   messaging functionality including a request-response and publish-subscribe
%   mechanisms.
%
%   Our protocol is tailored to our specific needs but at the core it is very
%   similar to XMPP core. When a decent multi-platform implementation framework
%   would have been available we would have liked to have built our protocol top
%   of XMPP core. It seems to be a very good match and could have saved a lot of
%   development work.

  \enlargethispage*{4pt}
  \bibliography{protocol}

  \appendix
  \section{Appendix}
  \pagestyle{empty}

  \subsection{Behavioural model}
   The following listing shows an mCRL2 model of the combined communication
   behaviour of the protocol. Besides communication tool start and termination
   only communications actions are visible. The model features a single
   controller and a single tool.

  \small \verbatiminput{protocol.mcrl2} \normalsize
%  \rotatebox{90}{\verbatiminput{protocol.mcrl2}}
   Message content is abstracted to that portion that is relevant for
   communication. In this way we distinguished three classes of messages, those
   with empty contents, those with a true/false result and all of the others.
   For example, requests characterised by the message type and empty
   contents.

  \pagebreak

  \subsection{Graphical Representation of Communication Behaviour}

   The following figure shows a graphical representation of the communication
   behaviour using the mCRL2 model presented previously. For presentation
   purposes the communication actions have been replaced by the names of the
   message they communicate.  The picture was generated with the ltsgraph tool
   after instantiating the state-space and and minimising modulo
   branching-bisimulation. The final result took some manual polishing.

  \begin{figure}[H]
   \includegraphics[width=\textwidth]{protocol.eps}
   \caption{Graphical representation of the state-space}
  \end{figure}

   \noindent The constraints as they are found in section
   \ref{s:high_level_specification} together make up the behaviour depicted
   above. What is visible is the intended pattern of communication. A protocol
   implementation must abort with an error condition for message sequences
   outside those allowed by the model.

  \pagebreak

  \subsection{Example Layout} \label{figure:example_layout_listing}
  Below is a listing for the layout graphically depicted in figure
  \ref{figure:example_layout}.

  \begin{figure}[H]
   \small \begin{verbatim}
 <display-layout>
  <layout-manager>
   <box-layout-manager variant="horizontal" id="top">
    <box-layout-manager variant="vertical" id="top_top">
     <box-layout-manager variant="vertical" id="top_top_left">
      <properties margin-left="5" margin-top="10">
      <label id="alabel"><![CDATA[This is a label]]></label>
     </box-layout-manager>
     <box-layout-manager variant="vertical" id="top_top_right">
      <properties margin-left="0" margin-top="0" horizontal-alignment="center">
      <box-layout-manager variant="vertical" id="top_top_right_top">
       <properties horizontal-alignment="center">
       <button id="abutton"><![CDATA[B Button]]></button>
      </box-layout-manager>
      <box-layout-manager variant="vertical" id="top_top_right_bottom">
       <properties horizontal-alignment="left">
       <button id="abutton"><![CDATA[A Button]]></button>
      </box-layout-manager>
     </box-layout-manager>
    </box-layout-manager>
    <box-layout-manager variant="vertical" id="top_bottom">
     <properties horizontal-alignment="center">
     <progress-bar id="progress" minimum="0" maximum="1000" current="350" />
    </box-layout-manager>
   </box-layout-manager>
  </layout-manager>
 </display-layout>\end{verbatim}
  \normalsize
  \end{figure}

%  \subsection{XML Schema for Messages}
%  \label{subsection:xml_schema_messages}

%  A formal specification of the syntax of messages is given by the following
%  XML schema listing. The main element is a message with a mandatory attribute
%  type. The value of the message type attribute determines the contents of the
%  message.

%  \small \verbatiminput{protocol.xsd} \normalsize

%   The purpose of the protocol is make it possible for a user to control of a
%   tool through facilities offered by a separate system that acts as
%   intermediary. The protocol describes how a tool can be configured to perform
%   a task, how it can be made to perform this task and report the results.  A
%   task specification comes into being by interaction with the user through the
%   system. The protocol describes this process.  The most important
%   functionality offered by the protocol is repeatability of the configuration
%   process based on a previous configuration.

%   The deskSQuADT application currently uses the protocol as its only method
%   for controlling tools. The most important features provided by the current
%   version are:
%    \begin{itemize}
%     \item dependencies generated by application of tools on files are
%     visualised
%     \item change propagation through (semi-)automated task execution for
%     repeating tasks; changes in input are detected and tools are re-executed
%     on request to ensure up-to-date outputs
%     \item data consistency is guarded by avoiding concurrent execution of
%     tasks that share inputs or outputs
%    \end{itemize}
%   All of these features are the result of functionality purposefully built
%   into the protocol.

%   Experience so far has told us that the current ability to fill and
%   manipulate the display is rather limited. Interaction with the user would
%   improve with a broader choice in controls and more fine-grained control over
%   the layout. A good example of useful additional control over layout would be
%   hiding or disabling controls in a layout when they are not needed.

%   Since the decision was made to create a custom implementation for the
%   protocol, see section \ref{s:protocol_implementation}, the XMPP protocol has
%   been formalised by the Internet Engineering Task Force (IETF). This means it
%   is now an open Internet standard. Because he notion of a message is
%   approximately the same for the protocols, It was (and remains) an option to
%   use our protocol on top of XMPP.

%   It is still interesting to consider implementing this protocol on top of
%   XMPP. The latter has additional functionality that can be used to help solve
%   other tool integration problems. An example of this is active communication
%   between multiple tools through a publish-subscribe mechanism.  A future
%   extension to the protocol or perhaps even another protocol can offer such
%   functionality.

\end{document}
