import path ;
import modules ;
import feature : feature ;
import os : name ;

path-constant TOP             : . ;
path-constant BUILD_TOP       : ./bin ;
path-constant BOOST           : ./boost ;
path-constant REVISION_HEADER : ./src/mcrl2_revision.h ;

if ! [ path.exists $(TOP)/config.jam ] {
  ECHO "Please configure your source tree!" ;

  exit ;
}

include $(TOP)/config.jam ;

project
       : build-dir $(BUILD_TOP)
       : requirements
          <cxxflags>-std=c++98
          <define>_FILE_OFFSET_BITS=64
          <toolset>darwin:<linkflags>"-undefined dynamic_lookup"
       : default-build
          <address-model>$(ADDRESS_MODEL)
          <variant>$(BUILD_VARIANT)
       ;

# The known sub projects
use-project /root                      : . ;
use-project /libraries/md5pp           : src/squadt/libraries/md5pp/build ;
use-project /libraries/transport       : src/squadt/libraries/transport/build ;
use-project /libraries/sip             : src/squadt/libraries/sip/build ;
use-project /libraries/xml2pp          : src/squadt/libraries/xml2pp/build ;
use-project /boost/program_options     : boost/libs/program_options/build ;
use-project /boost/filesystem          : boost/libs/filesystem/build ;
use-project /boost/thread              : boost/libs/thread/build ;

# The SVN revision number with which tools will be tagged
if [ path.exists $(TOP)/utility/revision.jam ] {
  include $(TOP)/utility/revision.jam ; 

  make $(REVISION_HEADER)
       : maximum_revision
       : run_maximum_revision
       ;
}

alias mcrl2_revision
       : $(REVISION_HEADER)
       ;

tools = [ MATCH src/(.*)/.* : [ glob src/*/Jamfile.v2 src/*/build/Jamfile.v2 ] ] ;

# Register tool projects
for tool in $(tools) {
  # Make tool project known under a nice name
  use-project /tools/$(tool) : src/$(tool) ;

  # Build by default
  build-project src/$(tool) ;
}

libraries = [ MATCH src/libraries/(.*)/build/.* : [ glob src/libraries/*/build/Jamfile.v2 ] ] ;

# Register library projects
for library in $(libraries) {
  # Make tool project known under a nice name
  use-project /libraries/$(library) : src/libraries/$(library)/build ;
}

# Feature to mark tools as experimental
feature tool_type : basic experimental : optional incidental ;

feature squadt_support : disable enable : composite optional incidental ;

feature.compose <squadt_support>enable
      : <define>ENABLE_SQUADT_CONNECTIVITY
        <library>/libraries/sip//sipt
      ;

# Feature for linking to the xml2 library
feature xml2 : none interface library : composite incidental link-incompatible ;

feature.compose <xml2>interface
      : <cxxflags>"$(XML2_CPPFLAGS)"
      ;
feature.compose <xml2>library
      : <linkflags>"$(XML2_LDFLAGS)"
        <cxxflags>"$(XML2_CPPFLAGS)"
      ;

# Feature for linking to wx widget libraries
feature wx : none interface basic gl : composite incidental link-incompatible ;

feature.compose <wx>interface
      : <cxxflags>"$(WX_CPPFLAGS)"
      ;
feature.compose <wx>basic
      : <linkflags>"$(WX_BASE_LDFLAGS)"
        <cxxflags>"$(WX_CPPFLAGS)"
      ;
feature.compose <wx>gl
      : <linkflags>"$(WX_GL_LDFLAGS)"
        <cxxflags>"$(WX_CPPFLAGS)"
      ;

# OpenGL, GLU and GLUT libraries names
rule import_libraries {
  switch [ os.name ] {
    case "NT" :
      lib OpenGL : : <name>"opengl32" ;
      lib GLU    : OpenGL : <name>"glu32" ;
      lib GLUT   : OpenGL : <name>"glut32" ;
    case "MACOSX" :
      alias OpenGL : : : : <framework>"OpenGL" ;
      alias GLUT   : OpenGL : : : <framework>"GLUT" ;
      alias GLU    : OpenGL : : : ;
    case * :
      lib OpenGL : : <name>"GL" ;
      lib GLU    : OpenGL : <name>"GLU" ;
      lib GLUT   : OpenGL : <name>"glut" ;
  }

  lib z  : : <name>"z" ;

  lib m  : : <name>"m" ;

  lib dl : : <name>"dl" ;

  lib xml2
        :
        : <name>"xml2"
        :
        : <cxxflags>"$(XML2_CPPFLAGS)"
          <library>z
          <library>m
        ;
}

# Install when requested
if install in [ MATCH "^--(install)" "^(install)" : [ modules.peek : ARGV ] ] {

  # Custom rule to install a tool executable with the libraries it depends on
  rule install_with_libraries ( tool * : property * ) {

    alias install
          : install-libraries
            install-binaries
          : $(property)
          ;
 
    install install-binaries
          : $(tool)
          : <dll-path>$(LIB_DIR)
            <location>$(BIN_DIR)
          ;
 
    install install-libraries
          : $(tool)
          : <install-dependencies>on <install-type>SHARED_LIB
          : <location>$(LIB_DIR)
          ;
 
    explicit install install-binaries install-libraries ;
  }

  rule install_data ( name : files * : directories ? ) {

    target = [ path.join $(DATA_DIR) $(directories) ] ;

    install $(name)
          : $(files)
          : <location>$(target)
          ;
  }

  alias install-tools
       : /tools/$(tools)//install
       ;

  extensions = mcrl2 pnml fsm ;

  # Install examples
  install examples
       : [ glob ./examples/*.$(extensions) ./examples/*/*.$(extensions) ./examples/*/*/*.$(extensions) ]
       : <location>$(DATA_DIR)
         <install-source-root>.
       ;
}
else {
  # Dummy rule
  rule install_with_libraries ( tool * : property * ) {
  }

  # Dummy rule
  rule install_data ( name : files * : directories ? ) {
  }
}
