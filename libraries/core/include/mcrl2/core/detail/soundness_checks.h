// Author(s): Wieger Wesselink
// Copyright: see the accompanying file COPYING or copy at
// https://github.com/mCRL2org/mCRL2/blob/master/COPYING
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
/// \file mcrl2/core/detail/soundness_checks.h
/// \brief Add your file description here.

#ifndef MCRL2_CORE_DETAIL_SOUNDNESS_CHECKS_H
#define MCRL2_CORE_DETAIL_SOUNDNESS_CHECKS_H

// This file contains soundness checks for LPS terms.
// N.B. This file is automatically generated!

#include "mcrl2/atermpp/concepts.h"
#include "mcrl2/atermpp/aterm_string.h"
#include "mcrl2/core/detail/function_symbols.h"

namespace mcrl2
{

namespace core
{

namespace detail
{

// checks
// 1) if term t satisfies the predicate f
template <atermpp::IsATerm Term, typename CheckFunction>
bool check_term_argument(const Term& t, CheckFunction f)
{
  return f(t);
}

// checks
// 1) if term t is a list,
// 2) if the list has the proper minimum size
// 3) if all elements of the list satisfy the predicate f
template <atermpp::IsATerm Term, typename CheckFunction>
bool check_list_argument(const Term& t, CheckFunction f, unsigned int minimum_size)
{
  const atermpp::aterm& term(t);
  if (!t.type_is_list())
  {
    return false;
  }
  const atermpp::aterm_list& l = atermpp::down_cast<atermpp::aterm_list>(term);
  if (l.size() < minimum_size)
  {
    return false;
  }
  for (const auto& x: l)
  {
    if (!f(x))
    {
      return false;
    }
  }
  return true;
}

template <atermpp::IsATerm Term>
bool check_rule_String(const Term& t)
{
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.size() > 0)
  {
    return false;
  }
  if (term == atermpp::empty_string())
  {
    return false;
  }
  return true;
}

template <atermpp::IsATerm Term>
bool check_rule_StringOrEmpty(const Term& t)
{
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  return term.size() <= 0;
}

template <atermpp::IsATerm Term>
bool check_rule_Number(const Term& t)
{
  const atermpp::aterm& term(t);
  return term.type_is_int();
}

template <atermpp::IsATerm Term> bool check_rule_DataExpr(const Term& t);

// DataAppl(DataExpr, DataExpr+)
template <atermpp::IsATerm Term>
bool check_term_DataAppl(const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (term.type_is_int())
  {
    return true;
  }
  if (!term.type_is_appl())
  {
    return false;
  }
  if (!gsIsDataAppl(term))
  {
    return false;
  }
#ifndef LPS_NO_RECURSIVE_SOUNDNESS_CHECKS
  for (const atermpp::aterm& child : term)
  {
    if (!check_term_argument(child, check_rule_DataExpr<atermpp::aterm>))
    {
      mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
      return false;
    }
  }
#endif // LPS_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

//--- start generated code ---//
template <atermpp::IsATerm Term> bool check_rule_SortExpr(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_SortId(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_SortConsType(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_StructCons(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_StructProj(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_DataExpr(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_DataVarId(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_OpId(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_UntypedDataParameter(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_BindingOperator(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_WhrDecl(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_DataVarIdInit(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_UntypedIdentifierAssignment(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_DataSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_SortSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_ConsSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_MapSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_DataEqnSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_SortDecl(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_DataEqn(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_MultAct(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_TimedMultAct(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_UntypedMultiAction(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_Action(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_ActId(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_ProcExpr(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_ProcVarId(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_MultActName(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_RenameExpr(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_CommExpr(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_ProcSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_ActSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_GlobVarSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_ProcEqnSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_ProcEqn(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_MultActOrDelta(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_ProcInit(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_Distribution(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_LinProcSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_LinearProcess(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_LinearProcessSummand(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_LinearProcessInit(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_StateFrm(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_RegFrm(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_ActFrm(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_ParamIdOrAction(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_ActionRenameRules(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_ActionRenameRule(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_ActionRenameRuleRHS(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_ActionRenameSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_PBES(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_PBEqnSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_PBInit(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_PBEqn(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_FixPoint(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_PropVarDecl(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_PBExpr(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_PropVarInst(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_PRES(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_PREqnSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_PRInit(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_PREqn(const Term& t);
template <atermpp::IsATerm Term> bool check_rule_PRExpr(const Term& t);
template <atermpp::IsATerm Term> bool check_term_SortCons(const Term& t);
template <atermpp::IsATerm Term> bool check_term_SortStruct(const Term& t);
template <atermpp::IsATerm Term> bool check_term_SortArrow(const Term& t);
template <atermpp::IsATerm Term> bool check_term_UntypedSortUnknown(const Term& t);
template <atermpp::IsATerm Term> bool check_term_UntypedSortsPossible(const Term& t);
template <atermpp::IsATerm Term> bool check_term_UntypedSortVariable(const Term& t);
template <atermpp::IsATerm Term> bool check_term_SortId(const Term& t);
template <atermpp::IsATerm Term> bool check_term_SortList(const Term& t);
template <atermpp::IsATerm Term> bool check_term_SortSet(const Term& t);
template <atermpp::IsATerm Term> bool check_term_SortBag(const Term& t);
template <atermpp::IsATerm Term> bool check_term_SortFSet(const Term& t);
template <atermpp::IsATerm Term> bool check_term_SortFBag(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StructCons(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StructProj(const Term& t);
template <atermpp::IsATerm Term> bool check_term_Binder(const Term& t);
template <atermpp::IsATerm Term> bool check_term_Whr(const Term& t);
template <atermpp::IsATerm Term> bool check_term_UntypedIdentifier(const Term& t);
template <atermpp::IsATerm Term> bool check_term_DataVarId(const Term& t);
template <atermpp::IsATerm Term> bool check_term_OpId(const Term& t);
template <atermpp::IsATerm Term> bool check_term_UntypedDataParameter(const Term& t);
template <atermpp::IsATerm Term> bool check_term_Forall(const Term& t);
template <atermpp::IsATerm Term> bool check_term_Exists(const Term& t);
template <atermpp::IsATerm Term> bool check_term_SetComp(const Term& t);
template <atermpp::IsATerm Term> bool check_term_BagComp(const Term& t);
template <atermpp::IsATerm Term> bool check_term_Lambda(const Term& t);
template <atermpp::IsATerm Term> bool check_term_UntypedSetBagComp(const Term& t);
template <atermpp::IsATerm Term> bool check_term_DataVarIdInit(const Term& t);
template <atermpp::IsATerm Term> bool check_term_UntypedIdentifierAssignment(const Term& t);
template <atermpp::IsATerm Term> bool check_term_DataSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_term_SortSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_term_ConsSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_term_MapSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_term_DataEqnSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_term_SortRef(const Term& t);
template <atermpp::IsATerm Term> bool check_term_DataEqn(const Term& t);
template <atermpp::IsATerm Term> bool check_term_MultAct(const Term& t);
template <atermpp::IsATerm Term> bool check_term_TimedMultAct(const Term& t);
template <atermpp::IsATerm Term> bool check_term_UntypedMultiAction(const Term& t);
template <atermpp::IsATerm Term> bool check_term_Action(const Term& t);
template <atermpp::IsATerm Term> bool check_term_ActId(const Term& t);
template <atermpp::IsATerm Term> bool check_term_Process(const Term& t);
template <atermpp::IsATerm Term> bool check_term_ProcessAssignment(const Term& t);
template <atermpp::IsATerm Term> bool check_term_Delta(const Term& t);
template <atermpp::IsATerm Term> bool check_term_Tau(const Term& t);
template <atermpp::IsATerm Term> bool check_term_Sum(const Term& t);
template <atermpp::IsATerm Term> bool check_term_Block(const Term& t);
template <atermpp::IsATerm Term> bool check_term_Hide(const Term& t);
template <atermpp::IsATerm Term> bool check_term_Rename(const Term& t);
template <atermpp::IsATerm Term> bool check_term_Comm(const Term& t);
template <atermpp::IsATerm Term> bool check_term_Allow(const Term& t);
template <atermpp::IsATerm Term> bool check_term_Sync(const Term& t);
template <atermpp::IsATerm Term> bool check_term_AtTime(const Term& t);
template <atermpp::IsATerm Term> bool check_term_Seq(const Term& t);
template <atermpp::IsATerm Term> bool check_term_IfThen(const Term& t);
template <atermpp::IsATerm Term> bool check_term_IfThenElse(const Term& t);
template <atermpp::IsATerm Term> bool check_term_BInit(const Term& t);
template <atermpp::IsATerm Term> bool check_term_Merge(const Term& t);
template <atermpp::IsATerm Term> bool check_term_LMerge(const Term& t);
template <atermpp::IsATerm Term> bool check_term_Choice(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StochasticOperator(const Term& t);
template <atermpp::IsATerm Term> bool check_term_UntypedProcessAssignment(const Term& t);
template <atermpp::IsATerm Term> bool check_term_ProcVarId(const Term& t);
template <atermpp::IsATerm Term> bool check_term_MultActName(const Term& t);
template <atermpp::IsATerm Term> bool check_term_RenameExpr(const Term& t);
template <atermpp::IsATerm Term> bool check_term_CommExpr(const Term& t);
template <atermpp::IsATerm Term> bool check_term_ProcSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_term_ActSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_term_GlobVarSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_term_ProcEqnSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_term_ProcEqn(const Term& t);
template <atermpp::IsATerm Term> bool check_term_ProcessInit(const Term& t);
template <atermpp::IsATerm Term> bool check_term_Distribution(const Term& t);
template <atermpp::IsATerm Term> bool check_term_LinProcSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_term_LinearProcess(const Term& t);
template <atermpp::IsATerm Term> bool check_term_LinearProcessSummand(const Term& t);
template <atermpp::IsATerm Term> bool check_term_LinearProcessInit(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StateTrue(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StateFalse(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StateNot(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StateMinus(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StateAnd(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StateOr(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StateImp(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StatePlus(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StateConstantMultiply(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StateConstantMultiplyAlt(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StateForall(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StateExists(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StateInfimum(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StateSupremum(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StateSum(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StateMust(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StateMay(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StateYaled(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StateYaledTimed(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StateDelay(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StateDelayTimed(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StateVar(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StateNu(const Term& t);
template <atermpp::IsATerm Term> bool check_term_StateMu(const Term& t);
template <atermpp::IsATerm Term> bool check_term_RegNil(const Term& t);
template <atermpp::IsATerm Term> bool check_term_RegSeq(const Term& t);
template <atermpp::IsATerm Term> bool check_term_RegAlt(const Term& t);
template <atermpp::IsATerm Term> bool check_term_RegTrans(const Term& t);
template <atermpp::IsATerm Term> bool check_term_RegTransOrNil(const Term& t);
template <atermpp::IsATerm Term> bool check_term_UntypedRegFrm(const Term& t);
template <atermpp::IsATerm Term> bool check_term_ActTrue(const Term& t);
template <atermpp::IsATerm Term> bool check_term_ActFalse(const Term& t);
template <atermpp::IsATerm Term> bool check_term_ActNot(const Term& t);
template <atermpp::IsATerm Term> bool check_term_ActAnd(const Term& t);
template <atermpp::IsATerm Term> bool check_term_ActOr(const Term& t);
template <atermpp::IsATerm Term> bool check_term_ActImp(const Term& t);
template <atermpp::IsATerm Term> bool check_term_ActForall(const Term& t);
template <atermpp::IsATerm Term> bool check_term_ActExists(const Term& t);
template <atermpp::IsATerm Term> bool check_term_ActAt(const Term& t);
template <atermpp::IsATerm Term> bool check_term_ActMultAct(const Term& t);
template <atermpp::IsATerm Term> bool check_term_ActionRenameRules(const Term& t);
template <atermpp::IsATerm Term> bool check_term_ActionRenameRule(const Term& t);
template <atermpp::IsATerm Term> bool check_term_ActionRenameSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PBES(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PBEqnSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PBInit(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PBEqn(const Term& t);
template <atermpp::IsATerm Term> bool check_term_Mu(const Term& t);
template <atermpp::IsATerm Term> bool check_term_Nu(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PropVarDecl(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PBESTrue(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PBESFalse(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PBESNot(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PBESAnd(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PBESOr(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PBESImp(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PBESForall(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PBESExists(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PropVarInst(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PRES(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PREqnSpec(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PRInit(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PREqn(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PRESTrue(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PRESFalse(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PRESMinus(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PRESAnd(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PRESOr(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PRESImp(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PRESPlus(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PRESConstantMultiply(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PRESConstantMultiplyAlt(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PRESInfimum(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PRESSupremum(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PRESSum(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PRESEqInf(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PRESEqNInf(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PRESCondSm(const Term& t);
template <atermpp::IsATerm Term> bool check_term_PRESCondEq(const Term& t);

template <atermpp::IsATerm Term>
bool check_rule_SortExpr([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_rule_SortId(t)
         || check_term_SortCons(t)
         || check_term_SortStruct(t)
         || check_term_SortArrow(t)
         || check_term_UntypedSortUnknown(t)
         || check_term_UntypedSortsPossible(t)
         || check_term_UntypedSortVariable(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_SortId([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_SortId(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_SortConsType([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_SortList(t)
         || check_term_SortSet(t)
         || check_term_SortBag(t)
         || check_term_SortFSet(t)
         || check_term_SortFBag(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_StructCons([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_StructCons(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_StructProj([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_StructProj(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_DataExpr([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_rule_DataVarId(t)
         || check_rule_OpId(t)
         || check_term_DataAppl(t)
         || check_term_Binder(t)
         || check_term_Whr(t)
         || check_term_UntypedIdentifier(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_DataVarId([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_DataVarId(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_OpId([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_OpId(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_UntypedDataParameter([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_UntypedDataParameter(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_BindingOperator([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_Forall(t)
         || check_term_Exists(t)
         || check_term_SetComp(t)
         || check_term_BagComp(t)
         || check_term_Lambda(t)
         || check_term_UntypedSetBagComp(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_WhrDecl([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_rule_DataVarIdInit(t)
         || check_rule_UntypedIdentifierAssignment(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_DataVarIdInit([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_DataVarIdInit(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_UntypedIdentifierAssignment([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_UntypedIdentifierAssignment(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_DataSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_DataSpec(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_SortSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_SortSpec(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_ConsSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_ConsSpec(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_MapSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_MapSpec(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_DataEqnSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_DataEqnSpec(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_SortDecl([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_rule_SortId(t)
         || check_term_SortRef(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_DataEqn([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_DataEqn(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_MultAct([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_MultAct(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_TimedMultAct([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_TimedMultAct(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_UntypedMultiAction([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_UntypedMultiAction(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_Action([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_Action(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_ActId([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_ActId(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_ProcExpr([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_rule_Action(t)
         || check_term_Process(t)
         || check_term_ProcessAssignment(t)
         || check_term_Delta(t)
         || check_term_Tau(t)
         || check_term_Sum(t)
         || check_term_Block(t)
         || check_term_Hide(t)
         || check_term_Rename(t)
         || check_term_Comm(t)
         || check_term_Allow(t)
         || check_term_Sync(t)
         || check_term_AtTime(t)
         || check_term_Seq(t)
         || check_term_IfThen(t)
         || check_term_IfThenElse(t)
         || check_term_BInit(t)
         || check_term_Merge(t)
         || check_term_LMerge(t)
         || check_term_Choice(t)
         || check_term_StochasticOperator(t)
         || check_term_UntypedProcessAssignment(t)
         || check_rule_UntypedDataParameter(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_ProcVarId([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_ProcVarId(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_MultActName([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_MultActName(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_RenameExpr([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_RenameExpr(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_CommExpr([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_CommExpr(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_ProcSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_ProcSpec(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_ActSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_ActSpec(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_GlobVarSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_GlobVarSpec(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_ProcEqnSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_ProcEqnSpec(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_ProcEqn([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_ProcEqn(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_MultActOrDelta([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_rule_MultAct(t)
         || check_term_Delta(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_ProcInit([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_ProcessInit(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_Distribution([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_Distribution(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_LinProcSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_LinProcSpec(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_LinearProcess([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_LinearProcess(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_LinearProcessSummand([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_LinearProcessSummand(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_LinearProcessInit([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_LinearProcessInit(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_StateFrm([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_rule_DataExpr(t)
         || check_term_StateTrue(t)
         || check_term_StateFalse(t)
         || check_term_StateNot(t)
         || check_term_StateMinus(t)
         || check_term_StateAnd(t)
         || check_term_StateOr(t)
         || check_term_StateImp(t)
         || check_term_StatePlus(t)
         || check_term_StateConstantMultiply(t)
         || check_term_StateConstantMultiplyAlt(t)
         || check_term_StateForall(t)
         || check_term_StateExists(t)
         || check_term_StateInfimum(t)
         || check_term_StateSupremum(t)
         || check_term_StateSum(t)
         || check_term_StateMust(t)
         || check_term_StateMay(t)
         || check_term_StateYaled(t)
         || check_term_StateYaledTimed(t)
         || check_term_StateDelay(t)
         || check_term_StateDelayTimed(t)
         || check_term_StateVar(t)
         || check_term_StateNu(t)
         || check_term_StateMu(t)
         || check_rule_UntypedDataParameter(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_RegFrm([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_rule_ActFrm(t)
         || check_term_RegNil(t)
         || check_term_RegSeq(t)
         || check_term_RegAlt(t)
         || check_term_RegTrans(t)
         || check_term_RegTransOrNil(t)
         || check_term_UntypedRegFrm(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_ActFrm([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_rule_DataExpr(t)
         || check_term_ActTrue(t)
         || check_term_ActFalse(t)
         || check_term_ActNot(t)
         || check_term_ActAnd(t)
         || check_term_ActOr(t)
         || check_term_ActImp(t)
         || check_term_ActForall(t)
         || check_term_ActExists(t)
         || check_term_ActAt(t)
         || check_term_ActMultAct(t)
         || check_rule_UntypedDataParameter(t)
         || check_rule_UntypedMultiAction(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_ParamIdOrAction([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_rule_UntypedDataParameter(t)
         || check_rule_Action(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_ActionRenameRules([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_ActionRenameRules(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_ActionRenameRule([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_ActionRenameRule(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_ActionRenameRuleRHS([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_rule_UntypedDataParameter(t)
         || check_rule_Action(t)
         || check_term_Delta(t)
         || check_term_Tau(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_ActionRenameSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_ActionRenameSpec(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_PBES([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_PBES(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_PBEqnSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_PBEqnSpec(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_PBInit([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_PBInit(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_PBEqn([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_PBEqn(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_FixPoint([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_Mu(t)
         || check_term_Nu(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_PropVarDecl([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_PropVarDecl(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_PBExpr([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_rule_DataExpr(t)
         || check_term_PBESTrue(t)
         || check_term_PBESFalse(t)
         || check_term_PBESNot(t)
         || check_term_PBESAnd(t)
         || check_term_PBESOr(t)
         || check_term_PBESImp(t)
         || check_term_PBESForall(t)
         || check_term_PBESExists(t)
         || check_rule_PropVarInst(t)
         || check_rule_UntypedDataParameter(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_PropVarInst([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_PropVarInst(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_PRES([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_PRES(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_PREqnSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_PREqnSpec(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_PRInit([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_PRInit(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_PREqn([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_term_PREqn(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

template <atermpp::IsATerm Term>
bool check_rule_PRExpr([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  return check_rule_DataExpr(t)
         || check_term_PRESTrue(t)
         || check_term_PRESFalse(t)
         || check_term_PRESMinus(t)
         || check_term_PRESAnd(t)
         || check_term_PRESOr(t)
         || check_term_PRESImp(t)
         || check_term_PRESPlus(t)
         || check_term_PRESConstantMultiply(t)
         || check_term_PRESConstantMultiplyAlt(t)
         || check_term_PRESInfimum(t)
         || check_term_PRESSupremum(t)
         || check_term_PRESSum(t)
         || check_term_PRESEqInf(t)
         || check_term_PRESEqNInf(t)
         || check_term_PRESCondSm(t)
         || check_term_PRESCondEq(t)
         || check_rule_PropVarInst(t)
         || check_rule_UntypedDataParameter(t);
#else
  return true;
#endif // MCRL2_NO_SOUNDNESS_CHECKS
}

// SortCons(SortConsType, SortExpr)
template <atermpp::IsATerm Term>
bool check_term_SortCons([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::SortCons)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_SortConsType<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_SortConsType" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_SortExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_SortExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// SortStruct(StructCons+)
template <atermpp::IsATerm Term>
bool check_term_SortStruct([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::SortStruct)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_StructCons<atermpp::aterm>, 1))
  {
    mCRL2log(log::debug) << "check_rule_StructCons" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// SortArrow(SortExpr+, SortExpr)
template <atermpp::IsATerm Term>
bool check_term_SortArrow([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::SortArrow)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_SortExpr<atermpp::aterm>, 1))
  {
    mCRL2log(log::debug) << "check_rule_SortExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_SortExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_SortExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// UntypedSortUnknown()
template <atermpp::IsATerm Term>
bool check_term_UntypedSortUnknown([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::UntypedSortUnknown)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// UntypedSortsPossible(SortExpr+)
template <atermpp::IsATerm Term>
bool check_term_UntypedSortsPossible([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::UntypedSortsPossible)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_SortExpr<atermpp::aterm>, 1))
  {
    mCRL2log(log::debug) << "check_rule_SortExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// UntypedSortVariable(Number)
template <atermpp::IsATerm Term>
bool check_term_UntypedSortVariable([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::UntypedSortVariable)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_Number<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_Number" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// SortId(String)
template <atermpp::IsATerm Term>
bool check_term_SortId([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::SortId)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_String<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_String" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// SortList()
template <atermpp::IsATerm Term>
bool check_term_SortList([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::SortList)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// SortSet()
template <atermpp::IsATerm Term>
bool check_term_SortSet([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::SortSet)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// SortBag()
template <atermpp::IsATerm Term>
bool check_term_SortBag([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::SortBag)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// SortFSet()
template <atermpp::IsATerm Term>
bool check_term_SortFSet([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::SortFSet)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// SortFBag()
template <atermpp::IsATerm Term>
bool check_term_SortFBag([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::SortFBag)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StructCons(String, StructProj*, StringOrEmpty)
template <atermpp::IsATerm Term>
bool check_term_StructCons([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StructCons)
  {
    return false;
  }

  // check the children
  if (term.size() != 3)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_String<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_String" << std::endl;
    return false;
  }
  if (!check_list_argument(term[1], check_rule_StructProj<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_StructProj" << std::endl;
    return false;
  }
  if (!check_term_argument(term[2], check_rule_StringOrEmpty<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_StringOrEmpty" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StructProj(StringOrEmpty, SortExpr)
template <atermpp::IsATerm Term>
bool check_term_StructProj([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StructProj)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_StringOrEmpty<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_StringOrEmpty" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_SortExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_SortExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// Binder(BindingOperator, DataVarId+, DataExpr)
template <atermpp::IsATerm Term>
bool check_term_Binder([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::Binder)
  {
    return false;
  }

  // check the children
  if (term.size() != 3)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_BindingOperator<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_BindingOperator" << std::endl;
    return false;
  }
  if (!check_list_argument(term[1], check_rule_DataVarId<atermpp::aterm>, 1))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
  if (!check_term_argument(term[2], check_rule_DataExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// Whr(DataExpr, WhrDecl+)
template <atermpp::IsATerm Term>
bool check_term_Whr([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::Whr)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_DataExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
  if (!check_list_argument(term[1], check_rule_WhrDecl<atermpp::aterm>, 1))
  {
    mCRL2log(log::debug) << "check_rule_WhrDecl" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// UntypedIdentifier(String)
template <atermpp::IsATerm Term>
bool check_term_UntypedIdentifier([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::UntypedIdentifier)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_String<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_String" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// DataVarId(String, SortExpr)
template <atermpp::IsATerm Term>
bool check_term_DataVarId([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::DataVarId)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_String<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_String" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_SortExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_SortExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// OpId(String, SortExpr, Number)
template <atermpp::IsATerm Term>
bool check_term_OpId([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::OpId)
  {
    return false;
  }

  // check the children
  if (term.size() != 3)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_String<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_String" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_SortExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_SortExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[2], check_rule_Number<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_Number" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// UntypedDataParameter(String, DataExpr*)
template <atermpp::IsATerm Term>
bool check_term_UntypedDataParameter([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::UntypedDataParameter)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_String<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_String" << std::endl;
    return false;
  }
  if (!check_list_argument(term[1], check_rule_DataExpr<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// Forall()
template <atermpp::IsATerm Term>
bool check_term_Forall([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::Forall)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// Exists()
template <atermpp::IsATerm Term>
bool check_term_Exists([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::Exists)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// SetComp()
template <atermpp::IsATerm Term>
bool check_term_SetComp([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::SetComp)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// BagComp()
template <atermpp::IsATerm Term>
bool check_term_BagComp([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::BagComp)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// Lambda()
template <atermpp::IsATerm Term>
bool check_term_Lambda([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::Lambda)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// UntypedSetBagComp()
template <atermpp::IsATerm Term>
bool check_term_UntypedSetBagComp([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::UntypedSetBagComp)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// DataVarIdInit(DataVarId, DataExpr)
template <atermpp::IsATerm Term>
bool check_term_DataVarIdInit([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::DataVarIdInit)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_DataVarId<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_DataExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// UntypedIdentifierAssignment(String, DataExpr)
template <atermpp::IsATerm Term>
bool check_term_UntypedIdentifierAssignment([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::UntypedIdentifierAssignment)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_String<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_String" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_DataExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// DataSpec(SortSpec, ConsSpec, MapSpec, DataEqnSpec)
template <atermpp::IsATerm Term>
bool check_term_DataSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::DataSpec)
  {
    return false;
  }

  // check the children
  if (term.size() != 4)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_SortSpec<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_SortSpec" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_ConsSpec<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ConsSpec" << std::endl;
    return false;
  }
  if (!check_term_argument(term[2], check_rule_MapSpec<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_MapSpec" << std::endl;
    return false;
  }
  if (!check_term_argument(term[3], check_rule_DataEqnSpec<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataEqnSpec" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// SortSpec(SortDecl*)
template <atermpp::IsATerm Term>
bool check_term_SortSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::SortSpec)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_SortDecl<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_SortDecl" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// ConsSpec(OpId*)
template <atermpp::IsATerm Term>
bool check_term_ConsSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::ConsSpec)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_OpId<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_OpId" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// MapSpec(OpId*)
template <atermpp::IsATerm Term>
bool check_term_MapSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::MapSpec)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_OpId<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_OpId" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// DataEqnSpec(DataEqn*)
template <atermpp::IsATerm Term>
bool check_term_DataEqnSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::DataEqnSpec)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_DataEqn<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_DataEqn" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// SortRef(SortId, SortExpr)
template <atermpp::IsATerm Term>
bool check_term_SortRef([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::SortRef)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_SortId<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_SortId" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_SortExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_SortExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// DataEqn(DataVarId*, DataExpr, DataExpr, DataExpr)
template <atermpp::IsATerm Term>
bool check_term_DataEqn([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::DataEqn)
  {
    return false;
  }

  // check the children
  if (term.size() != 4)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_DataVarId<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_DataExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[2], check_rule_DataExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[3], check_rule_DataExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// MultAct(Action*)
template <atermpp::IsATerm Term>
bool check_term_MultAct([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::MultAct)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_Action<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_Action" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// TimedMultAct(Action*, DataExpr)
template <atermpp::IsATerm Term>
bool check_term_TimedMultAct([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::TimedMultAct)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_Action<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_Action" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_DataExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// UntypedMultiAction(UntypedDataParameter*)
template <atermpp::IsATerm Term>
bool check_term_UntypedMultiAction([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::UntypedMultiAction)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_UntypedDataParameter<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_UntypedDataParameter" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// Action(ActId, DataExpr*)
template <atermpp::IsATerm Term>
bool check_term_Action([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::Action)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_ActId<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ActId" << std::endl;
    return false;
  }
  if (!check_list_argument(term[1], check_rule_DataExpr<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// ActId(String, SortExpr*)
template <atermpp::IsATerm Term>
bool check_term_ActId([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::ActId)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_String<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_String" << std::endl;
    return false;
  }
  if (!check_list_argument(term[1], check_rule_SortExpr<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_SortExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// Process(ProcVarId, DataExpr*)
template <atermpp::IsATerm Term>
bool check_term_Process([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::Process)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_ProcVarId<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcVarId" << std::endl;
    return false;
  }
  if (!check_list_argument(term[1], check_rule_DataExpr<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// ProcessAssignment(ProcVarId, DataVarIdInit*)
template <atermpp::IsATerm Term>
bool check_term_ProcessAssignment([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::ProcessAssignment)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_ProcVarId<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcVarId" << std::endl;
    return false;
  }
  if (!check_list_argument(term[1], check_rule_DataVarIdInit<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_DataVarIdInit" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// Delta()
template <atermpp::IsATerm Term>
bool check_term_Delta([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::Delta)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// Tau()
template <atermpp::IsATerm Term>
bool check_term_Tau([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::Tau)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// Sum(DataVarId+, ProcExpr)
template <atermpp::IsATerm Term>
bool check_term_Sum([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::Sum)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_DataVarId<atermpp::aterm>, 1))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// Block(String*, ProcExpr)
template <atermpp::IsATerm Term>
bool check_term_Block([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::Block)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_String<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_String" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// Hide(String*, ProcExpr)
template <atermpp::IsATerm Term>
bool check_term_Hide([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::Hide)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_String<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_String" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// Rename(RenameExpr*, ProcExpr)
template <atermpp::IsATerm Term>
bool check_term_Rename([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::Rename)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_RenameExpr<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_RenameExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// Comm(CommExpr*, ProcExpr)
template <atermpp::IsATerm Term>
bool check_term_Comm([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::Comm)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_CommExpr<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_CommExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// Allow(MultActName*, ProcExpr)
template <atermpp::IsATerm Term>
bool check_term_Allow([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::Allow)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_MultActName<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_MultActName" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// Sync(ProcExpr, ProcExpr)
template <atermpp::IsATerm Term>
bool check_term_Sync([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::Sync)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// AtTime(ProcExpr, DataExpr)
template <atermpp::IsATerm Term>
bool check_term_AtTime([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::AtTime)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_DataExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// Seq(ProcExpr, ProcExpr)
template <atermpp::IsATerm Term>
bool check_term_Seq([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::Seq)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// IfThen(DataExpr, ProcExpr)
template <atermpp::IsATerm Term>
bool check_term_IfThen([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::IfThen)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_DataExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// IfThenElse(DataExpr, ProcExpr, ProcExpr)
template <atermpp::IsATerm Term>
bool check_term_IfThenElse([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::IfThenElse)
  {
    return false;
  }

  // check the children
  if (term.size() != 3)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_DataExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[2], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// BInit(ProcExpr, ProcExpr)
template <atermpp::IsATerm Term>
bool check_term_BInit([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::BInit)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// Merge(ProcExpr, ProcExpr)
template <atermpp::IsATerm Term>
bool check_term_Merge([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::Merge)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// LMerge(ProcExpr, ProcExpr)
template <atermpp::IsATerm Term>
bool check_term_LMerge([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::LMerge)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// Choice(ProcExpr, ProcExpr)
template <atermpp::IsATerm Term>
bool check_term_Choice([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::Choice)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StochasticOperator(DataVarId+, DataExpr, ProcExpr)
template <atermpp::IsATerm Term>
bool check_term_StochasticOperator([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StochasticOperator)
  {
    return false;
  }

  // check the children
  if (term.size() != 3)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_DataVarId<atermpp::aterm>, 1))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_DataExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[2], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// UntypedProcessAssignment(String, UntypedIdentifierAssignment*)
template <atermpp::IsATerm Term>
bool check_term_UntypedProcessAssignment([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::UntypedProcessAssignment)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_String<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_String" << std::endl;
    return false;
  }
  if (!check_list_argument(term[1], check_rule_UntypedIdentifierAssignment<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_UntypedIdentifierAssignment" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// ProcVarId(String, DataVarId*)
template <atermpp::IsATerm Term>
bool check_term_ProcVarId([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::ProcVarId)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_String<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_String" << std::endl;
    return false;
  }
  if (!check_list_argument(term[1], check_rule_DataVarId<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// MultActName(String+)
template <atermpp::IsATerm Term>
bool check_term_MultActName([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::MultActName)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_String<atermpp::aterm>, 1))
  {
    mCRL2log(log::debug) << "check_rule_String" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// RenameExpr(String, String)
template <atermpp::IsATerm Term>
bool check_term_RenameExpr([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::RenameExpr)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_String<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_String" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_String<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_String" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// CommExpr(MultActName, String)
template <atermpp::IsATerm Term>
bool check_term_CommExpr([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::CommExpr)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_MultActName<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_MultActName" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_String<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_String" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// ProcSpec(DataSpec, ActSpec, GlobVarSpec, ProcEqnSpec, ProcInit)
template <atermpp::IsATerm Term>
bool check_term_ProcSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::ProcSpec)
  {
    return false;
  }

  // check the children
  if (term.size() != 5)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_DataSpec<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataSpec" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_ActSpec<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ActSpec" << std::endl;
    return false;
  }
  if (!check_term_argument(term[2], check_rule_GlobVarSpec<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_GlobVarSpec" << std::endl;
    return false;
  }
  if (!check_term_argument(term[3], check_rule_ProcEqnSpec<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcEqnSpec" << std::endl;
    return false;
  }
  if (!check_term_argument(term[4], check_rule_ProcInit<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcInit" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// ActSpec(ActId*)
template <atermpp::IsATerm Term>
bool check_term_ActSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::ActSpec)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_ActId<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_ActId" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// GlobVarSpec(DataVarId*)
template <atermpp::IsATerm Term>
bool check_term_GlobVarSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::GlobVarSpec)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_DataVarId<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// ProcEqnSpec(ProcEqn*)
template <atermpp::IsATerm Term>
bool check_term_ProcEqnSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::ProcEqnSpec)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_ProcEqn<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_ProcEqn" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// ProcEqn(ProcVarId, DataVarId*, ProcExpr)
template <atermpp::IsATerm Term>
bool check_term_ProcEqn([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::ProcEqn)
  {
    return false;
  }

  // check the children
  if (term.size() != 3)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_ProcVarId<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcVarId" << std::endl;
    return false;
  }
  if (!check_list_argument(term[1], check_rule_DataVarId<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
  if (!check_term_argument(term[2], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// ProcessInit(ProcExpr)
template <atermpp::IsATerm Term>
bool check_term_ProcessInit([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::ProcessInit)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_ProcExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ProcExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// Distribution(DataVarId*, DataExpr)
template <atermpp::IsATerm Term>
bool check_term_Distribution([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::Distribution)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_DataVarId<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_DataExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// LinProcSpec(DataSpec, ActSpec, GlobVarSpec, LinearProcess, LinearProcessInit)
template <atermpp::IsATerm Term>
bool check_term_LinProcSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::LinProcSpec)
  {
    return false;
  }

  // check the children
  if (term.size() != 5)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_DataSpec<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataSpec" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_ActSpec<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ActSpec" << std::endl;
    return false;
  }
  if (!check_term_argument(term[2], check_rule_GlobVarSpec<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_GlobVarSpec" << std::endl;
    return false;
  }
  if (!check_term_argument(term[3], check_rule_LinearProcess<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_LinearProcess" << std::endl;
    return false;
  }
  if (!check_term_argument(term[4], check_rule_LinearProcessInit<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_LinearProcessInit" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// LinearProcess(DataVarId*, LinearProcessSummand*)
template <atermpp::IsATerm Term>
bool check_term_LinearProcess([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::LinearProcess)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_DataVarId<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
  if (!check_list_argument(term[1], check_rule_LinearProcessSummand<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_LinearProcessSummand" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// LinearProcessSummand(DataVarId*, DataExpr, MultActOrDelta, DataExpr, DataVarIdInit*, Distribution)
template <atermpp::IsATerm Term>
bool check_term_LinearProcessSummand([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::LinearProcessSummand)
  {
    return false;
  }

  // check the children
  if (term.size() != 6)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_DataVarId<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_DataExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[2], check_rule_MultActOrDelta<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_MultActOrDelta" << std::endl;
    return false;
  }
  if (!check_term_argument(term[3], check_rule_DataExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
  if (!check_list_argument(term[4], check_rule_DataVarIdInit<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_DataVarIdInit" << std::endl;
    return false;
  }
  if (!check_term_argument(term[5], check_rule_Distribution<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_Distribution" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// LinearProcessInit(DataExpr*, Distribution)
template <atermpp::IsATerm Term>
bool check_term_LinearProcessInit([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::LinearProcessInit)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_DataExpr<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_Distribution<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_Distribution" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StateTrue()
template <atermpp::IsATerm Term>
bool check_term_StateTrue([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StateTrue)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StateFalse()
template <atermpp::IsATerm Term>
bool check_term_StateFalse([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StateFalse)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StateNot(StateFrm)
template <atermpp::IsATerm Term>
bool check_term_StateNot([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StateNot)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_StateFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_StateFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StateMinus(StateFrm)
template <atermpp::IsATerm Term>
bool check_term_StateMinus([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StateMinus)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_StateFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_StateFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StateAnd(StateFrm, StateFrm)
template <atermpp::IsATerm Term>
bool check_term_StateAnd([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StateAnd)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_StateFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_StateFrm" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_StateFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_StateFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StateOr(StateFrm, StateFrm)
template <atermpp::IsATerm Term>
bool check_term_StateOr([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StateOr)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_StateFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_StateFrm" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_StateFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_StateFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StateImp(StateFrm, StateFrm)
template <atermpp::IsATerm Term>
bool check_term_StateImp([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StateImp)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_StateFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_StateFrm" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_StateFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_StateFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StatePlus(StateFrm, StateFrm)
template <atermpp::IsATerm Term>
bool check_term_StatePlus([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StatePlus)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_StateFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_StateFrm" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_StateFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_StateFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StateConstantMultiply(DataExpr, StateFrm)
template <atermpp::IsATerm Term>
bool check_term_StateConstantMultiply([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StateConstantMultiply)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_DataExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_StateFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_StateFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StateConstantMultiplyAlt(StateFrm, DataExpr)
template <atermpp::IsATerm Term>
bool check_term_StateConstantMultiplyAlt([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StateConstantMultiplyAlt)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_StateFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_StateFrm" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_DataExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StateForall(DataVarId+, StateFrm)
template <atermpp::IsATerm Term>
bool check_term_StateForall([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StateForall)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_DataVarId<atermpp::aterm>, 1))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_StateFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_StateFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StateExists(DataVarId+, StateFrm)
template <atermpp::IsATerm Term>
bool check_term_StateExists([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StateExists)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_DataVarId<atermpp::aterm>, 1))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_StateFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_StateFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StateInfimum(DataVarId+, StateFrm)
template <atermpp::IsATerm Term>
bool check_term_StateInfimum([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StateInfimum)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_DataVarId<atermpp::aterm>, 1))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_StateFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_StateFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StateSupremum(DataVarId+, StateFrm)
template <atermpp::IsATerm Term>
bool check_term_StateSupremum([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StateSupremum)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_DataVarId<atermpp::aterm>, 1))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_StateFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_StateFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StateSum(DataVarId+, StateFrm)
template <atermpp::IsATerm Term>
bool check_term_StateSum([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StateSum)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_DataVarId<atermpp::aterm>, 1))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_StateFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_StateFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StateMust(RegFrm, StateFrm)
template <atermpp::IsATerm Term>
bool check_term_StateMust([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StateMust)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_RegFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_RegFrm" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_StateFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_StateFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StateMay(RegFrm, StateFrm)
template <atermpp::IsATerm Term>
bool check_term_StateMay([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StateMay)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_RegFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_RegFrm" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_StateFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_StateFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StateYaled()
template <atermpp::IsATerm Term>
bool check_term_StateYaled([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StateYaled)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StateYaledTimed(DataExpr)
template <atermpp::IsATerm Term>
bool check_term_StateYaledTimed([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StateYaledTimed)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_DataExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StateDelay()
template <atermpp::IsATerm Term>
bool check_term_StateDelay([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StateDelay)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StateDelayTimed(DataExpr)
template <atermpp::IsATerm Term>
bool check_term_StateDelayTimed([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StateDelayTimed)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_DataExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StateVar(String, DataExpr*)
template <atermpp::IsATerm Term>
bool check_term_StateVar([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StateVar)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_String<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_String" << std::endl;
    return false;
  }
  if (!check_list_argument(term[1], check_rule_DataExpr<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StateNu(String, DataVarIdInit*, StateFrm)
template <atermpp::IsATerm Term>
bool check_term_StateNu([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StateNu)
  {
    return false;
  }

  // check the children
  if (term.size() != 3)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_String<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_String" << std::endl;
    return false;
  }
  if (!check_list_argument(term[1], check_rule_DataVarIdInit<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_DataVarIdInit" << std::endl;
    return false;
  }
  if (!check_term_argument(term[2], check_rule_StateFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_StateFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// StateMu(String, DataVarIdInit*, StateFrm)
template <atermpp::IsATerm Term>
bool check_term_StateMu([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::StateMu)
  {
    return false;
  }

  // check the children
  if (term.size() != 3)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_String<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_String" << std::endl;
    return false;
  }
  if (!check_list_argument(term[1], check_rule_DataVarIdInit<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_DataVarIdInit" << std::endl;
    return false;
  }
  if (!check_term_argument(term[2], check_rule_StateFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_StateFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// RegNil()
template <atermpp::IsATerm Term>
bool check_term_RegNil([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::RegNil)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// RegSeq(RegFrm, RegFrm)
template <atermpp::IsATerm Term>
bool check_term_RegSeq([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::RegSeq)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_RegFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_RegFrm" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_RegFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_RegFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// RegAlt(RegFrm, RegFrm)
template <atermpp::IsATerm Term>
bool check_term_RegAlt([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::RegAlt)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_RegFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_RegFrm" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_RegFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_RegFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// RegTrans(RegFrm)
template <atermpp::IsATerm Term>
bool check_term_RegTrans([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::RegTrans)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_RegFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_RegFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// RegTransOrNil(RegFrm)
template <atermpp::IsATerm Term>
bool check_term_RegTransOrNil([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::RegTransOrNil)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_RegFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_RegFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// UntypedRegFrm(String, RegFrm, RegFrm)
template <atermpp::IsATerm Term>
bool check_term_UntypedRegFrm([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::UntypedRegFrm)
  {
    return false;
  }

  // check the children
  if (term.size() != 3)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_String<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_String" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_RegFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_RegFrm" << std::endl;
    return false;
  }
  if (!check_term_argument(term[2], check_rule_RegFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_RegFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// ActTrue()
template <atermpp::IsATerm Term>
bool check_term_ActTrue([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::ActTrue)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// ActFalse()
template <atermpp::IsATerm Term>
bool check_term_ActFalse([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::ActFalse)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// ActNot(ActFrm)
template <atermpp::IsATerm Term>
bool check_term_ActNot([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::ActNot)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_ActFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ActFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// ActAnd(ActFrm, ActFrm)
template <atermpp::IsATerm Term>
bool check_term_ActAnd([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::ActAnd)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_ActFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ActFrm" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_ActFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ActFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// ActOr(ActFrm, ActFrm)
template <atermpp::IsATerm Term>
bool check_term_ActOr([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::ActOr)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_ActFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ActFrm" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_ActFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ActFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// ActImp(ActFrm, ActFrm)
template <atermpp::IsATerm Term>
bool check_term_ActImp([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::ActImp)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_ActFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ActFrm" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_ActFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ActFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// ActForall(DataVarId+, ActFrm)
template <atermpp::IsATerm Term>
bool check_term_ActForall([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::ActForall)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_DataVarId<atermpp::aterm>, 1))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_ActFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ActFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// ActExists(DataVarId+, ActFrm)
template <atermpp::IsATerm Term>
bool check_term_ActExists([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::ActExists)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_DataVarId<atermpp::aterm>, 1))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_ActFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ActFrm" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// ActAt(ActFrm, DataExpr)
template <atermpp::IsATerm Term>
bool check_term_ActAt([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::ActAt)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_ActFrm<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ActFrm" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_DataExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// ActMultAct(Action*)
template <atermpp::IsATerm Term>
bool check_term_ActMultAct([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::ActMultAct)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_Action<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_Action" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// ActionRenameRules(ActionRenameRule*)
template <atermpp::IsATerm Term>
bool check_term_ActionRenameRules([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::ActionRenameRules)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_ActionRenameRule<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_ActionRenameRule" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// ActionRenameRule(DataVarId*, DataExpr, ParamIdOrAction, ActionRenameRuleRHS)
template <atermpp::IsATerm Term>
bool check_term_ActionRenameRule([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::ActionRenameRule)
  {
    return false;
  }

  // check the children
  if (term.size() != 4)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_DataVarId<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_DataExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[2], check_rule_ParamIdOrAction<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ParamIdOrAction" << std::endl;
    return false;
  }
  if (!check_term_argument(term[3], check_rule_ActionRenameRuleRHS<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ActionRenameRuleRHS" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// ActionRenameSpec(DataSpec, ActSpec, ActionRenameRules)
template <atermpp::IsATerm Term>
bool check_term_ActionRenameSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::ActionRenameSpec)
  {
    return false;
  }

  // check the children
  if (term.size() != 3)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_DataSpec<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataSpec" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_ActSpec<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ActSpec" << std::endl;
    return false;
  }
  if (!check_term_argument(term[2], check_rule_ActionRenameRules<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_ActionRenameRules" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PBES(DataSpec, GlobVarSpec, PBEqnSpec, PBInit)
template <atermpp::IsATerm Term>
bool check_term_PBES([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PBES)
  {
    return false;
  }

  // check the children
  if (term.size() != 4)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_DataSpec<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataSpec" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_GlobVarSpec<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_GlobVarSpec" << std::endl;
    return false;
  }
  if (!check_term_argument(term[2], check_rule_PBEqnSpec<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PBEqnSpec" << std::endl;
    return false;
  }
  if (!check_term_argument(term[3], check_rule_PBInit<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PBInit" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PBEqnSpec(PBEqn*)
template <atermpp::IsATerm Term>
bool check_term_PBEqnSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PBEqnSpec)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_PBEqn<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_PBEqn" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PBInit(PropVarInst)
template <atermpp::IsATerm Term>
bool check_term_PBInit([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PBInit)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_PropVarInst<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PropVarInst" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PBEqn(FixPoint, PropVarDecl, PBExpr)
template <atermpp::IsATerm Term>
bool check_term_PBEqn([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PBEqn)
  {
    return false;
  }

  // check the children
  if (term.size() != 3)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_FixPoint<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_FixPoint" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_PropVarDecl<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PropVarDecl" << std::endl;
    return false;
  }
  if (!check_term_argument(term[2], check_rule_PBExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PBExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// Mu()
template <atermpp::IsATerm Term>
bool check_term_Mu([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::Mu)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// Nu()
template <atermpp::IsATerm Term>
bool check_term_Nu([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::Nu)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PropVarDecl(String, DataVarId*)
template <atermpp::IsATerm Term>
bool check_term_PropVarDecl([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PropVarDecl)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_String<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_String" << std::endl;
    return false;
  }
  if (!check_list_argument(term[1], check_rule_DataVarId<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PBESTrue()
template <atermpp::IsATerm Term>
bool check_term_PBESTrue([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PBESTrue)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PBESFalse()
template <atermpp::IsATerm Term>
bool check_term_PBESFalse([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PBESFalse)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PBESNot(PBExpr)
template <atermpp::IsATerm Term>
bool check_term_PBESNot([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PBESNot)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_PBExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PBExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PBESAnd(PBExpr, PBExpr)
template <atermpp::IsATerm Term>
bool check_term_PBESAnd([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PBESAnd)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_PBExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PBExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_PBExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PBExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PBESOr(PBExpr, PBExpr)
template <atermpp::IsATerm Term>
bool check_term_PBESOr([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PBESOr)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_PBExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PBExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_PBExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PBExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PBESImp(PBExpr, PBExpr)
template <atermpp::IsATerm Term>
bool check_term_PBESImp([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PBESImp)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_PBExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PBExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_PBExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PBExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PBESForall(DataVarId+, PBExpr)
template <atermpp::IsATerm Term>
bool check_term_PBESForall([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PBESForall)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_DataVarId<atermpp::aterm>, 1))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_PBExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PBExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PBESExists(DataVarId+, PBExpr)
template <atermpp::IsATerm Term>
bool check_term_PBESExists([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PBESExists)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_DataVarId<atermpp::aterm>, 1))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_PBExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PBExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PropVarInst(String, DataExpr*)
template <atermpp::IsATerm Term>
bool check_term_PropVarInst([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PropVarInst)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_String<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_String" << std::endl;
    return false;
  }
  if (!check_list_argument(term[1], check_rule_DataExpr<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PRES(DataSpec, GlobVarSpec, PREqnSpec, PRInit)
template <atermpp::IsATerm Term>
bool check_term_PRES([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PRES)
  {
    return false;
  }

  // check the children
  if (term.size() != 4)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_DataSpec<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataSpec" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_GlobVarSpec<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_GlobVarSpec" << std::endl;
    return false;
  }
  if (!check_term_argument(term[2], check_rule_PREqnSpec<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PREqnSpec" << std::endl;
    return false;
  }
  if (!check_term_argument(term[3], check_rule_PRInit<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PRInit" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PREqnSpec(PREqn*)
template <atermpp::IsATerm Term>
bool check_term_PREqnSpec([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PREqnSpec)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_PREqn<atermpp::aterm>, 0))
  {
    mCRL2log(log::debug) << "check_rule_PREqn" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PRInit(PropVarInst)
template <atermpp::IsATerm Term>
bool check_term_PRInit([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PRInit)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_PropVarInst<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PropVarInst" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PREqn(FixPoint, PropVarDecl, PRExpr)
template <atermpp::IsATerm Term>
bool check_term_PREqn([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PREqn)
  {
    return false;
  }

  // check the children
  if (term.size() != 3)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_FixPoint<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_FixPoint" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_PropVarDecl<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PropVarDecl" << std::endl;
    return false;
  }
  if (!check_term_argument(term[2], check_rule_PRExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PRExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PRESTrue()
template <atermpp::IsATerm Term>
bool check_term_PRESTrue([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PRESTrue)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PRESFalse()
template <atermpp::IsATerm Term>
bool check_term_PRESFalse([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PRESFalse)
  {
    return false;
  }

  // check the children
  if (term.size() != 0)
  {
    return false;
  }

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PRESMinus(PRExpr)
template <atermpp::IsATerm Term>
bool check_term_PRESMinus([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PRESMinus)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_PRExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PRExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PRESAnd(PRExpr, PRExpr)
template <atermpp::IsATerm Term>
bool check_term_PRESAnd([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PRESAnd)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_PRExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PRExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_PRExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PRExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PRESOr(PRExpr, PRExpr)
template <atermpp::IsATerm Term>
bool check_term_PRESOr([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PRESOr)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_PRExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PRExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_PRExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PRExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PRESImp(PRExpr, PRExpr)
template <atermpp::IsATerm Term>
bool check_term_PRESImp([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PRESImp)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_PRExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PRExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_PRExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PRExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PRESPlus(PRExpr, PRExpr)
template <atermpp::IsATerm Term>
bool check_term_PRESPlus([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PRESPlus)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_PRExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PRExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_PRExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PRExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PRESConstantMultiply(DataExpr, PRExpr)
template <atermpp::IsATerm Term>
bool check_term_PRESConstantMultiply([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PRESConstantMultiply)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_DataExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_PRExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PRExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PRESConstantMultiplyAlt(PRExpr, DataExpr)
template <atermpp::IsATerm Term>
bool check_term_PRESConstantMultiplyAlt([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PRESConstantMultiplyAlt)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_PRExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PRExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_DataExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_DataExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PRESInfimum(DataVarId+, PRExpr)
template <atermpp::IsATerm Term>
bool check_term_PRESInfimum([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PRESInfimum)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_DataVarId<atermpp::aterm>, 1))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_PRExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PRExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PRESSupremum(DataVarId+, PRExpr)
template <atermpp::IsATerm Term>
bool check_term_PRESSupremum([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PRESSupremum)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_DataVarId<atermpp::aterm>, 1))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_PRExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PRExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PRESSum(DataVarId+, PRExpr)
template <atermpp::IsATerm Term>
bool check_term_PRESSum([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PRESSum)
  {
    return false;
  }

  // check the children
  if (term.size() != 2)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(term[0], check_rule_DataVarId<atermpp::aterm>, 1))
  {
    mCRL2log(log::debug) << "check_rule_DataVarId" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_PRExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PRExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PRESEqInf(PRExpr)
template <atermpp::IsATerm Term>
bool check_term_PRESEqInf([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PRESEqInf)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_PRExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PRExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PRESEqNInf(PRExpr)
template <atermpp::IsATerm Term>
bool check_term_PRESEqNInf([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PRESEqNInf)
  {
    return false;
  }

  // check the children
  if (term.size() != 1)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_PRExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PRExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PRESCondSm(PRExpr, PRExpr, PRExpr)
template <atermpp::IsATerm Term>
bool check_term_PRESCondSm([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PRESCondSm)
  {
    return false;
  }

  // check the children
  if (term.size() != 3)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_PRExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PRExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_PRExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PRExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[2], check_rule_PRExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PRExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}

// PRESCondEq(PRExpr, PRExpr, PRExpr)
template <atermpp::IsATerm Term>
bool check_term_PRESCondEq([[maybe_unused]] const Term& t)
{
#ifndef MCRL2_NO_SOUNDNESS_CHECKS
  // check the type of the term
  const atermpp::aterm& term(t);
  if (!term.type_is_appl())
  {
    return false;
  }
  if (term.function() != core::detail::function_symbols::PRESCondEq)
  {
    return false;
  }

  // check the children
  if (term.size() != 3)
  {
    return false;
  }
#ifndef MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(term[0], check_rule_PRExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PRExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[1], check_rule_PRExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PRExpr" << std::endl;
    return false;
  }
  if (!check_term_argument(term[2], check_rule_PRExpr<atermpp::aterm>))
  {
    mCRL2log(log::debug) << "check_rule_PRExpr" << std::endl;
    return false;
  }
#endif // MCRL2_NO_RECURSIVE_SOUNDNESS_CHECKS

#endif // MCRL2_NO_SOUNDNESS_CHECKS
  return true;
}
//--- end generated code ---//

} // namespace detail

} // namespace core

} // namespace mcrl2
#endif // MCRL2_CORE_DETAIL_SOUNDNESS_CHECKS_H
