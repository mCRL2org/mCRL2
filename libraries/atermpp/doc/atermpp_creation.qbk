[section: ATerm creation]
All aterm types have their own appropriate constructors for creating them:

    aterm_int i(10);
    aterm_real r(2.5);
    aterm_appl f(function_symbol("f", 2), aterm("x"), aterm("y")); // represents f(x,y)

There is also a convenience function `make_term` for easily creating aterms from
strings: `make_term(const std::string& format, ...)`. The `format` argument is
a string that may contain several patterns as given in the table below. For each
occurrence of a pattern, one or more additional arguments need to be supplied to
the function `make_term`.

[table ATerm++ patterns
  [[type          ] [pattern       ] [argument                    ]]
  [[Application   ] [<appl>        ] [``string pattern, arguments`` ]]
  [[Blob          ] [<blob>        ] [``int length, void* data   `` ]]
  [[Integer       ] [<int>         ] [``int value                `` ]]
  [[List          ] [<list>        ] [``aterm                    `` ]]
  [[Placeholder   ] [<placeholder> ] [``string type              `` ]]
  [[Real          ] [<real>        ] [``double value             `` ]]
  [[String        ] [<str>         ] [``string pattern, arguments`` ]]
  [[Term          ] [<term>        ] [``aterm                    `` ]]
]

The following program illustrates the usage of `make_term`.

  #include <iostream>
  #include "atermpp/atermpp.h"
  #include "mcrl2/atermpp/aterm_init.h"

  using namespace atermpp;

  void foo()
  {
    const int i       = 42;
    const char* s     = "example";
    const char* blob  = "12345678";
    const double r    = 3.14;
    const char *func  = "f";

    aterm_int  t0 = make_term("<int>" , i);         // integer value: 42
    aterm      t1 = make_term("<str>" , func);      // quoted application: "f", no args
    aterm_real t2 = make_term("<real>", r);         // real value: 3.14
    aterm_blob t3 = make_term("<blob>", 8, blob);   // blob of size 8, data: 12345678

    aterm_list l0 = make_term("[]");
    aterm_list l1 = make_term("[1,<int>,<real>]", i, r);
    aterm_list l2 = make_term("[<int>,<list>]", i+1, l1);

    aterm_appl a0 = make_term("<appl>", func);
    aterm_appl a1 = make_term("<appl(<int>)>", func, i);
    aterm_appl a2 = make_term("<appl(<int>, <term>, <list>)>", func, 42, t3, l2);
  }

  int main(int argc, char* argv[])
  {
    MCRL2_ATERMPP_INIT(argc, argv)

    foo();
    return 0;
  }

The function `match` can be used to extract pieces of aterms, as illustrated by the
following program fragment:

  aterm t = make_term("and(a,not(b))");
  aterm t1;
  aterm t2;
  if (match(t, "and(<term>,<term>)", t1, t2))
  {
    assert(t1 == make_term("a"));
    assert(t2 == make_term("not(b)"));
  }

[endsect]
