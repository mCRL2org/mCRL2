[section:user_defined User defined terms]

Suppose we want to create a class `MyTerm` that has an ATerm as attribute:

   struct MyTerm
   {
     atermpp::aterm x_;

     MyTerm(std::string x)
       : x_(atermpp::make_term(x))
     { }
   };

To make this class usable within the `atermpp` library, we must specify how
to protect it from garbage collection, and how to obtain an ATerm representation
of the term. For this the `aterm_traits` class must be used.

[heading ATerm traits]
In the `atermpp` a class is considered a term if a specialization of the class
`aterm_traits` exists for it. This is a traits class that describes how the
specialized type can be protected from garbage collection and how an ATerm
can be obtained from it. For the class `MyTerm`, the specialization looks like
this:

   namespace atermpp
   {
     template<>
     struct aterm_traits<MyTerm>
     {
       typedef ATermAppl aterm_type;
       static void protect(MyTerm t)   { t.x_.protect(); }   // protect the term against garbage collection
       static void unprotect(MyTerm t) { t.x_.unprotect(); } // undo the protection against garbage collection
       static void mark(MyTerm t)      { t.x_.mark(); }      // mark the term for not being garbage collected
                                                             // when it is inside a protected container
       static ATerm term(MyTerm t)     { return t.term(); }  // return the ATerm corresponding to t
       static ATerm* ptr(MyTerm& t)    { return &t.term(); } // return the address of the ATerm corresponding to t
     };
   } // namespace atermpp

Now that we have defined `aterm_traits<MyTerm>`, it is safe to use `MyTerm` in a protected container:

   #include "atermpp/vector.h"

   atermpp::vector<MyTerm> v;
   v.push_back(MyTerm("f(x)");
   v.push_back(MyTerm("g(y)");

Also the search and replace algorithms of section
[link mcrl2_atermpp.programming.algorithms ATerm algorithms]
can be applied to `MyTerm`.

[endsect]

