import modules ;
import stage ;
import set ;
import package ;
import common ;

constant BOOST_VERSION : 1.38.0 ;
constant BOOST_JAMROOT_MODULE : $(__name__) ;

local version-tag = [ MATCH "^([^.]+)[.]([^.]+)[.]([^.]+)" : $(BOOST_VERSION) ] ; 
if $(version-tag[3]) = 0 {
  version-tag = $(version-tag[1-2]) ;
}

constant BOOST_VERSION_TAG : $(version-tag:J="_") ;

project boost
       : requirements
          <define>BOOST_ALL_NO_LIB=1
          <define>BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS=1
          <tag>@$(__name__).tag
       ;

# This rule is called by Boost.Build to determine the name of
# target. We use it to encode build variant, compiler name and
# boost version in the target name
rule tag ( name : type ? : property-set ) {
  if $(type) in STATIC_LIB SHARED_LIB IMPORT_LIB {
    if $(layout) = versioned {
      local result = [ common.format-name
        <base> <toolset> <threading> <runtime> -$(BOOST_VERSION_TAG) -$(BUILD_ID)
            : $(name) : $(type) : $(property-set) ] ;

      if $(type) = SHARED_LIB &&
        ! ( [ $(property-set).get <target-os> ] in windows cygwin darwin aix )
      {
          result = $(result).$(BOOST_VERSION)  ;
      }
      
      return $(result) ;
    }
    else {
      return [ common.format-name <base> <threading> <runtime> -$(BUILD_ID)
                  : $(name) : $(type) : $(property-set) ] ;
    }
  }
}

libraries = [ MATCH .*libs/(.*)/build/.* : [ glob libs/*/build/Jamfile.v2 ] ] ;

# Make project ids of all libraries known.
for local l in $(libraries) {
  use-project /boost/$(l) : libs/$(l)/build ;

  alias $(l) : libs/$(l)/build//boost_$(l) : : <include>. ;
  explicit $(l) ;
}

rule boost-install ( libraries * ) {
}

alias headers : : : : <include>. ;
